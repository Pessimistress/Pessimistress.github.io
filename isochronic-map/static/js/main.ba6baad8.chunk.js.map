{"version":3,"sources":["Controls.js","graph-layer/utils.js","graph-layer/shortest-path-transform.js","graph-layer/edge-attributes-transform.js","graph-layer/constants.js","graph-layer/node-attributes-transform.js","graph-layer/node-layer.js","graph-layer/edge-layer.js","graph-layer/graph-layer.js","Map.js","load-data.js","Main.js","serviceWorker.js","index.js"],"names":["cities","value","label","mapTypes","Controls","_ref","city","mapType","setMapType","hour","setHour","setCity","react_default","a","createElement","block","className","style","position","top","left","padding","width","backgroundColor","border","form_control","baseui_select","find","d","clearable","options","labelKey","valueKey","onChange","_ref2","_ref3","slider","min","max","step","_ref4","Number","TEXTURE_WIDTH","TEXTURE_FORMATS","1","GL","R32F","2","RG32F","3","RGB32F","4","RGBA32F","DATA_FORMATS","RED","RG","RGB","RGBA","getTextureSize","nodeCount","x","height","Math","pow","ceil","log2","getFloatTexture","gl","size","_parameters","Texture2D","data","format","type","FLOAT","mipmaps","parameters","Object","defineProperty","TEXTURE_MAG_FILTER","NEAREST","TEXTURE_MIN_FILTER","dataFormat","ShortestPathTransform","classCallCheck","this","nodeValueTextures","nodeValueBuffer","Buffer","byteLength","accessor","nodeValueFramebuffer","Framebuffer","id","concat","attachments","COLOR_ATTACHMENT0","nodeValueTexture","_model","_getModel","_swapTexture","edgeCount","attributes","textureSize","resize","reallocate","setVertexCount","setAttributes","edgeSourceIndices","edgeTargetIndices","edgeValues","setUniforms","textureDims","sourceIndex","index","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","texture","attach","clear","framebuffer","color","setSubImageData","objectSpread","Float32Array","y","floor","err","return","sourceTexture","targetTexture","draw","viewport","blend","blendFunc","ONE","blendEquation","MIN","MAX","depthMask","depthTest","uniforms","nodeValueSampler","readPixelsToBuffer","target","sourceFormat","sourceType","Model","vs","fs","drawMode","POINTS","EdgePositionTransform","_sourcePositionsBuffer","_targetPositionsBuffer","_validityBuffer","nodePositionsTexture","_swapBuffer","_transform","_getTransform","_bufferChanged","update","arguments","length","_ref$nodeCount","_nodeCount","_ref$edgeCount","_edgeCount","_ref$attributes","_attributes","sourcePositionsBuffer","targetPositionsBuffer","validityBuffer","sourceBuffers","feedbackBuffers","sourcePositions","targetPositions","isValid","elementCount","nodePositionsBuffer","run","nodePositions","Transform","varyings","ISOCHRONIC_RINGS","NodePositionTransform","_nodePositionsBuffer","_nodeColorsBuffer","_nodeRadiusBuffer","_sourcePosition","slice","nodeColorsBuffer","nodeRadiusBuffer","nodeIndices","radius","moduleParameters","mode","distortion","model","updateModuleSettings","sourcePosition","nodeValues","toFixed","NodeLayer","context","get","getPrototypeOf","prototype","call","getAttributeManager","getAttributes","instancePositions","ScatterplotLayer","EdgeLayer","shaders","inject","vs:#decl","vs:#main-end","addInstanced","instanceValid","transition","LineLayer","MODE","GraphLayer","setState","_getAttributes","nodeAttributesTransform","NodeAttributesTransform","edgeAttributesTransform","EdgeAttributesTransform","shortestPathTransform","transitionDuration","iteration","Infinity","lastAttributeChange","animation","requestAnimationFrame","animate","bind","props","oldProps","changeFlags","dataChanged","updateTriggersChanged","_this$state","state","nodes","edges","attributeName","attribute","userData","setNeedsUpdate","isNode","startsWith","numInstances","allocate","updateBuffer","maxIterations","sqrt","reset","_updateAttributes","cancelAnimationFrame","_this$state2","getCurrentLayer","assign","create","Attribute","INT","t","_this$state3","ticks","_this$props","getNodePosition","getSubLayerProps","filled","stroked","lineWidthMinPixels","coordinateSystem","COORDINATE_SYSTEM","METER_OFFSETS","coordinateOrigin","getPosition","getRadius","getLineColor","TextLayer","getTextAnchor","getText","getSize","getColor","_this$props2","_this$state4","duration","easing","_transitionEasing","getSourcePosition","getTargetPosition","widthScale","instanceSourcePositions","instanceTargetPositions","transitions","getIsValid","instanceFillColors","instanceRadius","getFillColor","pickable","autoHighlight","highlightColor","_getIsochronicRings","CompositeLayer","defaultProps","getNodeIndex","getEdgeSource","getEdgeTarget","getEdgeValue","Map","viewState","graph","setSourceIndex","setViewState","deckgl","pickingRadius","controller","onViewStateChange","layers","onClick","lon","lat","start","end","times_by_hour","distance","updateTriggers","AWS_PREFIX","loadData","_x","_loadData","apply","_callee","edgesText","nodesText","regenerator_default","wrap","_context","prev","fetch","then","res","text","sent","parseCSV","console","log","abrupt","stop","lines","split","filter","Boolean","headers","shift","map","line","values","row","i","name","engine","Styletron","initialState","citySettings","loaded","App","_useState","useState","_useState2","slicedToArray","setData","loadCity","asyncToGenerator","mark","t0","error","useEffect","dist_browser_es5_es","baseui","theme","LightTheme","display","src_Controls","src_Map","alignItems","justifyContent","spinner","window","location","hostname","match","ReactDOM","render","Main","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.ba6baad8.chunk.js","sourcesContent":["import React from \"react\";\nimport {Select} from 'baseui/select';\nimport {Block} from 'baseui/block';\nimport {FormControl} from 'baseui/form-control';\nimport {Slider} from 'baseui/slider';\n\nconst cities = [\n  {value: 'cincinnati', label: 'Cincinnati'},\n  {value: 'london', label: 'London'},\n  {value: 'nairobi', label: 'Nairobi'},\n  {value: 'new-york', label: 'New York'},\n  {value: 'san-francisco', label: 'San Francisco'},\n  {value: 'seattle', label: 'Seattle'}\n];\n\nconst mapTypes = [\n  {value: 0, label: 'Base Map'},\n  {value: 1, label: 'Node Distance'},\n  {value: 2, label: 'Average Speed'},\n  {value: 3, label: 'Isochronic Map'}\n]\n\nconst Controls = ({\n  city,\n  mapType,\n  setMapType,\n  hour,\n  setHour,\n  setCity\n}) => (\n  <Block className='controls' style={{\n    position: 'fixed',\n    top: 20,\n    left: 20,\n    padding: 20,\n    width: '200px',\n    backgroundColor: 'white',\n    border: `1px solid #eee`,\n  }}>\n    <FormControl label=\"City\">\n    <Select value={[cities.find(d => d.value === city)]}\n      clearable={false}\n      options={cities}\n      labelKey=\"label\"\n      valueKey=\"value\"\n      onChange={({value}) => {\n        setCity(value[0].value);\n      }}\n    />\n     </FormControl>\n     <FormControl label=\"Map Type\">\n    <Select value={[mapTypes.find(d => d.value === mapType)]}\n      clearable={false}\n      options={mapTypes}\n      labelKey=\"label\"\n      valueKey=\"value\"\n      onChange={({value}) => {\n        setMapType(value[0].value);\n      }}\n    />\n    </FormControl>\n    \n    <FormControl label=\"Hour\">\n      <Slider\n        min={0}\n        max={23}\n        step={1}\n        value={[hour]}\n        onChange={({value}) => setHour(Number(value))}\n      />\n    </FormControl>\n  </Block>\n);\n\nexport default Controls;\n","import GL from '@luma.gl/constants';\nimport {Texture2D} from '@luma.gl/core';\n\nconst TEXTURE_WIDTH = 512;\n\nconst TEXTURE_FORMATS = {\n  1: GL.R32F,\n  2: GL.RG32F,\n  3: GL.RGB32F,\n  4: GL.RGBA32F\n}\nconst DATA_FORMATS = {\n  1: GL.RED,\n  2: GL.RG,\n  3: GL.RGB,\n  4: GL.RGBA\n}\n\nfunction getNextPOT(x) {\n  return Math.pow(2, Math.max(0, Math.ceil(Math.log2(x))));\n}\n\nexport function getTexelCoord(index) {\n  return {\n    x: index % TEXTURE_WIDTH,\n    y: Math.floor(index / TEXTURE_WIDTH)\n  }\n}\n\nexport function getTextureSize(nodeCount) {\n  const width = TEXTURE_WIDTH;\n  const height = getNextPOT(nodeCount / TEXTURE_WIDTH);\n  return {width, height};\n}\n\nexport function getFloatTexture(gl, size) {\n  return new Texture2D(gl, {\n    data: null,\n    format: TEXTURE_FORMATS[size],\n    type: GL.FLOAT,\n    border: 0,\n    mipmaps: false,\n    parameters: {\n      [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n      [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n    },\n    dataFormat: DATA_FORMATS[size],\n    width: 1,\n    height: 1\n  });\n}\n\nexport function walk(graph, startNode, maxDepth = 10, depth = 0) {\n  if (startNode.visited || depth > maxDepth) {\n    return;\n  }\n  startNode.visited = true;\n  for (const edgeId in graph.edges) {\n    const edge = graph.edges[edgeId];\n    if (edge.hours[0] && edge.start_junction_id === startNode.id) {\n      walk(graph, graph.nodesById[edge.end_junction_id], maxDepth, depth + 1);\n    }\n  }\n};\n","import {\n  Buffer,\n  Model,\n  Framebuffer,\n  clear,\n  // readPixelsToArray,\n  readPixelsToBuffer\n} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\n\nimport {getFloatTexture, getTextureSize, getTexelCoord} from './utils';\n\nexport default class ShortestPathTransform {\n\n  constructor(gl) {\n    const nodeValueTextures = [\n      getFloatTexture(gl, 4),\n      getFloatTexture(gl, 4)\n    ];\n    // Mirrors nodeValueTexture\n    const nodeValueBuffer = new Buffer(gl, {byteLength: 4, accessor: {size: 1, type: GL.FLOAT}});\n\n    const nodeValueFramebuffer = new Framebuffer(gl, {\n      id: `${this.id || 'transform'}-framebuffer-0`,\n      width: 1,\n      height: 1,\n      attachments: {\n        [GL.COLOR_ATTACHMENT0]: nodeValueTextures[0]\n      }\n    });\n\n    this.gl = gl;\n    this.nodeValueTexture = null;\n    this.nodeValueTextures = nodeValueTextures;\n    this.nodeValueFramebuffer = nodeValueFramebuffer;\n    this.nodeValueBuffer = nodeValueBuffer;\n\n    this._model = this._getModel(gl);\n    this._swapTexture = false;\n  }\n\n  update({nodeCount, edgeCount, attributes}) {\n    const textureSize = getTextureSize(nodeCount);\n    this.nodeValueFramebuffer.resize(textureSize);\n    // 1 float per channel, 4 changels per pixel\n    this.nodeValueBuffer.reallocate(textureSize.width * textureSize.height * 4 * 4);\n\n    this._model.setVertexCount(edgeCount);\n   \n    this._model.setAttributes({\n      edgeSourceIndices: attributes.edgeSourceIndices,\n      edgeTargetIndices: attributes.edgeTargetIndices,\n      edgeValues: attributes.edgeValues\n    });\n\n    this._model.setUniforms({\n      textureDims: [textureSize.width, textureSize.height]\n    })\n  }\n\n  reset(sourceIndex) {\n    const {gl, nodeValueFramebuffer, nodeValueTextures} = this;\n\n    for (const texture of nodeValueTextures) {\n      nodeValueFramebuffer.attach({\n        [GL.COLOR_ATTACHMENT0]: texture\n      });\n      clear(gl, {framebuffer: nodeValueFramebuffer, color: [1e6, 1e6, 1e6, 0]});\n      texture.setSubImageData({\n        data: new Float32Array([0, 0, 0, 0]),\n        ...getTexelCoord(sourceIndex),\n        width: 1,\n        height: 1\n      });\n    }\n  }\n\n  run() {\n    const {_swapTexture, nodeValueFramebuffer, nodeValueTextures, nodeValueBuffer, _model} = this;\n\n    const sourceTexture = nodeValueTextures[_swapTexture ? 0 : 1];\n    const targetTexture = nodeValueTextures[_swapTexture ? 1 : 0];\n    nodeValueFramebuffer.attach({\n      [GL.COLOR_ATTACHMENT0]: targetTexture\n    });\n\n    _model.draw({\n      framebuffer: nodeValueFramebuffer,\n      parameters: {\n        viewport: [0, 0, targetTexture.width, targetTexture.height],\n        blend: true,\n        blendFunc: [GL.ONE, GL.ONE, GL.ONE, GL.ONE],\n        blendEquation: [GL.MIN, GL.MAX],\n        depthMask: false,\n        depthTest: false\n      },\n      uniforms: {\n        nodeValueSampler: sourceTexture,\n      }\n    });\n\n    // Copy texture to buffer\n    // console.log(readPixelsToArray(nodeValueFramebuffer, {sourceFormat: GL.RGBA}));\n    readPixelsToBuffer(nodeValueFramebuffer, {target: nodeValueBuffer, sourceFormat: GL.RGBA, sourceType: GL.FLOAT});\n\n    this.nodeValueTexture = targetTexture;\n    this._swapTexture = !this._swapTexture;\n  }\n\n  _getModel(gl) {\n    return new Model(gl, {\n      vs: `#version 300 es\n\nuniform vec2 textureDims;\nuniform sampler2D nodeValueSampler;\n\nin float edgeSourceIndices;\nin float edgeTargetIndices;\nin vec3 edgeValues;\n\nout vec3 value;\n\nivec2 getVexelCoord(float index) {\n  float y = floor(index / textureDims.x);\n  float x = index - textureDims.x * y;\n  return ivec2(x, y);\n}\n\nvec2 getTexCoord(float index) {\n  vec2 texCoord = vec2(getVexelCoord(index)) + 0.5;\n  texCoord /= textureDims;\n\n  return texCoord;\n}\n\nvoid main() {\n  vec2 texCoord = getTexCoord(edgeTargetIndices);\n  gl_Position = vec4(texCoord * 2.0 - 1.0, 0.0, 1.0);\n\n  vec3 sourceValue = texelFetch(nodeValueSampler, getVexelCoord(edgeSourceIndices), 0).rgb;\n  value = sourceValue + edgeValues;\n}\n      `,\n      fs: `#version 300 es\nprecision highp float;\n#define MAX_VALUE 1000000.0\n\nin vec3 value;\nout vec4 color;\n\nvoid main() {\n  if (value.r >= MAX_VALUE) {\n    discard;\n  }\n  color = vec4(value, 1.0);\n}\n      `,\n      drawMode: GL.POINTS\n    });\n  }\n\n}\n","import {Buffer, Transform} from '@luma.gl/core';\nimport {getFloatTexture, getTextureSize} from './utils';\n\nexport default class EdgePositionTransform {\n  constructor(gl) {\n    this._sourcePositionsBuffer = [\n      new Buffer(gl, {accessor: {size: 3}, byteLength: 12}),\n      new Buffer(gl, {accessor: {size: 3}, byteLength: 12})\n    ];\n    this._targetPositionsBuffer = [\n      new Buffer(gl, {accessor: {size: 3}, byteLength: 12}),\n      new Buffer(gl, {accessor: {size: 3}, byteLength: 12})\n    ];\n    this._validityBuffer = [\n      new Buffer(gl, {accessor: {size: 1}, byteLength: 4}),\n      new Buffer(gl, {accessor: {size: 1}, byteLength: 4})\n    ];\n\n    this.nodePositionsTexture = getFloatTexture(gl, 4);\n\n    this._swapBuffer = false;\n    this._transform = this._getTransform(gl);\n    this._bufferChanged = false;\n\n    this.gl = gl;\n  }\n\n  get sourcePositionsBuffer() {\n    return this._sourcePositionsBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  get targetPositionsBuffer() {\n    return this._targetPositionsBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  get validityBuffer() {\n    return this._validityBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  reset(sourceIndex) {\n    if (this._bufferChanged) {\n      this.update();\n    }\n  }\n\n  update({nodeCount = this._nodeCount, edgeCount = this._edgeCount, attributes = this._attributes} = {}) {\n    this._swapBuffer = !this._swapBuffer;\n    this._nodeCount = nodeCount;\n    this._edgeCount = edgeCount;\n    this._attributes = attributes;\n\n    const {nodePositionsTexture, sourcePositionsBuffer, targetPositionsBuffer, validityBuffer} = this;\n    nodePositionsTexture.resize(getTextureSize(nodeCount));\n\n    sourcePositionsBuffer.reallocate(edgeCount * 3 * 4);\n    targetPositionsBuffer.reallocate(edgeCount * 3 * 4);\n    validityBuffer.reallocate(edgeCount * 4);\n\n    this._transform.update({\n      sourceBuffers: {\n        edgeSourceIndices: attributes.edgeSourceIndices,\n        edgeTargetIndices: attributes.edgeTargetIndices,\n      },\n      feedbackBuffers: {\n        sourcePositions: this.sourcePositionsBuffer,\n        targetPositions: this.targetPositionsBuffer,\n        isValid: this.validityBuffer\n      },\n      elementCount: edgeCount\n    });\n\n    this._bufferChanged = false;\n  }\n\n  run({nodePositionsBuffer}) {\n    const {_transform, nodePositionsTexture} = this;\n    nodePositionsTexture.setSubImageData({data: nodePositionsBuffer});\n\n    _transform.run({\n      uniforms: {\n        nodePositions: nodePositionsTexture,\n        textureDims: [nodePositionsTexture.width, nodePositionsTexture.height]\n      }\n    });\n\n    this._bufferChanged = true;\n    // console.log(this.validityBuffer.getData());\n  }\n\n  _getTransform(gl) {\n    return new Transform(gl, {\n      vs: `\\\n#version 300 es\nin float edgeSourceIndices;\nin float edgeTargetIndices;\n\nuniform sampler2D nodePositions;\nuniform vec2 textureDims;\n\nout vec3 sourcePositions;\nout vec3 targetPositions;\nout float isValid;\n\nivec2 getVexelCoord(float index) {\n  float y = floor(index / textureDims.x);\n  float x = index - textureDims.x * y;\n  return ivec2(x, y);\n}\n\nvoid main() {\n  ivec2 sourceCoord = getVexelCoord(edgeSourceIndices);\n  ivec2 targetoord = getVexelCoord(edgeTargetIndices);\n\n  vec4 source = texelFetch(nodePositions, sourceCoord, 0);\n  vec4 target = texelFetch(nodePositions, targetoord, 0);\n\n  sourcePositions = source.rgb;\n  targetPositions = target.rgb;\n\n  isValid = source.a * target.a;\n}\n`,\n      varyings: ['sourcePositions', 'targetPositions', 'isValid'],\n      elementCount: 1,\n\n      feedbackBuffers: {\n        sourcePositions: this.sourcePositionsBuffer,\n        targetPositions: this.targetPositionsBuffer,\n        isValid: this.validityBuffer\n      }\n    });\n  }\n}\n","\nexport const TRANSITION_FRAMES = 60;\nexport const ISOCHRONIC_SCALE = 6; // seconds per meter\n\nexport const ISOCHRONIC_RINGS = [\n  120, // 2 min\n  300, // 5 min\n  600, // 10 min\n  900, // 15 min\n  1200, // 20 min\n  1800, // 30 min\n  2700, // 45 min\n  3600 // 60 min\n];\n","import {Buffer, Transform} from '@luma.gl/core';\nimport {getTextureSize} from './utils';\n\nimport {ISOCHRONIC_SCALE} from './constants';\n\nexport default class NodePositionTransform {\n  constructor(gl) {\n    this._nodePositionsBuffer = [\n      new Buffer(gl, {accessor: {size: 4}, byteLength: 12}),\n      new Buffer(gl, {accessor: {size: 4}, byteLength: 12})\n    ];\n    this._nodeColorsBuffer = [\n      new Buffer(gl, {accessor: {size: 4}, byteLength: 16}),\n      new Buffer(gl, {accessor: {size: 4}, byteLength: 16})\n    ];\n    this._nodeRadiusBuffer = [\n      new Buffer(gl, {accessor: {size: 1}, byteLength: 4}),\n      new Buffer(gl, {accessor: {size: 1}, byteLength: 4})\n    ];\n\n    this._swapBuffer = false;\n    this._bufferChanged = false;\n\n    this._transform = this._getTransform(gl);\n\n    this.gl = gl;\n  }\n\n  get nodePositionsBuffer() {\n    return this._nodePositionsBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  get nodeColorsBuffer() {\n    return this._nodeColorsBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  get nodeRadiusBuffer() {\n    return this._nodeRadiusBuffer[this._swapBuffer ? 1 : 0];\n  }\n\n  reset(sourceIndex) {\n    this._sourcePosition = this._transform.sourceBuffers[0].nodePositions.value.slice(sourceIndex * 2, sourceIndex * 2 + 2);\n    \n    if (this._bufferChanged) {\n      this.update();\n    }\n  }\n\n  update({nodeCount = this._nodeCount, attributes = this._attributes} = {}) {\n    this._swapBuffer = !this._swapBuffer;\n    this._nodeCount = nodeCount;\n    this._attributes = attributes;\n\n    const textureSize = getTextureSize(nodeCount);\n    this.nodePositionsBuffer.reallocate(textureSize.width * textureSize.height * 4 * 4);\n    this.nodeColorsBuffer.reallocate(textureSize.width * textureSize.height * 4 * 4);\n    this.nodeRadiusBuffer.reallocate(textureSize.width * textureSize.height * 4);\n\n    this._transform.update({\n      sourceBuffers: {\n        nodePositions: attributes.nodePositions,\n        nodeIndices: attributes.nodeIndices\n      },\n      feedbackBuffers: {\n        position: this.nodePositionsBuffer,\n        color: this.nodeColorsBuffer,\n        radius: this.nodeRadiusBuffer\n      },\n      elementCount: nodeCount\n    });\n    this._bufferChanged = false;\n  }\n\n  run({moduleParameters, mode, nodeValueTexture, distortion}) {\n    this._transform.model.updateModuleSettings(moduleParameters);\n    this._transform.run({\n      uniforms: {\n        sourcePosition: this._sourcePosition,\n        nodeValues: nodeValueTexture,\n        mode,\n        distortion,\n        textureDims: [nodeValueTexture.width, nodeValueTexture.height]\n      }\n    });\n    this._bufferChanged = true;\n\n    // console.log(this.nodeColorsBuffer.getData());\n  }\n\n  _getTransform(gl) {\n    return new Transform(gl, {\n      vs: `\\\n#version 300 es\n\n#define MODE_NONE 0\n#define MODE_NODE_DISTANCE 1\n#define MODE_TRAFFIC 2\n#define MODE_ISOCHRONIC 3\n\nin vec2 nodePositions;\nin float nodeIndices;\n\nuniform int mode;\nuniform sampler2D nodeValues;\nuniform vec2 textureDims;\nuniform vec2 sourcePosition;\nuniform float distortion;\n\nout vec4 position;\nout vec4 color;\nout float radius;\n\nconst vec4 GREEN = vec4(0., 255., 0., 255.);\nconst vec4 YELLOW = vec4(255., 255., 0., 255.);\nconst vec4 RED = vec4(255., 0., 0., 255.);\nconst vec4 BLACK = vec4(0., 0., 0., 255.);\nconst vec4 GRAY = vec4(200., 200., 200., 100.);\n\nivec2 getVexelCoord(float index) {\n  float y = floor(index / textureDims.x);\n  float x = index - textureDims.x * y;\n  return ivec2(x, y);\n}\n\nvec4 colorScale(float r) {\n  vec4 c = mix(GREEN, YELLOW, r);\n  c = mix(c, RED, max(r - 1.0, 0.0));\n  c = mix(c, BLACK, min(1.0, max(r - 2.0, 0.0)));\n  return c;\n}\n\nvoid main() {\n  vec4 valuePixel = texelFetch(nodeValues, getVexelCoord(nodeIndices), 0);\n  float travelTime = valuePixel.r;\n  float streetDistance = valuePixel.g;\n  float nodeDistance = valuePixel.b;\n  float isValid = valuePixel.a;\n\n  position = vec4(nodePositions, 0.0, isValid);\n  color = GRAY;\n  radius = 10.;\n\n  if (mode == MODE_NODE_DISTANCE) {\n\n    color = mix(color, BLACK, isValid);\n    radius = mix(radius, sqrt(nodeDistance) * 5., isValid);\n\n  } else if (mode == MODE_TRAFFIC) {\n\n    float r = travelTime / streetDistance * 12.;\n    r = mix(0.0, r, distortion * isValid);\n    position.z = r * 400.;\n    radius = mix(radius, radius * 3.0, isValid);\n    color = mix(GRAY, colorScale(r), isValid);\n\n  } else if (mode == MODE_ISOCHRONIC) {\n\n    float geoDistance = length((nodePositions - sourcePosition) * project_uCommonUnitsPerWorldUnit.xy / project_uCommonUnitsPerMeter.xy);\n    float r = travelTime / geoDistance * ${ISOCHRONIC_SCALE.toFixed(1)};\n    r = mix(1.0, r, distortion * isValid);\n    position.xy = mix(sourcePosition, nodePositions, r);\n    radius = mix(radius, radius * 3.0, isValid);\n    color = mix(GRAY, colorScale(r), isValid);\n\n  }\n}\n`,\n      varyings: ['position', 'color', 'radius'],\n      elementCount: 1,\n\n      feedbackBuffers: {\n        position: this.nodePositionsBuffer,\n        color: this.nodeColorsBuffer,\n        radius: this.nodeRadiusBuffer\n      }\n    });\n  }\n}\n","import {ScatterplotLayer} from '@deck.gl/layers';\n\nexport default class NodeLayer extends ScatterplotLayer {\n  initializeState(context) {\n    super.initializeState(context);\n\n    // TODO: deck.gl's Attribute's update does not respect external buffer's stride\n    this.getAttributeManager().getAttributes().instancePositions.size = 4;\n  }\n}\n","import {LineLayer} from '@deck.gl/layers';\n\nexport default class EdgeLayer extends LineLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.inject = {\n      'vs:#decl': `\nattribute float instanceValid;\n`,\n      'vs:#main-end': `\nvColor.a *= instanceValid + 0.1;\n`\n    };\n    return shaders;\n  }\n\n  initializeState(context) {\n    super.initializeState(context);\n\n    // TODO: deck.gl's Attribute's update does not respect external buffer's offset or stride\n    this.getAttributeManager().addInstanced({\n      instanceValid: {size: 1, accessor: 'getIsValid', transition: true}\n    });\n  }\n}\n","import {CompositeLayer, COORDINATE_SYSTEM} from '@deck.gl/core';\nimport Attribute from '@deck.gl/core/dist/esm/lib/attribute';\n\nimport GL from '@luma.gl/constants';\n\nimport ShortestPathTransform from './shortest-path-transform';\nimport EdgeAttributesTransform from './edge-attributes-transform';\nimport NodeAttributesTransform from './node-attributes-transform';\n\nimport {ScatterplotLayer, TextLayer} from '@deck.gl/layers';\nimport NodeLayer from './node-layer';\nimport EdgeLayer from './edge-layer';\n\nimport {TRANSITION_FRAMES, ISOCHRONIC_SCALE, ISOCHRONIC_RINGS} from './constants';\n\nconst MODE = {\n  NONE: 0,\n  NODE_DISTANCE: 1,\n  TRAFFIC: 2,\n  ISOCHRONIC: 3\n};\n\nexport default class GraphLayer extends CompositeLayer {\n\n  initializeState({gl}) {\n    this.setState({\n      attributes: this._getAttributes(gl),\n      nodeAttributesTransform: new NodeAttributesTransform(gl),\n      edgeAttributesTransform: new EdgeAttributesTransform(gl),\n      shortestPathTransform: new ShortestPathTransform(gl),\n      transitionDuration: 0,\n      iteration: Infinity,\n      lastAttributeChange: -1,\n      animation: requestAnimationFrame(this.animate.bind(this))\n    });\n  }\n\n  updateState({props, oldProps, changeFlags}) {\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged;\n    const {attributes, shortestPathTransform, nodeAttributesTransform, edgeAttributesTransform} = this.state;\n\n    if (props.data && dataChanged) {\n      const nodeCount = props.data.nodes.length;\n      const edgeCount = props.data.edges.length;\n\n      for (const attributeName in attributes) {\n        const attribute = attributes[attributeName];\n\n        if (changeFlags.dataChanged ||\n          (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged[attribute.userData.accessor])) {\n          attribute.setNeedsUpdate();\n          const isNode = attributeName.startsWith('node');\n          const numInstances = isNode ? nodeCount : edgeCount;\n          attribute.allocate(numInstances);\n          attribute.updateBuffer({\n            numInstances,\n            data: isNode ? props.data.nodes : props.data.edges,\n            props,\n            context: this\n          })\n        }\n      }\n\n      // Reset model\n      shortestPathTransform.update({nodeCount, edgeCount, attributes});\n      nodeAttributesTransform.update({nodeCount, edgeCount, attributes});\n      edgeAttributesTransform.update({nodeCount, edgeCount, attributes});\n\n      this.setState({\n        transitionDuration: edgeCount,\n        maxIterations: Math.ceil(Math.sqrt(nodeCount)) + TRANSITION_FRAMES\n      });\n    }\n\n    if (dataChanged || props.sourceIndex !== oldProps.sourceIndex) {\n      shortestPathTransform.reset(props.sourceIndex);\n      nodeAttributesTransform.reset(props.sourceIndex);\n      edgeAttributesTransform.reset(props.sourceIndex);\n      this.setState({iteration: 0, lastAttributeChange: 0});\n    } else if (props.mode !== oldProps.mode) {\n      nodeAttributesTransform.update();\n      edgeAttributesTransform.update();\n      if (this.state.iteration >= this.state.maxIterations) {\n        this._updateAttributes();\n      }\n      this.setState({lastAttributeChange: this.state.iteration});\n    }\n  }\n\n  finalizeState() {\n    super.finalizeState();\n\n    cancelAnimationFrame(this.state.animation);\n  }\n\n  animate() {\n    if (this.state.iteration < this.state.maxIterations) {\n      const {shortestPathTransform} = this.state;\n\n      shortestPathTransform.run();\n\n      this._updateAttributes();\n    }\n    this.state.iteration++;\n    // Try bind the callback to the latest version of the layer\n    this.state.animation = requestAnimationFrame(this.animate.bind(this));\n  }\n\n  _updateAttributes() {\n    const {shortestPathTransform, nodeAttributesTransform, edgeAttributesTransform, iteration} = this.state;\n    const props = this.getCurrentLayer().props;\n\n    const moduleParameters = Object.assign(Object.create(props), {\n      viewport: this.context.viewport\n    });\n\n    nodeAttributesTransform.run({\n      moduleParameters,\n      mode: props.mode,\n      nodeValueTexture: shortestPathTransform.nodeValueTexture,\n      distortion: Math.min(iteration / TRANSITION_FRAMES, 1)\n    });\n    edgeAttributesTransform.run({\n      nodePositionsBuffer: nodeAttributesTransform.nodePositionsBuffer\n    });\n  }\n\n  _getAttributes(gl) {\n    return {\n      nodePositions: new Attribute(gl, {\n        size: 2,\n        accessor: 'getNodePosition'\n      }),\n      nodeIndices: new Attribute(gl, {\n        size: 1,\n        accessor: 'getNodeIndex'\n      }),\n      edgeSourceIndices: new Attribute(gl, {\n        size: 1,\n        type: GL.INT,\n        accessor: 'getEdgeSource'\n      }),\n      edgeTargetIndices: new Attribute(gl, {\n        size: 1,\n        type: GL.INT,\n        accessor: 'getEdgeTarget'\n      }),\n      edgeValues: new Attribute(gl, {\n        size: 3,\n        accessor: 'getEdgeValue'\n      })\n    };\n  }\n\n  // Hack: we're using attribute transition with a moving target, so instead of\n  // interpolating linearly within duration we make duration really long and\n  // hijack the progress calculation with this easing function\n  // Can probably remove when constant speed transition is implemented\n  _transitionEasing(t) {\n    const {iteration, lastAttributeChange} = this.state;\n\n    const ticks = iteration - lastAttributeChange;\n    if (ticks <= TRANSITION_FRAMES) {\n      return ticks / TRANSITION_FRAMES;\n    }\n    return 1;\n  }\n\n  _getIsochronicRings() {\n    const {data, getNodePosition, sourceIndex, mode} = this.props;\n\n    const sourcePosition = getNodePosition(data.nodes[sourceIndex]);\n\n    return mode === MODE.ISOCHRONIC && [\n      new ScatterplotLayer(this.getSubLayerProps({\n        id: 'isochronic-rings-circle',\n        data: ISOCHRONIC_RINGS,\n        filled: false,\n        stroked: true,\n        lineWidthMinPixels: 1,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: sourcePosition,\n\n        getPosition: d => [0, 0],\n        getRadius: d => d * ISOCHRONIC_SCALE,\n        getLineColor: [0, 128, 255]\n      })),\n      new TextLayer(this.getSubLayerProps({\n        id: 'isochronic-rings-legend',\n        data: ISOCHRONIC_RINGS,\n\n        coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n        coordinateOrigin: sourcePosition,\n\n        getTextAnchor: 'start',\n        getPosition: d => [d * ISOCHRONIC_SCALE, 0],\n        getText: d => ` ${d / 60} min`,\n        getSize: 20,\n        getColor: [0, 128, 255]\n      }))\n    ];\n  }\n\n  renderLayers() {\n    const {data, getNodePosition} = this.props;\n    const {nodeAttributesTransform, edgeAttributesTransform, transitionDuration} = this.state;\n\n    const transition = this.props.transition && {\n      duration: transitionDuration,\n      easing: this._transitionEasing.bind(this)\n    };\n\n    return [\n      new EdgeLayer(this.getSubLayerProps({\n        id: 'edges',\n        data: data.edges,\n        getSourcePosition: d => [0, 0],\n        getTargetPosition: d => [0, 0],\n        getColor: [200, 200, 200],\n        widthScale: 3,\n\n        instanceSourcePositions: edgeAttributesTransform.sourcePositionsBuffer,\n        instanceTargetPositions: edgeAttributesTransform.targetPositionsBuffer,\n        instanceValid: edgeAttributesTransform.validityBuffer,\n\n        transitions: transition && {\n          getSourcePosition: transition,\n          getTargetPosition: transition,\n          getIsValid: transition\n        }\n      })),\n\n      new NodeLayer(this.getSubLayerProps({\n        id: 'nodes',\n        data: data.nodes,\n        getPosition: getNodePosition,\n\n        instancePositions: nodeAttributesTransform.nodePositionsBuffer,\n        instanceFillColors: nodeAttributesTransform.nodeColorsBuffer,\n        instanceRadius: nodeAttributesTransform.nodeRadiusBuffer,\n\n        transitions: transition && {\n          getPosition: transition,\n          getFillColor: transition,\n          getRadius: transition\n        },\n\n        pickable: true,\n        autoHighlight: true,\n        highlightColor: [0, 200, 255, 200]\n      })),\n\n      this._getIsochronicRings()\n    ]\n  }\n}\n\nGraphLayer.defaultProps = {\n  mode: MODE.NODE_DISTANCE,\n  getNodePosition: {type: 'accessor'},\n  getNodeIndex: {type: 'accessor'},\n  getEdgeSource: {type: 'accessor'},\n  getEdgeTarget: {type: 'accessor'},\n  getEdgeValue: {type: 'accessor'}\n};\n","import React from \"react\";\nimport DeckGL from \"deck.gl\";\nimport GraphLayer from './graph-layer/graph-layer.js';\n\nconst Map = ({viewState, graph, mode, setSourceIndex, setViewState, hour, sourceIndex}) => (\n  <div>\n    <DeckGL\n      viewState={viewState}\n      pickingRadius={5}\n      controller={true}\n      onViewStateChange={({viewState}) => {\n        setViewState(viewState)\n      }}\n      style={{\n        left: '280px',\n        width: 'calc(100vw - 280px)'\n      }}\n      layers={[\n        new GraphLayer({\n          data: graph,\n          sourceIndex,\n          onClick: ({index}) => {\n             setSourceIndex(index);\n          },\n          getNodePosition: d => [d.lon, d.lat],\n          getNodeIndex: (d, {index}) => index,\n          getEdgeSource: d => d.start,\n          getEdgeTarget: d => d.end,\n          getEdgeValue: d => [\n            d.times_by_hour[hour] || 1e6,\n            d.distance,\n            1\n          ],\n\n          mode,\n\n          transition: true,\n\n          updateTriggers: {\n            getEdgeValue: hour\n          }\n        })\n      ]}\n    />\n  </div>\n);\n\nexport default Map;\n","const AWS_PREFIX =\n  \"https://uber-common-public.s3-us-west-2.amazonaws.com/svc-vis-prototype/vis-hackathon-isochronic-map\";\n\nexport default async function loadData(city) {\n  const edgesText = await fetch(`${AWS_PREFIX}/${city}/edges-sm.csv`).then(res => res.text());\n  const nodesText = await fetch(`${AWS_PREFIX}/${city}/nodes-sm.csv`).then(res => res.text());\n\n  const nodes = parseCSV(nodesText);\n  const edges = parseCSV(edgesText);\n\n  console.log(`Loaded ${city}. ${nodes.length} nodes, ${edges.length} edges`);\n  return {nodes, edges};\n}\n\nfunction parseCSV(text) {\n  const lines = text.split('\\n').filter(Boolean);\n  const headers = lines.shift().split(',');\n  return lines.map(line => {\n    const values = line.split(',');\n    const row = {};\n    for (let i = 0; i < headers.length; i++) {\n      const name = headers[i];\n      row[name] = name === 'times_by_hour' ? values[i].split('\\t').map(Number) : Number(values[i]);\n    }\n    return row;\n  });\n}\n","import React, {useState, useEffect} from \"react\";\nimport {Client as Styletron} from 'styletron-engine-atomic';\nimport {Provider as StyletronProvider} from 'styletron-react';\nimport {LightTheme, BaseProvider} from 'baseui';\nimport {Spinner} from 'baseui/spinner';\nimport citySettings from \"./city-settings.json\";\nimport Controls from \"./Controls\";\nimport Map from \"./Map\";\nimport loadData from './load-data';\n\nconst engine = new Styletron();\n\nconst initialState = {\n  graph: {},\n  city: \"san-francisco\",\n  ...citySettings[\"san-francisco\"],\n  hour: 0,\n  mapType: 1,\n  loaded: false\n};\n\nfunction App() {\n  const [data, setData] = useState(initialState);\n  const loadCity = async city => {\n    try {\n      const graph = await loadData(city);\n      setData(state => ({...state, graph, loaded: true}));\n    } catch (e) {\n      console.error(e);\n    }\n  };\n  useEffect(() => {\n    if (!data.loaded) {\n      loadCity(data.city);\n    }\n  });\n  const setCity = city => {\n    setData(state => ({\n      ...state,\n      city,\n      ...citySettings[city],\n      loaded: false\n    }));\n  };\n  const setHour = hour => {\n    setData(state => ({...state, hour}));\n  };\n  const setMapType = mapType => {\n    setData(state => ({...state, mapType}));\n  };\n  const setSourceIndex = sourceIndex => {\n    setData(state => ({...state, sourceIndex}));\n  };\n  const setViewState = viewState => {\n    setData(state => ({...state, viewState}));\n  };\n\n  return (\n    <StyletronProvider value={engine}>\n      <BaseProvider theme={LightTheme}>\n        <div style={{display: 'flex', height: '100vh'}}>\n        <div style={{width: '280px', height: '100vh'}}><Controls\n          city={data.city}\n          mapType={data.mapType}\n          setMapType={setMapType}\n          hour={data.hour}\n          setHour={setHour}\n          setCity={setCity}\n        /></div>\n        <div style={{width: 'calc(100vw - 280px)', height: '100vh'}}>\n        {data.loaded ? (\n          <Map\n            viewState={data.viewState}\n            graph={data.graph}\n            hour={data.hour}\n            sourceIndex={data.sourceIndex}\n            setSourceIndex={setSourceIndex}\n            setViewState={setViewState}\n            mode={data.mapType}\n          />\n        ) : (\n          <div style={{height: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center'}}><Spinner /></div>\n        )}</div>\n        </div>\n      </BaseProvider>\n    </StyletronProvider>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './Main';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}