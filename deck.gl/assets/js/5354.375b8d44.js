"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[5354],{15804:(t,e,i)=>{i.d(e,{Z:()=>s});var n=i(51355),o=i(6745);const r={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class s{static get DRAW_MODE(){return r}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:e=(0,n.hQ)("geometry"),drawMode:i=r.TRIANGLES,attributes:o={},indices:s=null,vertexCount:c=null}=t;this.id=e,this.drawMode=0|i,this.attributes={},this.userData={},this._setAttributes(o,s),this.vertexCount=c||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return"Geometry ".concat(this.id," attribute ").concat(t)}_setAttributes(t,e){e&&(this.indices=ArrayBuffer.isView(e)?{value:e,size:1}:e);for(const i in t){let e=t[i];e=ArrayBuffer.isView(e)?{value:e}:e,(0,o.h)(ArrayBuffer.isView(e.value),"".concat(this._print(i),": must be typed array or object with value as typed array")),"POSITION"!==i&&"positions"!==i||e.size||(e.size=3),"indices"===i?((0,o.h)(!this.indices),this.indices=e):this.attributes[i]=e}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(t,e){if(e)return e.value.length;let i=1/0;for(const n in t){const e=t[n],{value:o,size:r,constant:s}=e;!s&&o&&r>=1&&(i=Math.min(i,o.length/r))}return(0,o.h)(Number.isFinite(i)),i}}},98254:(t,e,i)=>{i.d(e,{q:()=>o});const n={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};const o={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;const e={};if(void 0!==t.pickingSelectedColor)if(t.pickingSelectedColor){const i=t.pickingSelectedColor.slice(0,3);e.picking_uSelectedColorValid=1,e.picking_uSelectedColor=i}else e.picking_uSelectedColorValid=0;if(t.pickingHighlightColor){const i=Array.from(t.pickingHighlightColor,(t=>t/255));Number.isFinite(i[3])||(i[3]=1),e.picking_uHighlightColor=i}return void 0!==t.pickingActive&&(e.picking_uActive=Boolean(t.pickingActive),e.picking_uAttribute=Boolean(t.pickingAttribute)),e}}},3905:(t,e,i)=>{i.d(e,{Zo:()=>a,kt:()=>d});var n=i(67294);function o(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function r(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function s(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?r(Object(i),!0).forEach((function(e){o(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function c(t,e){if(null==t)return{};var i,n,o=function(t,e){if(null==t)return{};var i,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||(o[i]=t[i]);return o}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)i=r[n],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(o[i]=t[i])}return o}var l=n.createContext({}),u=function(t){var e=n.useContext(l),i=e;return t&&(i="function"==typeof t?t(e):s(s({},e),t)),i},a=function(t){var e=u(t.components);return n.createElement(l.Provider,{value:e},t.children)},p="mdxType",h={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},g=n.forwardRef((function(t,e){var i=t.components,o=t.mdxType,r=t.originalType,l=t.parentName,a=c(t,["components","mdxType","originalType","parentName"]),p=u(i),g=o,d=p["".concat(l,".").concat(g)]||p[g]||h[g]||r;return i?n.createElement(d,s(s({ref:e},a),{},{components:i})):n.createElement(d,s({ref:e},a))}));function d(t,e){var i=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var r=i.length,s=new Array(r);s[0]=g;var c={};for(var l in e)hasOwnProperty.call(e,l)&&(c[l]=e[l]);c.originalType=t,c[p]="string"==typeof t?t:o,s[1]=c;for(var u=2;u<r;u++)s[u]=i[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,i)}g.displayName="MDXCreateElement"},20745:(t,e,i)=>{var n=i(73935);e.s=n.createRoot,n.hydrateRoot},60850:(t,e,i)=>{function n(t,e,i,r,s,c){if(s-r<=i)return;const l=r+s>>1;o(t,e,l,r,s,c%2),n(t,e,i,r,l-1,c+1),n(t,e,i,l+1,s,c+1)}function o(t,e,i,n,s,c){for(;s>n;){if(s-n>600){const r=s-n+1,l=i-n+1,u=Math.log(r),a=.5*Math.exp(2*u/3),p=.5*Math.sqrt(u*a*(r-a)/r)*(l-r/2<0?-1:1);o(t,e,i,Math.max(n,Math.floor(i-l*a/r+p)),Math.min(s,Math.floor(i+(r-l)*a/r+p)),c)}const l=e[2*i+c];let u=n,a=s;for(r(t,e,n,i),e[2*s+c]>l&&r(t,e,n,s);u<a;){for(r(t,e,u,a),u++,a--;e[2*u+c]<l;)u++;for(;e[2*a+c]>l;)a--}e[2*n+c]===l?r(t,e,n,a):(a++,r(t,e,a,s)),a<=i&&(n=a+1),i<=a&&(s=a-1)}}function r(t,e,i,n){s(t,i,n),s(e,2*i,2*n),s(e,2*i+1,2*n+1)}function s(t,e,i){const n=t[e];t[e]=t[i],t[i]=n}function c(t,e,i,n){const o=t-i,r=e-n;return o*o+r*r}i.d(e,{Z:()=>d});const l=t=>t[0],u=t=>t[1];class a{constructor(t,e=l,i=u,o=64,r=Float64Array){this.nodeSize=o,this.points=t;const s=t.length<65536?Uint16Array:Uint32Array,c=this.ids=new s(t.length),a=this.coords=new r(2*t.length);for(let n=0;n<t.length;n++)c[n]=n,a[2*n]=e(t[n]),a[2*n+1]=i(t[n]);n(c,a,o,0,c.length-1,0)}range(t,e,i,n){return function(t,e,i,n,o,r,s){const c=[0,t.length-1,0],l=[];let u,a;for(;c.length;){const p=c.pop(),h=c.pop(),g=c.pop();if(h-g<=s){for(let s=g;s<=h;s++)u=e[2*s],a=e[2*s+1],u>=i&&u<=o&&a>=n&&a<=r&&l.push(t[s]);continue}const d=Math.floor((g+h)/2);u=e[2*d],a=e[2*d+1],u>=i&&u<=o&&a>=n&&a<=r&&l.push(t[d]);const f=(p+1)%2;(0===p?i<=u:n<=a)&&(c.push(g),c.push(d-1),c.push(f)),(0===p?o>=u:r>=a)&&(c.push(d+1),c.push(h),c.push(f))}return l}(this.ids,this.coords,t,e,i,n,this.nodeSize)}within(t,e,i){return function(t,e,i,n,o,r){const s=[0,t.length-1,0],l=[],u=o*o;for(;s.length;){const a=s.pop(),p=s.pop(),h=s.pop();if(p-h<=r){for(let o=h;o<=p;o++)c(e[2*o],e[2*o+1],i,n)<=u&&l.push(t[o]);continue}const g=Math.floor((h+p)/2),d=e[2*g],f=e[2*g+1];c(d,f,i,n)<=u&&l.push(t[g]);const m=(a+1)%2;(0===a?i-o<=d:n-o<=f)&&(s.push(h),s.push(g-1),s.push(m)),(0===a?i+o>=d:n+o>=f)&&(s.push(g+1),s.push(p),s.push(m))}return l}(this.ids,this.coords,t,e,i,this.nodeSize)}}const p={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:t=>t},h=Math.fround||(g=new Float32Array(1),t=>(g[0]=+t,g[0]));var g;class d{constructor(t){this.options=A(Object.create(p),t),this.trees=new Array(this.options.maxZoom+1)}load(t){const{log:e,minZoom:i,maxZoom:n,nodeSize:o}=this.options;e&&console.time("total time");const r=`prepare ${t.length} points`;e&&console.time(r),this.points=t;let s=[];for(let c=0;c<t.length;c++)t[c].geometry&&s.push(m(t[c],c));this.trees[n+1]=new a(s,C,x,o,Float32Array),e&&console.timeEnd(r);for(let c=n;c>=i;c--){const t=+Date.now();s=this._cluster(s,c),this.trees[c]=new a(s,C,x,o,Float32Array),e&&console.log("z%d: %d clusters in %dms",c,s.length,+Date.now()-t)}return e&&console.timeEnd("total time"),this}getClusters(t,e){let i=((t[0]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,t[1]));let o=180===t[2]?180:((t[2]+180)%360+360)%360-180;const r=Math.max(-90,Math.min(90,t[3]));if(t[2]-t[0]>=360)i=-180,o=180;else if(i>o){const t=this.getClusters([i,n,180,r],e),s=this.getClusters([-180,n,o,r],e);return t.concat(s)}const s=this.trees[this._limitZoom(e)],c=s.range(k(i),b(r),k(o),b(n)),l=[];for(const u of c){const t=s.points[u];l.push(t.numPoints?v(t):this.points[t.index])}return l}getChildren(t){const e=this._getOriginId(t),i=this._getOriginZoom(t),n="No cluster with the specified id.",o=this.trees[i];if(!o)throw new Error(n);const r=o.points[e];if(!r)throw new Error(n);const s=this.options.radius/(this.options.extent*Math.pow(2,i-1)),c=o.within(r.x,r.y,s),l=[];for(const u of c){const e=o.points[u];e.parentId===t&&l.push(e.numPoints?v(e):this.points[e.index])}if(0===l.length)throw new Error(n);return l}getLeaves(t,e,i){e=e||10,i=i||0;const n=[];return this._appendLeaves(n,t,e,i,0),n}getTile(t,e,i){const n=this.trees[this._limitZoom(t)],o=Math.pow(2,t),{extent:r,radius:s}=this.options,c=s/r,l=(i-c)/o,u=(i+1+c)/o,a={features:[]};return this._addTileFeatures(n.range((e-c)/o,l,(e+1+c)/o,u),n.points,e,i,o,a),0===e&&this._addTileFeatures(n.range(1-c/o,l,1,u),n.points,o,i,o,a),e===o-1&&this._addTileFeatures(n.range(0,l,c/o,u),n.points,-1,i,o,a),a.features.length?a:null}getClusterExpansionZoom(t){let e=this._getOriginZoom(t)-1;for(;e<=this.options.maxZoom;){const i=this.getChildren(t);if(e++,1!==i.length)break;t=i[0].properties.cluster_id}return e}_appendLeaves(t,e,i,n,o){const r=this.getChildren(e);for(const s of r){const e=s.properties;if(e&&e.cluster?o+e.point_count<=n?o+=e.point_count:o=this._appendLeaves(t,e.cluster_id,i,n,o):o<n?o++:t.push(s),t.length===i)break}return o}_addTileFeatures(t,e,i,n,o,r){for(const s of t){const t=e[s],c=t.numPoints;let l,u,a;if(c)l=_(t),u=t.x,a=t.y;else{const e=this.points[t.index];l=e.properties,u=k(e.geometry.coordinates[0]),a=b(e.geometry.coordinates[1])}const p={type:1,geometry:[[Math.round(this.options.extent*(u*o-i)),Math.round(this.options.extent*(a*o-n))]],tags:l};let h;c?h=t.id:this.options.generateId?h=t.index:this.points[t.index].id&&(h=this.points[t.index].id),void 0!==h&&(p.id=h),r.features.push(p)}}_limitZoom(t){return Math.max(this.options.minZoom,Math.min(Math.floor(+t),this.options.maxZoom+1))}_cluster(t,e){const i=[],{radius:n,extent:o,reduce:r,minPoints:s}=this.options,c=n/(o*Math.pow(2,e));for(let l=0;l<t.length;l++){const n=t[l];if(n.zoom<=e)continue;n.zoom=e;const o=this.trees[e+1],u=o.within(n.x,n.y,c),a=n.numPoints||1;let p=a;for(const t of u){const i=o.points[t];i.zoom>e&&(p+=i.numPoints||1)}if(p>a&&p>=s){let t=n.x*a,s=n.y*a,c=r&&a>1?this._map(n,!0):null;const h=(l<<5)+(e+1)+this.points.length;for(const i of u){const l=o.points[i];if(l.zoom<=e)continue;l.zoom=e;const u=l.numPoints||1;t+=l.x*u,s+=l.y*u,l.parentId=h,r&&(c||(c=this._map(n,!0)),r(c,this._map(l)))}n.parentId=h,i.push(f(t/p,s/p,h,p,c))}else if(i.push(n),p>1)for(const t of u){const n=o.points[t];n.zoom<=e||(n.zoom=e,i.push(n))}}return i}_getOriginId(t){return t-this.points.length>>5}_getOriginZoom(t){return(t-this.points.length)%32}_map(t,e){if(t.numPoints)return e?A({},t.properties):t.properties;const i=this.points[t.index].properties,n=this.options.map(i);return e&&n===i?A({},n):n}}function f(t,e,i,n,o){return{x:h(t),y:h(e),zoom:1/0,id:i,parentId:-1,numPoints:n,properties:o}}function m(t,e){const[i,n]=t.geometry.coordinates;return{x:h(k(i)),y:h(b(n)),zoom:1/0,index:e,parentId:-1}}function v(t){return{type:"Feature",id:t.id,properties:_(t),geometry:{type:"Point",coordinates:[(e=t.x,360*(e-.5)),y(t.y)]}};var e}function _(t){const e=t.numPoints,i=e>=1e4?`${Math.round(e/1e3)}k`:e>=1e3?Math.round(e/100)/10+"k":e;return A(A({},t.properties),{cluster:!0,cluster_id:t.id,point_count:e,point_count_abbreviated:i})}function k(t){return t/360+.5}function b(t){const e=Math.sin(t*Math.PI/180),i=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return i<0?0:i>1?1:i}function y(t){const e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function A(t,e){for(const i in e)t[i]=e[i];return t}function C(t){return t.x}function x(t){return t.y}}}]);