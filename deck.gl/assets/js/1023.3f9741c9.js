"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1023],{15804:(i,n,t)=>{t.d(n,{Z:()=>l});var e=t(51355),o=t(6745);const r={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class l{static get DRAW_MODE(){return r}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:n=(0,e.hQ)("geometry"),drawMode:t=r.TRIANGLES,attributes:o={},indices:l=null,vertexCount:c=null}=i;this.id=n,this.drawMode=0|t,this.attributes={},this.userData={},this._setAttributes(o,l),this.vertexCount=c||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return"Geometry ".concat(this.id," attribute ").concat(i)}_setAttributes(i,n){n&&(this.indices=ArrayBuffer.isView(n)?{value:n,size:1}:n);for(const t in i){let n=i[t];n=ArrayBuffer.isView(n)?{value:n}:n,(0,o.h)(ArrayBuffer.isView(n.value),"".concat(this._print(t),": must be typed array or object with value as typed array")),"POSITION"!==t&&"positions"!==t||n.size||(n.size=3),"indices"===t?((0,o.h)(!this.indices),this.indices=n):this.attributes[t]=n}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(i,n){if(n)return n.value.length;let t=1/0;for(const e in i){const n=i[e],{value:o,size:r,constant:l}=n;!l&&o&&r>=1&&(t=Math.min(t,o.length/r))}return(0,o.h)(Number.isFinite(t)),t}}},54591:(i,n,t)=>{t.d(n,{H:()=>l});const e="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r(){let{color:i=[0,0,0],intensity:n=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i.map((i=>i*n/255))}const l={name:"lights",vs:e,fs:e,getUniforms:function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if("lightSources"in n){const{ambientLight:i,pointLights:t,directionalLights:e}=n.lightSources||{};return i||t&&t.length>0||e&&e.length>0?Object.assign({},function(i){let{ambientLight:n,pointLights:t=[],directionalLights:e=[]}=i;const o={};return o["lighting_uAmbientLight.color"]=n?r(n):[0,0,0],t.forEach(((i,n)=>{o["lighting_uPointLight[".concat(n,"].color")]=r(i),o["lighting_uPointLight[".concat(n,"].position")]=i.position,o["lighting_uPointLight[".concat(n,"].attenuation")]=i.attenuation||[1,0,0]})),o.lighting_uPointLightCount=t.length,e.forEach(((i,n)=>{o["lighting_uDirectionalLight[".concat(n,"].color")]=r(i),o["lighting_uDirectionalLight[".concat(n,"].direction")]=i.direction})),o.lighting_uDirectionalLightCount=e.length,o}({ambientLight:i,pointLights:t,directionalLights:e}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in n){const t={pointLights:[],directionalLights:[]};for(const i of n.lights||[])switch(i.type){case"ambient":t.ambientLight=i;break;case"directional":t.directionalLights.push(i);break;case"point":t.pointLights.push(i)}return i({lightSources:t})}return{}},defines:{MAX_LIGHTS:3}}},89771:(i,n,t)=>{t.d(n,{N:()=>c,s:()=>g});var e=t(54591);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function l(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in i))return{};const{material:n}=i;return n?function(i){const{ambient:n=.35,diffuse:t=.6,shininess:e=32,specularColor:o=[30,30,30]}=i;return{lighting_uAmbient:n,lighting_uDiffuse:t,lighting_uShininess:e,lighting_uSpecularColor:o.map((i=>i/255))}}(n):{lighting_uEnabled:!1}}const c={name:"gouraud-lighting",dependencies:[e.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:l},g={name:"phong-lighting",dependencies:[e.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:l}},98254:(i,n,t)=>{t.d(n,{q:()=>o});const e={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};const o={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e;const n={};if(void 0!==i.pickingSelectedColor)if(i.pickingSelectedColor){const t=i.pickingSelectedColor.slice(0,3);n.picking_uSelectedColorValid=1,n.picking_uSelectedColor=t}else n.picking_uSelectedColorValid=0;if(i.pickingHighlightColor){const t=Array.from(i.pickingHighlightColor,(i=>i/255));Number.isFinite(t[3])||(t[3]=1),n.picking_uHighlightColor=t}return void 0!==i.pickingActive&&(n.picking_uActive=Boolean(i.pickingActive),n.picking_uAttribute=Boolean(i.pickingAttribute)),n}}},68341:(i,n,t)=>{t.d(n,{M:()=>e});const e={name:"LAS",id:"las",module:"las",version:"3.3.1",worker:!0,extensions:["las","laz"],mimeTypes:["application/octet-stream"],text:!0,binary:!0,tests:["LAS"],options:{las:{shape:"mesh",fp64:!1,skip:1,colorDepth:8}}}},3905:(i,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>d});var e=t(67294);function o(i,n,t){return n in i?Object.defineProperty(i,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):i[n]=t,i}function r(i,n){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(i);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(i,n).enumerable}))),t.push.apply(t,e)}return t}function l(i){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(i,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(i,n,Object.getOwnPropertyDescriptor(t,n))}))}return i}function c(i,n){if(null==i)return{};var t,e,o=function(i,n){if(null==i)return{};var t,e,o={},r=Object.keys(i);for(e=0;e<r.length;e++)t=r[e],n.indexOf(t)>=0||(o[t]=i[t]);return o}(i,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(i);for(e=0;e<r.length;e++)t=r[e],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(i,t)&&(o[t]=i[t])}return o}var g=e.createContext({}),a=function(i){var n=e.useContext(g),t=n;return i&&(t="function"==typeof i?i(n):l(l({},n),i)),t},s=function(i){var n=a(i.components);return e.createElement(g.Provider,{value:n},i.children)},h="mdxType",u={inlineCode:"code",wrapper:function(i){var n=i.children;return e.createElement(e.Fragment,{},n)}},p=e.forwardRef((function(i,n){var t=i.components,o=i.mdxType,r=i.originalType,g=i.parentName,s=c(i,["components","mdxType","originalType","parentName"]),h=a(t),p=o,d=h["".concat(g,".").concat(p)]||h[p]||u[p]||r;return t?e.createElement(d,l(l({ref:n},s),{},{components:t})):e.createElement(d,l({ref:n},s))}));function d(i,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof i||o){var r=t.length,l=new Array(r);l[0]=p;var c={};for(var g in n)hasOwnProperty.call(n,g)&&(c[g]=n[g]);c.originalType=i,c[h]="string"==typeof i?i:o,l[1]=c;for(var a=2;a<r;a++)l[a]=t[a];return e.createElement.apply(null,l)}return e.createElement.apply(null,t)}p.displayName="MDXCreateElement"},20745:(i,n,t)=>{var e=t(73935);n.s=e.createRoot,e.hydrateRoot}}]);