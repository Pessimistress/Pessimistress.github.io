"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[6368],{34982:(t,i,e)=>{function n(t){let i=1/0,e=1/0,n=1/0,o=-1/0,r=-1/0,s=-1/0;const l=t.POSITION?t.POSITION.value:[],c=l&&l.length;for(let a=0;a<c;a+=3){const t=l[a],c=l[a+1],h=l[a+2];i=t<i?t:i,e=c<e?c:e,n=h<n?h:n,o=t>o?t:o,r=c>r?c:r,s=h>s?h:s}return[[i,e,n],[o,r,s]]}e.d(i,{v:()=>n})},15804:(t,i,e)=>{e.d(i,{Z:()=>s});var n=e(51355),o=e(6745);const r={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class s{static get DRAW_MODE(){return r}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:i=(0,n.hQ)("geometry"),drawMode:e=r.TRIANGLES,attributes:o={},indices:s=null,vertexCount:l=null}=t;this.id=i,this.drawMode=0|e,this.attributes={},this.userData={},this._setAttributes(o,s),this.vertexCount=l||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(t){return"Geometry ".concat(this.id," attribute ").concat(t)}_setAttributes(t,i){i&&(this.indices=ArrayBuffer.isView(i)?{value:i,size:1}:i);for(const e in t){let i=t[e];i=ArrayBuffer.isView(i)?{value:i}:i,(0,o.h)(ArrayBuffer.isView(i.value),"".concat(this._print(e),": must be typed array or object with value as typed array")),"POSITION"!==e&&"positions"!==e||i.size||(i.size=3),"indices"===e?((0,o.h)(!this.indices),this.indices=i):this.attributes[e]=i}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(t,i){if(i)return i.value.length;let e=1/0;for(const n in t){const i=t[n],{value:o,size:r,constant:s}=i;!s&&o&&r>=1&&(e=Math.min(e,o.length/r))}return(0,o.h)(Number.isFinite(e)),e}}},54591:(t,i,e)=>{e.d(i,{H:()=>s});const n="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r(){let{color:t=[0,0,0],intensity:i=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.map((t=>t*i/255))}const s={name:"lights",vs:n,fs:n,getUniforms:function t(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if("lightSources"in i){const{ambientLight:t,pointLights:e,directionalLights:n}=i.lightSources||{};return t||e&&e.length>0||n&&n.length>0?Object.assign({},function(t){let{ambientLight:i,pointLights:e=[],directionalLights:n=[]}=t;const o={};return o["lighting_uAmbientLight.color"]=i?r(i):[0,0,0],e.forEach(((t,i)=>{o["lighting_uPointLight[".concat(i,"].color")]=r(t),o["lighting_uPointLight[".concat(i,"].position")]=t.position,o["lighting_uPointLight[".concat(i,"].attenuation")]=t.attenuation||[1,0,0]})),o.lighting_uPointLightCount=e.length,n.forEach(((t,i)=>{o["lighting_uDirectionalLight[".concat(i,"].color")]=r(t),o["lighting_uDirectionalLight[".concat(i,"].direction")]=t.direction})),o.lighting_uDirectionalLightCount=n.length,o}({ambientLight:t,pointLights:e,directionalLights:n}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in i){const e={pointLights:[],directionalLights:[]};for(const t of i.lights||[])switch(t.type){case"ambient":e.ambientLight=t;break;case"directional":e.directionalLights.push(t);break;case"point":e.pointLights.push(t)}return t({lightSources:e})}return{}},defines:{MAX_LIGHTS:3}}},89771:(t,i,e)=>{e.d(i,{N:()=>l,s:()=>c});var n=e(54591);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function s(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in t))return{};const{material:i}=t;return i?function(t){const{ambient:i=.35,diffuse:e=.6,shininess:n=32,specularColor:o=[30,30,30]}=t;return{lighting_uAmbient:i,lighting_uDiffuse:e,lighting_uShininess:n,lighting_uSpecularColor:o.map((t=>t/255))}}(i):{lighting_uEnabled:!1}}const l={name:"gouraud-lighting",dependencies:[n.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:s},c={name:"phong-lighting",dependencies:[n.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:s}},98254:(t,i,e)=>{e.d(i,{q:()=>o});const n={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};const o={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n;const i={};if(void 0!==t.pickingSelectedColor)if(t.pickingSelectedColor){const e=t.pickingSelectedColor.slice(0,3);i.picking_uSelectedColorValid=1,i.picking_uSelectedColor=e}else i.picking_uSelectedColorValid=0;if(t.pickingHighlightColor){const e=Array.from(t.pickingHighlightColor,(t=>t/255));Number.isFinite(e[3])||(e[3]=1),i.picking_uHighlightColor=e}return void 0!==t.pickingActive&&(i.picking_uActive=Boolean(t.pickingActive),i.picking_uAttribute=Boolean(t.pickingAttribute)),i}}},4199:(t,i,e)=>{e.d(i,{LU:()=>k});var n=e(34982);const o=/^[og]\s*(.+)?/,r=/^mtllib /,s=/^usemtl /;class l{constructor(t){let{index:i,name:e="",mtllib:n,smooth:o,groupStart:r}=t;this.index=i,this.name=e,this.mtllib=n,this.smooth=o,this.groupStart=r,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.index;return new l({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class c{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(t,i){const e=this._finalize(!1);e&&(e.inherited||e.groupCount<=0)&&this.materials.splice(e.index,1);const n=new l({index:this.materials.length,name:t,mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:void 0!==e?e.smooth:this.smooth,groupStart:void 0!==e?e.groupEnd:0});return this.materials.push(n),n}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(t){const i=this.currentMaterial();if(i&&-1===i.groupEnd&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),t&&this.materials.length>1)for(let e=this.materials.length-1;e>=0;e--)this.materials[e].groupCount<=0&&this.materials.splice(e,1);return t&&0===this.materials.length&&this.materials.push({name:"",smooth:this.smooth}),i}}class a{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(t){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.object&&!this.object.fromDeclaration)return this.object.name=t,void(this.object.fromDeclaration=i);const e=this.object&&"function"==typeof this.object.currentMaterial?this.object.currentMaterial():void 0;if(this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0),this.object=new c(t),this.object.fromDeclaration=i,e&&e.name&&"function"==typeof e.clone){const t=e.clone(0);t.inherited=!0,this.object.materials.push(t)}this.objects.push(this.object)}finalize(){this.object&&"function"==typeof this.object._finalize&&this.object._finalize(!0)}parseVertexIndex(t,i){const e=parseInt(t);return 3*(e>=0?e-1:e+i/3)}parseNormalIndex(t,i){const e=parseInt(t);return 3*(e>=0?e-1:e+i/3)}parseUVIndex(t,i){const e=parseInt(t);return 2*(e>=0?e-1:e+i/2)}addVertex(t,i,e){const n=this.vertices,o=this.object.geometry.vertices;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addVertexPoint(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addVertexLine(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addNormal(t,i,e){const n=this.normals,o=this.object.geometry.normals;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addColor(t,i,e){const n=this.colors,o=this.object.geometry.colors;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[i+0],n[i+1],n[i+2]),o.push(n[e+0],n[e+1],n[e+2])}addUV(t,i,e){const n=this.uvs,o=this.object.geometry.uvs;o.push(n[t+0],n[t+1]),o.push(n[i+0],n[i+1]),o.push(n[e+0],n[e+1])}addUVLine(t){const i=this.uvs;this.object.geometry.uvs.push(i[t+0],i[t+1])}addFace(t,i,e,n,o,r,s,l,c){const a=this.vertices.length;let h=this.parseVertexIndex(t,a),g=this.parseVertexIndex(i,a),u=this.parseVertexIndex(e,a);if(this.addVertex(h,g,u),void 0!==n&&""!==n){const t=this.uvs.length;h=this.parseUVIndex(n,t),g=this.parseUVIndex(o,t),u=this.parseUVIndex(r,t),this.addUV(h,g,u)}if(void 0!==s&&""!==s){const t=this.normals.length;h=this.parseNormalIndex(s,t),g=s===l?h:this.parseNormalIndex(l,t),u=s===c?h:this.parseNormalIndex(c,t),this.addNormal(h,g,u)}this.colors.length>0&&this.addColor(h,g,u)}addPointGeometry(t){this.object.geometry.type="Points";const i=this.vertices.length;for(const e of t)this.addVertexPoint(this.parseVertexIndex(e,i))}addLineGeometry(t,i){this.object.geometry.type="Line";const e=this.vertices.length,n=this.uvs.length;for(const o of t)this.addVertexLine(this.parseVertexIndex(o,e));for(const o of i)this.addUVLine(this.parseUVIndex(o,n))}}var h=e(87312),g=e(76379),u=e(9773),p=e(52230);function d(t){let i,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};for(const o in e)i=i||new Map,"value"!==o&&i.set(o,JSON.stringify(e[o]));const n=[];for(const o in t){const i=f(o,t[o]);n.push(i)}return new h.Z(n,i)}function f(t,i){const e=new Map;for(const o in i)"value"!==o&&e.set(o,JSON.stringify(i[o]));const n=(0,g.Y)(i.value);return!("size"in i)||1===i.size?new u.Z(t,n,!1,e):new u.Z(t,new p.t7(i.size,new u.Z("value",n)),!1,e)}function m(t,i){const{meshes:e}=function(t){const i=new a;-1!==t.indexOf("\r\n")&&(t=t.replace(/\r\n/g,"\n")),-1!==t.indexOf("\\\n")&&(t=t.replace(/\\\n/g,""));const e=t.split("\n");let n="",l="",c=0,h=[];const g="function"==typeof"".trimLeft;for(let a=0,d=e.length;a<d;a++)if(n=e[a],n=g?n.trimLeft():n.trim(),c=n.length,0!==c&&(l=n.charAt(0),"#"!==l))if("v"===l){const t=n.split(/\s+/);switch(t[0]){case"v":i.vertices.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3])),8===t.length&&i.colors.push(parseFloat(t[4]),parseFloat(t[5]),parseFloat(t[6]));break;case"vn":i.normals.push(parseFloat(t[1]),parseFloat(t[2]),parseFloat(t[3]));break;case"vt":i.uvs.push(parseFloat(t[1]),parseFloat(t[2]))}}else if("f"===l){const t=n.substr(1).trim().split(/\s+/),e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i];if(n.length>0){const t=n.split("/");e.push(t)}}const o=e[0];for(let n=1,r=e.length-1;n<r;n++){const t=e[n],r=e[n+1];i.addFace(o[0],t[0],r[0],o[1],t[1],r[1],o[2],t[2],r[2])}}else if("l"===l){const t=n.substring(1).trim().split(" ");let e;const o=[];if(-1===n.indexOf("/"))e=t;else{e=[];for(let i=0,n=t.length;i<n;i++){const n=t[i].split("/");""!==n[0]&&e.push(n[0]),""!==n[1]&&o.push(n[1])}}i.addLineGeometry(e,o)}else if("p"===l){const t=n.substr(1).trim().split(" ");i.addPointGeometry(t)}else if(null!==(h=o.exec(n))){const t=(" "+h[0].substr(1).trim()).substr(1);i.startObject(t)}else if(s.test(n))i.object.startMaterial(n.substring(7).trim(),i.materialLibraries);else if(r.test(n))i.materialLibraries.push(n.substring(7).trim());else{if("s"!==l){if("\0"===n)continue;throw new Error('Unexpected line: "'.concat(n,'"'))}{if(h=n.split(" "),h.length>1){const t=h[1].trim().toLowerCase();i.object.smooth="0"!==t&&"off"!==t}else i.object.smooth=!0;const t=i.object.currentMaterial();t&&(t.smooth=i.object.smooth)}}i.finalize();const u=[],p=[];for(const o of i.objects){const{geometry:t}=o;if(0===t.vertices.length)continue;const i={header:{vertexCount:t.vertices.length/3},attributes:{}};switch(t.type){case"Points":i.mode=0;break;case"Line":i.mode=1;break;default:i.mode=4}i.attributes.POSITION={value:new Float32Array(t.vertices),size:3},t.normals.length>0&&(i.attributes.NORMAL={value:new Float32Array(t.normals),size:3}),t.colors.length>0&&(i.attributes.COLOR_0={value:new Float32Array(t.colors),size:3}),t.uvs.length>0&&(i.attributes.TEXCOORD_0={value:new Float32Array(t.uvs),size:2}),i.materials=[];for(const e of o.materials){const t={name:e.name,flatShading:!e.smooth};i.materials.push(t),p.push(t)}i.name=o.name,u.push(i)}return{meshes:u,materials:p}}(t),l=e.reduce(((t,i)=>t+i.header.vertexCount),0),c=function(t,i){const e=new Float32Array(3*i);let n,o,r,s=0;for(const c of t){const{POSITION:t,NORMAL:l,COLOR_0:a,TEXCOORD_0:h}=c.attributes;e.set(t.value,3*s),l&&(n=n||new Float32Array(3*i),n.set(l.value,3*s)),a&&(o=o||new Float32Array(3*i),o.set(a.value,3*s)),h&&(r=r||new Float32Array(2*i),r.set(h.value,2*s)),s+=t.value.length/3}const l={};l.POSITION={value:e,size:3},n&&(l.NORMAL={value:n,size:3});o&&(l.COLOR_0={value:o,size:3});r&&(l.TEXCOORD_0={value:r,size:2});return l}(e,l),h={vertexCount:l,boundingBox:(0,n.v)(c)};return{loaderData:{header:{}},schema:d(c,{mode:4,boundingBox:h.boundingBox}),header:h,mode:4,attributes:c}}const v=/\s+/;function _(t,i){const e=[];let n={name:"placeholder"};const o=t.split("\n");for(let r of o){if(r=r.trim(),0===r.length||"#"===r.charAt(0))continue;const t=r.indexOf(" ");let i=t>=0?r.substring(0,t):r;i=i.toLowerCase();let o=t>=0?r.substring(t+1):"";switch(o=o.trim(),i){case"newmtl":n={name:o},e.push(n);break;case"ka":n.ambientColor=b(o);break;case"kd":n.diffuseColor=b(o);break;case"map_kd":n.diffuseTextureUrl=o;break;case"ks":n.specularColor=b(o);break;case"map_ks":n.specularTextureUrl=o;break;case"ke":n.emissiveColor=b(o);break;case"map_ke":n.emissiveTextureUrl=o;break;case"ns":n.shininess=parseFloat(o);break;case"map_ns":default:break;case"ni":n.refraction=parseFloat(o);break;case"illum":n.illumination=parseFloat(o)}}return e}function b(t,i){const e=t.split(v,3);return[parseFloat(e[0]),parseFloat(e[1]),parseFloat(e[2])]}const L={name:"OBJ",id:"obj",module:"obj",version:"3.3.1",worker:!0,extensions:["obj"],mimeTypes:["text/plain"],testText:function(t){return"v"===t[0]},options:{obj:{}}};const C={name:"MTL",id:"mtl",module:"mtl",version:"3.3.1",worker:!0,extensions:["mtl"],mimeTypes:["text/plain"],testText:t=>t.includes("newmtl"),options:{mtl:{}}},k={...L,parse:async(t,i)=>m((new TextDecoder).decode(t)),parseTextSync:(t,i)=>m(t)}},3905:(t,i,e)=>{e.d(i,{Zo:()=>h,kt:()=>d});var n=e(67294);function o(t,i,e){return i in t?Object.defineProperty(t,i,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[i]=e,t}function r(t,i){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);i&&(n=n.filter((function(i){return Object.getOwnPropertyDescriptor(t,i).enumerable}))),e.push.apply(e,n)}return e}function s(t){for(var i=1;i<arguments.length;i++){var e=null!=arguments[i]?arguments[i]:{};i%2?r(Object(e),!0).forEach((function(i){o(t,i,e[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(i){Object.defineProperty(t,i,Object.getOwnPropertyDescriptor(e,i))}))}return t}function l(t,i){if(null==t)return{};var e,n,o=function(t,i){if(null==t)return{};var e,n,o={},r=Object.keys(t);for(n=0;n<r.length;n++)e=r[n],i.indexOf(e)>=0||(o[e]=t[e]);return o}(t,i);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)e=r[n],i.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var c=n.createContext({}),a=function(t){var i=n.useContext(c),e=i;return t&&(e="function"==typeof t?t(i):s(s({},i),t)),e},h=function(t){var i=a(t.components);return n.createElement(c.Provider,{value:i},t.children)},g="mdxType",u={inlineCode:"code",wrapper:function(t){var i=t.children;return n.createElement(n.Fragment,{},i)}},p=n.forwardRef((function(t,i){var e=t.components,o=t.mdxType,r=t.originalType,c=t.parentName,h=l(t,["components","mdxType","originalType","parentName"]),g=a(e),p=o,d=g["".concat(c,".").concat(p)]||g[p]||u[p]||r;return e?n.createElement(d,s(s({ref:i},h),{},{components:e})):n.createElement(d,s({ref:i},h))}));function d(t,i){var e=arguments,o=i&&i.mdxType;if("string"==typeof t||o){var r=e.length,s=new Array(r);s[0]=p;var l={};for(var c in i)hasOwnProperty.call(i,c)&&(l[c]=i[c]);l.originalType=t,l[g]="string"==typeof t?t:o,s[1]=l;for(var a=2;a<r;a++)s[a]=e[a];return n.createElement.apply(null,s)}return n.createElement.apply(null,e)}p.displayName="MDXCreateElement"}}]);