"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[9774],{4380:(i,n,t)=>{t.d(n,{Z:()=>a});var e=t(87427),o=t(84448),r=t(87346);const c="https://api.cesium.com/v1/assets";async function l(i,n){if(!n){const t=await async function(i){(0,r.h)(i);const n=c,t={Authorization:"Bearer ".concat(i)},e=await(0,o.d)(n,{fetch:{headers:t}});if(!e.ok)throw new Error(e.statusText);return await e.json()}(i);for(const i of t.items)"3DTILES"===i.type&&(n=i.id)}const t=await async function(i,n){(0,r.h)(i,n);const t={Authorization:"Bearer ".concat(i)},e="".concat(c,"/").concat(n);let l=await(0,o.d)("".concat(e),{fetch:{headers:t}});if(!l.ok)throw new Error(l.statusText);let a=await l.json();if(l=await(0,o.d)("".concat(e,"/endpoint"),{fetch:{headers:t}}),!l.ok)throw new Error(l.statusText);const g=await l.json();return a={...a,...g},a}(i,n),{type:e,url:l}=t;return(0,r.h)("3DTILES"===e&&l),t.headers={Authorization:"Bearer ".concat(t.accessToken)},t}const a={...e.u,id:"cesium-ion",name:"Cesium Ion",preload:async function(i){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n=n["cesium-ion"]||{};const{accessToken:t}=n;let e=n.assetId;if(!Number.isFinite(e)){const n=i.match(/\/([0-9]+)\/tileset.json/);e=n&&n[1]}return l(t,e)},parse:async(i,n,t)=>((n={...n})["3d-tiles"]=n["cesium-ion"],n.loader=a,e.u.parse(i,n,t)),options:{"cesium-ion":{...e.u.options["3d-tiles"],accessToken:null}}}},34982:(i,n,t)=>{function e(i){let n=1/0,t=1/0,e=1/0,o=-1/0,r=-1/0,c=-1/0;const l=i.POSITION?i.POSITION.value:[],a=l&&l.length;for(let g=0;g<a;g+=3){const i=l[g],a=l[g+1],s=l[g+2];n=i<n?i:n,t=a<t?a:t,e=s<e?s:e,o=i>o?i:o,r=a>r?a:r,c=s>c?s:c}return[[n,t,e],[o,r,c]]}t.d(n,{v:()=>e})},15804:(i,n,t)=>{t.d(n,{Z:()=>c});var e=t(51355),o=t(6745);const r={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6};class c{static get DRAW_MODE(){return r}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:n=(0,e.hQ)("geometry"),drawMode:t=r.TRIANGLES,attributes:o={},indices:c=null,vertexCount:l=null}=i;this.id=n,this.drawMode=0|t,this.attributes={},this.userData={},this._setAttributes(o,c),this.vertexCount=l||this._calculateVertexCount(this.attributes,this.indices)}get mode(){return this.drawMode}getVertexCount(){return this.vertexCount}getAttributes(){return this.indices?{indices:this.indices,...this.attributes}:this.attributes}_print(i){return"Geometry ".concat(this.id," attribute ").concat(i)}_setAttributes(i,n){n&&(this.indices=ArrayBuffer.isView(n)?{value:n,size:1}:n);for(const t in i){let n=i[t];n=ArrayBuffer.isView(n)?{value:n}:n,(0,o.h)(ArrayBuffer.isView(n.value),"".concat(this._print(t),": must be typed array or object with value as typed array")),"POSITION"!==t&&"positions"!==t||n.size||(n.size=3),"indices"===t?((0,o.h)(!this.indices),this.indices=n):this.attributes[t]=n}return this.indices&&void 0!==this.indices.isIndexed&&(this.indices=Object.assign({},this.indices),delete this.indices.isIndexed),this}_calculateVertexCount(i,n){if(n)return n.value.length;let t=1/0;for(const e in i){const n=i[e],{value:o,size:r,constant:c}=n;!c&&o&&r>=1&&(t=Math.min(t,o.length/r))}return(0,o.h)(Number.isFinite(t)),t}}},54591:(i,n,t)=>{t.d(n,{H:()=>c});const e="#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n",o={lightSources:{}};function r(){let{color:i=[0,0,0],intensity:n=1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return i.map((i=>i*n/255))}const c={name:"lights",vs:e,fs:e,getUniforms:function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:o;if("lightSources"in n){const{ambientLight:i,pointLights:t,directionalLights:e}=n.lightSources||{};return i||t&&t.length>0||e&&e.length>0?Object.assign({},function(i){let{ambientLight:n,pointLights:t=[],directionalLights:e=[]}=i;const o={};return o["lighting_uAmbientLight.color"]=n?r(n):[0,0,0],t.forEach(((i,n)=>{o["lighting_uPointLight[".concat(n,"].color")]=r(i),o["lighting_uPointLight[".concat(n,"].position")]=i.position,o["lighting_uPointLight[".concat(n,"].attenuation")]=i.attenuation||[1,0,0]})),o.lighting_uPointLightCount=t.length,e.forEach(((i,n)=>{o["lighting_uDirectionalLight[".concat(n,"].color")]=r(i),o["lighting_uDirectionalLight[".concat(n,"].direction")]=i.direction})),o.lighting_uDirectionalLightCount=e.length,o}({ambientLight:i,pointLights:t,directionalLights:e}),{lighting_uEnabled:!0}):{lighting_uEnabled:!1}}if("lights"in n){const t={pointLights:[],directionalLights:[]};for(const i of n.lights||[])switch(i.type){case"ambient":t.ambientLight=i;break;case"directional":t.directionalLights.push(i);break;case"point":t.pointLights.push(i)}return i({lightSources:t})}return{}},defines:{MAX_LIGHTS:3}}},89771:(i,n,t)=>{t.d(n,{N:()=>l,s:()=>a});var e=t(54591);const o="\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n",r={};function c(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:r;if(!("material"in i))return{};const{material:n}=i;return n?function(i){const{ambient:n=.35,diffuse:t=.6,shininess:e=32,specularColor:o=[30,30,30]}=i;return{lighting_uAmbient:n,lighting_uDiffuse:t,lighting_uShininess:e,lighting_uSpecularColor:o.map((i=>i/255))}}(n):{lighting_uEnabled:!1}}const l={name:"gouraud-lighting",dependencies:[e.H],vs:o,defines:{LIGHTING_VERTEX:1},getUniforms:c},a={name:"phong-lighting",dependencies:[e.H],fs:o,defines:{LIGHTING_FRAGMENT:1},getUniforms:c}},98254:(i,n,t)=>{t.d(n,{q:()=>o});const e={pickingSelectedColor:null,pickingHighlightColor:new Uint8Array([0,255,255,255]),pickingActive:!1,pickingAttribute:!1};const o={name:"picking",vs:"uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n",fs:"uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n",getUniforms:function(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e;const n={};if(void 0!==i.pickingSelectedColor)if(i.pickingSelectedColor){const t=i.pickingSelectedColor.slice(0,3);n.picking_uSelectedColorValid=1,n.picking_uSelectedColor=t}else n.picking_uSelectedColorValid=0;if(i.pickingHighlightColor){const t=Array.from(i.pickingHighlightColor,(i=>i/255));Number.isFinite(t[3])||(t[3]=1),n.picking_uHighlightColor=t}return void 0!==i.pickingActive&&(n.picking_uActive=Boolean(i.pickingActive),n.picking_uAttribute=Boolean(i.pickingAttribute)),n}}},3905:(i,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>p});var e=t(67294);function o(i,n,t){return n in i?Object.defineProperty(i,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):i[n]=t,i}function r(i,n){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(i);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(i,n).enumerable}))),t.push.apply(t,e)}return t}function c(i){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(i,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(i,n,Object.getOwnPropertyDescriptor(t,n))}))}return i}function l(i,n){if(null==i)return{};var t,e,o=function(i,n){if(null==i)return{};var t,e,o={},r=Object.keys(i);for(e=0;e<r.length;e++)t=r[e],n.indexOf(t)>=0||(o[t]=i[t]);return o}(i,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(i);for(e=0;e<r.length;e++)t=r[e],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(i,t)&&(o[t]=i[t])}return o}var a=e.createContext({}),g=function(i){var n=e.useContext(a),t=n;return i&&(t="function"==typeof i?i(n):c(c({},n),i)),t},s=function(i){var n=g(i.components);return e.createElement(a.Provider,{value:n},i.children)},u="mdxType",h={inlineCode:"code",wrapper:function(i){var n=i.children;return e.createElement(e.Fragment,{},n)}},d=e.forwardRef((function(i,n){var t=i.components,o=i.mdxType,r=i.originalType,a=i.parentName,s=l(i,["components","mdxType","originalType","parentName"]),u=g(t),d=o,p=u["".concat(a,".").concat(d)]||u[d]||h[d]||r;return t?e.createElement(p,c(c({ref:n},s),{},{components:t})):e.createElement(p,c({ref:n},s))}));function p(i,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof i||o){var r=t.length,c=new Array(r);c[0]=d;var l={};for(var a in n)hasOwnProperty.call(n,a)&&(l[a]=n[a]);l.originalType=i,l[u]="string"==typeof i?i:o,c[1]=l;for(var g=2;g<r;g++)c[g]=t[g];return e.createElement.apply(null,c)}return e.createElement.apply(null,t)}d.displayName="MDXCreateElement"},20745:(i,n,t)=>{var e=t(73935);n.s=e.createRoot,e.hydrateRoot}}]);