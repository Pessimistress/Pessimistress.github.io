(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[1462],{32900:(t,e,i)=>{"use strict";i.d(e,{Z:()=>d});var n=i(15804),o=i(51355);const s=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]),r=new Float32Array([-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1]),a=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0]),l=new Float32Array([0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1]),c={POSITION:{size:3,value:new Float32Array(r)},NORMAL:{size:3,value:new Float32Array(a)},TEXCOORD_0:{size:2,value:new Float32Array(l)}};class d extends n.Z{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{id:e=(0,o.hQ)("cube-geometry")}=t;super({...t,id:e,indices:{size:1,value:new Uint16Array(s)},attributes:{...c,...t.attributes}})}}},3905:(t,e,i)=>{"use strict";i.d(e,{Zo:()=>d,kt:()=>g});var n=i(67294);function o(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function s(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,n)}return i}function r(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?s(Object(i),!0).forEach((function(e){o(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):s(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function a(t,e){if(null==t)return{};var i,n,o=function(t,e){if(null==t)return{};var i,n,o={},s=Object.keys(t);for(n=0;n<s.length;n++)i=s[n],e.indexOf(i)>=0||(o[i]=t[i]);return o}(t,e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(n=0;n<s.length;n++)i=s[n],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(o[i]=t[i])}return o}var l=n.createContext({}),c=function(t){var e=n.useContext(l),i=e;return t&&(i="function"==typeof t?t(e):r(r({},e),t)),i},d=function(t){var e=c(t.components);return n.createElement(l.Provider,{value:e},t.children)},u="mdxType",p={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(t,e){var i=t.components,o=t.mdxType,s=t.originalType,l=t.parentName,d=a(t,["components","mdxType","originalType","parentName"]),u=c(i),h=o,g=u["".concat(l,".").concat(h)]||u[h]||p[h]||s;return i?n.createElement(g,r(r({ref:e},d),{},{components:i})):n.createElement(g,r({ref:e},d))}));function g(t,e){var i=arguments,o=e&&e.mdxType;if("string"==typeof t||o){var s=i.length,r=new Array(s);r[0]=h;var a={};for(var l in e)hasOwnProperty.call(e,l)&&(a[l]=e[l]);a.originalType=t,a[u]="string"==typeof t?t:o,r[1]=a;for(var c=2;c<s;c++)r[c]=i[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}h.displayName="MDXCreateElement"},93932:(t,e,i)=>{"use strict";i.d(e,{Z:()=>w});var n=i(62833);const o=()=>{},s=2,r=3,a=t=>t,l=1;class c{constructor(t){this._onTransitionUpdate=t=>{const{time:e,settings:{interpolator:i,startProps:n,endProps:o,duration:s,easing:r}}=t,a=r(e/s),l=i.interpolateProps(n,o,a);this.propsInTransition=this.getControllerState({...this.props,...l}).getViewportProps(),this.onViewStateChange({viewState:this.propsInTransition,oldViewState:this.props})},this.getControllerState=t.getControllerState,this.propsInTransition=null,this.transition=new n.Z(t.timeline),this.onViewStateChange=t.onViewStateChange||o,this.onStateChange=t.onStateChange||o}finalize(){this.transition.cancel()}getViewportInTransition(){return this.propsInTransition}processViewStateChange(t){let e=!1;const i=this.props;if(this.props=t,!i||this._shouldIgnoreViewportChange(i,t))return!1;if(this._isTransitionEnabled(t)){let n=i;if(this.transition.inProgress){const{interruption:t,endProps:e}=this.transition.settings;n={...i,...t===s?e:this.propsInTransition||i}}this._triggerTransition(n,t),e=!0}else this.transition.cancel();return e}updateTransition(){this.transition.update()}_isTransitionEnabled(t){const{transitionDuration:e,transitionInterpolator:i}=t;return(e>0||"auto"===e)&&Boolean(i)}_isUpdateDueToCurrentTransition(t){return!(!this.transition.inProgress||!this.propsInTransition)&&this.transition.settings.interpolator.arePropsEqual(t,this.propsInTransition)}_shouldIgnoreViewportChange(t,e){return this.transition.inProgress?this.transition.settings.interruption===r||this._isUpdateDueToCurrentTransition(e):!this._isTransitionEnabled(e)||e.transitionInterpolator.arePropsEqual(t,e)}_triggerTransition(t,e){const i=this.getControllerState(t),n=this.getControllerState(e).shortestPathFrom(i),o=e.transitionInterpolator,s=o.getDuration?o.getDuration(t,e):e.transitionDuration;if(0===s)return;const r=o.initializeProps(t,n);this.propsInTransition={};const c={duration:s,easing:e.transitionEasing||a,interpolator:o,interruption:e.transitionInterruption||l,startProps:r.start,endProps:r.end,onStart:e.onTransitionStart,onUpdate:this._onTransitionUpdate,onInterrupt:this._onTransitionEnd(e.onTransitionInterrupt),onEnd:this._onTransitionEnd(e.onTransitionEnd)};this.transition.start(c),this.onStateChange({inTransition:!0}),this.updateTransition()}_onTransitionEnd(t){return e=>{this.propsInTransition=null,this.onStateChange({inTransition:!1,isZooming:!1,isPanning:!1,isRotating:!1}),null==t||t(e)}}}var d=i(60499);const u={transitionDuration:0},p=t=>1-(1-t)*(1-t),h=["wheel"],g=["panstart","panmove","panend"],f=["pinchstart","pinchmove","pinchend"],m=["tripanstart","tripanmove","tripanend"],v=["doubletap"],y=["keydown"],_={};class w{constructor(t){this.state={},this._events={},this._interactionState={isDragging:!1},this._customEvents=[],this._eventStartBlocked=null,this._panMove=!1,this.invertPan=!1,this.dragMode="rotate",this.inertia=0,this.scrollZoom=!0,this.dragPan=!0,this.dragRotate=!0,this.doubleClickZoom=!0,this.touchZoom=!0,this.touchRotate=!1,this.keyboard=!0,this.transitionManager=new c({...t,getControllerState:t=>new this.ControllerState(t),onViewStateChange:this._onTransition.bind(this),onStateChange:this._setInteractionState.bind(this)}),this.handleEvent=this.handleEvent.bind(this),this.eventManager=t.eventManager,this.onViewStateChange=t.onViewStateChange||(()=>{}),this.onStateChange=t.onStateChange||(()=>{}),this.makeViewport=t.makeViewport}set events(t){this.toggleEvents(this._customEvents,!1),this.toggleEvents(t,!0),this._customEvents=t,this.props&&this.setProps(this.props)}finalize(){for(const e in this._events){var t;if(this._events[e])null==(t=this.eventManager)||t.off(e,this.handleEvent)}this.transitionManager.finalize()}handleEvent(t){this._controllerState=void 0;const e=this._eventStartBlocked;switch(t.type){case"panstart":return!e&&this._onPanStart(t);case"panmove":return this._onPan(t);case"panend":return this._onPanEnd(t);case"pinchstart":return!e&&this._onPinchStart(t);case"pinchmove":return this._onPinch(t);case"pinchend":return this._onPinchEnd(t);case"tripanstart":return!e&&this._onTriplePanStart(t);case"tripanmove":return this._onTriplePan(t);case"tripanend":return this._onTriplePanEnd(t);case"doubletap":return this._onDoubleTap(t);case"wheel":return this._onWheel(t);case"keydown":return this._onKeyDown(t);default:return!1}}get controllerState(){return this._controllerState=this._controllerState||new this.ControllerState({makeViewport:this.makeViewport,...this.props,...this.state}),this._controllerState}getCenter(t){const{x:e,y:i}=this.props,{offsetCenter:n}=t;return[n.x-e,n.y-i]}isPointInBounds(t,e){const{width:i,height:n}=this.props;if(e&&e.handled)return!1;const o=t[0]>=0&&t[0]<=i&&t[1]>=0&&t[1]<=n;return o&&e&&e.stopPropagation(),o}isFunctionKeyPressed(t){const{srcEvent:e}=t;return Boolean(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}isDragging(){return this._interactionState.isDragging||!1}blockEvents(t){const e=setTimeout((()=>{this._eventStartBlocked===e&&(this._eventStartBlocked=null)}),t);this._eventStartBlocked=e}setProps(t){t.dragMode&&(this.dragMode=t.dragMode),this.props=t,"transitionInterpolator"in t||(t.transitionInterpolator=this._getTransitionProps().transitionInterpolator),this.transitionManager.processViewStateChange(t);const{inertia:e}=t;this.inertia=Number.isFinite(e)?e:!0===e?300:0;const{scrollZoom:i=!0,dragPan:n=!0,dragRotate:o=!0,doubleClickZoom:s=!0,touchZoom:r=!0,touchRotate:a=!1,keyboard:l=!0}=t,c=Boolean(this.onViewStateChange);this.toggleEvents(h,c&&i),this.toggleEvents(g,c&&(n||o)),this.toggleEvents(f,c&&(r||a)),this.toggleEvents(m,c&&a),this.toggleEvents(v,c&&s),this.toggleEvents(y,c&&l),this.scrollZoom=i,this.dragPan=n,this.dragRotate=o,this.doubleClickZoom=s,this.touchZoom=r,this.touchRotate=a,this.keyboard=l}updateTransition(){this.transitionManager.updateTransition()}toggleEvents(t,e){this.eventManager&&t.forEach((t=>{this._events[t]!==e&&(this._events[t]=e,e?this.eventManager.on(t,this.handleEvent):this.eventManager.off(t,this.handleEvent))}))}updateViewport(t,e,i){void 0===e&&(e=null),void 0===i&&(i={});const n={...t.getViewportProps(),...e},o=this.controllerState!==t;if(this.state=t.getState(),this._setInteractionState(i),o){const t=this.controllerState&&this.controllerState.getViewportProps();this.onViewStateChange&&this.onViewStateChange({viewState:n,interactionState:this._interactionState,oldViewState:t})}}_onTransition(t){this.onViewStateChange({...t,interactionState:this._interactionState})}_setInteractionState(t){Object.assign(this._interactionState,t),this.onStateChange(this._interactionState)}_onPanStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;let i=this.isFunctionKeyPressed(t)||t.rightButton||!1;(this.invertPan||"pan"===this.dragMode)&&(i=!i);const n=this.controllerState[i?"panStart":"rotateStart"]({pos:e});return this._panMove=i,this.updateViewport(n,u,{isDragging:!0}),!0}_onPan(t){return!!this.isDragging()&&(this._panMove?this._onPanMove(t):this._onPanRotate(t))}_onPanEnd(t){return!!this.isDragging()&&(this._panMove?this._onPanMoveEnd(t):this._onPanRotateEnd(t))}_onPanMove(t){if(!this.dragPan)return!1;const e=this.getCenter(t),i=this.controllerState.pan({pos:e});return this.updateViewport(i,u,{isDragging:!0,isPanning:!0}),!0}_onPanMoveEnd(t){const{inertia:e}=this;if(this.dragPan&&e&&t.velocity){const i=this.getCenter(t),n=[i[0]+t.velocityX*e/2,i[1]+t.velocityY*e/2],o=this.controllerState.pan({pos:n}).panEnd();this.updateViewport(o,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:p},{isDragging:!1,isPanning:!0})}else{const t=this.controllerState.panEnd();this.updateViewport(t,null,{isDragging:!1,isPanning:!1})}return!0}_onPanRotate(t){if(!this.dragRotate)return!1;const e=this.getCenter(t),i=this.controllerState.rotate({pos:e});return this.updateViewport(i,u,{isDragging:!0,isRotating:!0}),!0}_onPanRotateEnd(t){const{inertia:e}=this;if(this.dragRotate&&e&&t.velocity){const i=this.getCenter(t),n=[i[0]+t.velocityX*e/2,i[1]+t.velocityY*e/2],o=this.controllerState.rotate({pos:n}).rotateEnd();this.updateViewport(o,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:p},{isDragging:!1,isRotating:!0})}else{const t=this.controllerState.rotateEnd();this.updateViewport(t,null,{isDragging:!1,isRotating:!1})}return!0}_onWheel(t){if(!this.scrollZoom)return!1;t.srcEvent.preventDefault();const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const{speed:i=.01,smooth:n=!1}=!0===this.scrollZoom?{}:this.scrollZoom,{delta:o}=t;let s=2/(1+Math.exp(-Math.abs(o*i)));o<0&&0!==s&&(s=1/s);const r=this.controllerState.zoom({pos:e,scale:s});return this.updateViewport(r,{...this._getTransitionProps({around:e}),transitionDuration:n?250:1},{isZooming:!0,isPanning:!0}),!0}_onTriplePanStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.controllerState.rotateStart({pos:e});return this.updateViewport(i,u,{isDragging:!0}),!0}_onTriplePan(t){if(!this.touchRotate)return!1;if(!this.isDragging())return!1;const e=this.getCenter(t);e[0]-=t.deltaX;const i=this.controllerState.rotate({pos:e});return this.updateViewport(i,u,{isDragging:!0,isRotating:!0}),!0}_onTriplePanEnd(t){if(!this.isDragging())return!1;const{inertia:e}=this;if(this.touchRotate&&e&&t.velocityY){const i=this.getCenter(t),n=[i[0],i[1]+=t.velocityY*e/2],o=this.controllerState.rotate({pos:n});this.updateViewport(o,{...this._getTransitionProps(),transitionDuration:e,transitionEasing:p},{isDragging:!1,isRotating:!0}),this.blockEvents(e)}else{const t=this.controllerState.rotateEnd();this.updateViewport(t,null,{isDragging:!1,isRotating:!1})}return!0}_onPinchStart(t){const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.controllerState.zoomStart({pos:e}).rotateStart({pos:e});return _._startPinchRotation=t.rotation,_._lastPinchEvent=t,this.updateViewport(i,u,{isDragging:!0}),!0}_onPinch(t){if(!this.touchZoom&&!this.touchRotate)return!1;if(!this.isDragging())return!1;let e=this.controllerState;if(this.touchZoom){const{scale:i}=t,n=this.getCenter(t);e=e.zoom({pos:n,scale:i})}if(this.touchRotate){const{rotation:i}=t;e=e.rotate({deltaAngleX:_._startPinchRotation-i})}return this.updateViewport(e,u,{isDragging:!0,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:this.touchRotate}),_._lastPinchEvent=t,!0}_onPinchEnd(t){if(!this.isDragging())return!1;const{inertia:e}=this,{_lastPinchEvent:i}=_;if(this.touchZoom&&e&&i&&t.scale!==i.scale){const n=this.getCenter(t);let o=this.controllerState.rotateEnd();const s=Math.log2(t.scale),r=(s-Math.log2(i.scale))/(t.deltaTime-i.deltaTime),a=Math.pow(2,s+r*e/2);o=o.zoom({pos:n,scale:a}).zoomEnd(),this.updateViewport(o,{...this._getTransitionProps({around:n}),transitionDuration:e,transitionEasing:p},{isDragging:!1,isPanning:this.touchZoom,isZooming:this.touchZoom,isRotating:!1}),this.blockEvents(e)}else{const t=this.controllerState.zoomEnd().rotateEnd();this.updateViewport(t,null,{isDragging:!1,isPanning:!1,isZooming:!1,isRotating:!1})}return _._startPinchRotation=null,_._lastPinchEvent=null,!0}_onDoubleTap(t){if(!this.doubleClickZoom)return!1;const e=this.getCenter(t);if(!this.isPointInBounds(e,t))return!1;const i=this.isFunctionKeyPressed(t),n=this.controllerState.zoom({pos:e,scale:i?.5:2});return this.updateViewport(n,this._getTransitionProps({around:e}),{isZooming:!0,isPanning:!0}),this.blockEvents(100),!0}_onKeyDown(t){if(!this.keyboard)return!1;const e=this.isFunctionKeyPressed(t),{zoomSpeed:i,moveSpeed:n,rotateSpeedX:o,rotateSpeedY:s}=!0===this.keyboard?{}:this.keyboard,{controllerState:r}=this;let a;const l={};switch(t.srcEvent.code){case"Minus":a=e?r.zoomOut(i).zoomOut(i):r.zoomOut(i),l.isZooming=!0;break;case"Equal":a=e?r.zoomIn(i).zoomIn(i):r.zoomIn(i),l.isZooming=!0;break;case"ArrowLeft":e?(a=r.rotateLeft(o),l.isRotating=!0):(a=r.moveLeft(n),l.isPanning=!0);break;case"ArrowRight":e?(a=r.rotateRight(o),l.isRotating=!0):(a=r.moveRight(n),l.isPanning=!0);break;case"ArrowUp":e?(a=r.rotateUp(s),l.isRotating=!0):(a=r.moveUp(n),l.isPanning=!0);break;case"ArrowDown":e?(a=r.rotateDown(s),l.isRotating=!0):(a=r.moveDown(n),l.isPanning=!0);break;default:return!1}return this.updateViewport(a,this._getTransitionProps(),l),!0}_getTransitionProps(t){const{transition:e}=this;return e&&e.transitionInterpolator?t?{...e,transitionInterpolator:new d.Z({...t,...e.transitionInterpolator.opts,makeViewport:this.controllerState.makeViewport})}:e:u}}},26810:(t,e,i)=>{"use strict";i.d(e,{U:()=>c,Z:()=>d});var n=i(28835),o=i(93932),s=i(28793),r=i(92797),a=i(13405),l=i(60499);class c extends s.Z{constructor(t){const{width:e,height:i,latitude:n,longitude:o,zoom:s,bearing:r=0,pitch:l=0,altitude:c=1.5,position:d=[0,0,0],maxZoom:u=20,minZoom:p=0,maxPitch:h=60,minPitch:g=0,startPanLngLat:f,startZoomLngLat:m,startRotatePos:v,startBearing:y,startPitch:_,startZoom:w,normalize:b=!0}=t;(0,a.Z)(Number.isFinite(o)),(0,a.Z)(Number.isFinite(n)),(0,a.Z)(Number.isFinite(s)),super({width:e,height:i,latitude:n,longitude:o,zoom:s,bearing:r,pitch:l,altitude:c,maxZoom:u,minZoom:p,maxPitch:h,minPitch:g,normalize:b,position:d},{startPanLngLat:f,startZoomLngLat:m,startRotatePos:v,startBearing:y,startPitch:_,startZoom:w}),this.makeViewport=t.makeViewport}panStart(t){let{pos:e}=t;return this._getUpdatedState({startPanLngLat:this._unproject(e)})}pan(t){let{pos:e,startPos:i}=t;const n=this.getState().startPanLngLat||this._unproject(i);if(!n)return this;const o=this.makeViewport(this.getViewportProps()).panByPosition(n,e);return this._getUpdatedState(o)}panEnd(){return this._getUpdatedState({startPanLngLat:null})}rotateStart(t){let{pos:e}=t;return this._getUpdatedState({startRotatePos:e,startBearing:this.getViewportProps().bearing,startPitch:this.getViewportProps().pitch})}rotate(t){let{pos:e,deltaAngleX:i=0,deltaAngleY:n=0}=t;const{startRotatePos:o,startBearing:s,startPitch:r}=this.getState();if(!o||void 0===s||void 0===r)return this;let a;return a=e?this._getNewRotation(e,o,r,s):{bearing:s+i,pitch:r+n},this._getUpdatedState(a)}rotateEnd(){return this._getUpdatedState({startBearing:null,startPitch:null})}zoomStart(t){let{pos:e}=t;return this._getUpdatedState({startZoomLngLat:this._unproject(e),startZoom:this.getViewportProps().zoom})}zoom(t){let{pos:e,startPos:i,scale:o}=t,{startZoom:s,startZoomLngLat:r}=this.getState();if(r||(s=this.getViewportProps().zoom,r=this._unproject(i)||this._unproject(e)),!r)return this;const{maxZoom:a,minZoom:l}=this.getViewportProps();let c=s+Math.log2(o);c=(0,n.uZ)(c,l,a);const d=this.makeViewport({...this.getViewportProps(),zoom:c});return this._getUpdatedState({zoom:c,...d.panByPosition(r,e)})}zoomEnd(){return this._getUpdatedState({startZoomLngLat:null,startZoom:null})}zoomIn(t){return void 0===t&&(t=2),this._zoomFromCenter(t)}zoomOut(t){return void 0===t&&(t=2),this._zoomFromCenter(1/t)}moveLeft(t){return void 0===t&&(t=100),this._panFromCenter([t,0])}moveRight(t){return void 0===t&&(t=100),this._panFromCenter([-t,0])}moveUp(t){return void 0===t&&(t=100),this._panFromCenter([0,t])}moveDown(t){return void 0===t&&(t=100),this._panFromCenter([0,-t])}rotateLeft(t){return void 0===t&&(t=15),this._getUpdatedState({bearing:this.getViewportProps().bearing-t})}rotateRight(t){return void 0===t&&(t=15),this._getUpdatedState({bearing:this.getViewportProps().bearing+t})}rotateUp(t){return void 0===t&&(t=10),this._getUpdatedState({pitch:this.getViewportProps().pitch+t})}rotateDown(t){return void 0===t&&(t=10),this._getUpdatedState({pitch:this.getViewportProps().pitch-t})}shortestPathFrom(t){const e=t.getViewportProps(),i={...this.getViewportProps()},{bearing:n,longitude:o}=i;return Math.abs(n-e.bearing)>180&&(i.bearing=n<0?n+360:n-360),Math.abs(o-e.longitude)>180&&(i.longitude=o<0?o+360:o-360),i}applyConstraints(t){const{maxZoom:e,minZoom:i,zoom:o}=t;t.zoom=(0,n.uZ)(o,i,e);const{maxPitch:s,minPitch:a,pitch:l}=t;t.pitch=(0,n.uZ)(l,a,s);const{normalize:c=!0}=t;return c&&Object.assign(t,(0,r.QA)(t)),t}_zoomFromCenter(t){const{width:e,height:i}=this.getViewportProps();return this.zoom({pos:[e/2,i/2],scale:t})}_panFromCenter(t){const{width:e,height:i}=this.getViewportProps();return this.pan({startPos:[e/2,i/2],pos:[e/2+t[0],i/2+t[1]]})}_getUpdatedState(t){return new this.constructor({makeViewport:this.makeViewport,...this.getViewportProps(),...this.getState(),...t})}_unproject(t){const e=this.makeViewport(this.getViewportProps());return t&&e.unproject(t)}_getNewRotation(t,e,i,o){const s=t[0]-e[0],r=t[1]-e[1],a=t[1],l=e[1],{width:c,height:d}=this.getViewportProps(),u=s/c;let p=0;r>0?Math.abs(d-l)>5&&(p=r/(l-d)*1.2):r<0&&l>5&&(p=1-a/l),p=(0,n.uZ)(p,-1,1);const{minPitch:h,maxPitch:g}=this.getViewportProps();let f=i;return p>0?f=i+p*(g-i):p<0&&(f=i-p*(h-i)),{pitch:f,bearing:o+180*u}}}class d extends o.Z{constructor(){super(...arguments),this.ControllerState=c,this.transition={transitionDuration:300,transitionInterpolator:new l.Z({transitionProps:{compare:["longitude","latitude","zoom","bearing","pitch","position"],required:["longitude","latitude","zoom"]}})},this.dragMode="pan"}setProps(t){t.position=t.position||[0,0,0];const e=this.props;super.setProps(t);(!e||e.height!==t.height)&&this.updateViewport(new this.ControllerState({makeViewport:this.makeViewport,...t,...this.state}))}}},28793:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});class n{constructor(t,e){this._viewportProps=this.applyConstraints(t),this._state=e}getViewportProps(){return this._viewportProps}getState(){return this._state}}},14503:(t,e,i)=>{"use strict";i.d(e,{Z:()=>r,z:()=>s});var n=i(89745);let o={};function s(t){o=t}function r(t,e,i,s){n.Z.level>0&&o[t]&&o[t].call(null,e,i,s)}},35503:(t,e,i)=>{"use strict";i.d(e,{M:()=>r});const n=[255,255,255],o=1;let s=0;class r{constructor(t){void 0===t&&(t={}),this.type="ambient";const{color:e=n}=t,{intensity:i=o}=t;this.id=t.id||"ambient-"+s++,this.color=e,this.intensity=i}}},42697:(t,e,i)=>{"use strict";i.d(e,{O:()=>l});var n=i(59122);const o=[255,255,255],s=1,r=[0,0,-1];let a=0;class l{constructor(t){void 0===t&&(t={}),this.type="directional";const{color:e=o}=t,{intensity:i=s}=t,{direction:l=r}=t,{_shadow:c=!1}=t;this.id=t.id||"directional-"+a++,this.color=e,this.intensity=i,this.type="directional",this.direction=new n.Z(l).normalize().toArray(),this.shadow=c}getProjectedLight(t){return this}}},6192:(t,e,i)=>{"use strict";i.d(e,{Z:()=>L});var n=i(74797),o=i(43970),s=i(35503),r=i(42697),a=i(76450),l=i(59122),c=i(5259),d=i(40984),u=i(79762),p=i(7092);class h extends c.Z{constructor(t,e){super(t,e),this.shadowMap=new o.Z(t,{width:1,height:1,parameters:{10241:9729,10240:9729,10242:33071,10243:33071}}),this.depthBuffer=new d.Z(t,{format:33189,width:1,height:1}),this.fbo=new u.Z(t,{id:"shadowmap",width:1,height:1,attachments:{36064:this.shadowMap,36096:this.depthBuffer}})}render(t){const e=this.fbo;(0,p.s8)(this.gl,{depthRange:[0,1],depthTest:!0,blend:!1,clearColor:[1,1,1,1]},(()=>{const i=t.viewports[0],n=(0,p.w)(this.gl),o=i.width*n,s=i.height*n;o===e.width&&s===e.height||e.resize({width:o,height:s}),super.render({...t,target:e,pass:"shadow"})}))}shouldDrawLayer(t){return!1!==t.props.shadowEnabled}getModuleParameters(){return{drawToShadowMap:!0}}delete(){this.fbo&&(this.fbo.delete(),this.fbo=null),this.shadowMap&&(this.shadowMap.delete(),this.shadowMap=null),this.depthBuffer&&(this.depthBuffer.delete(),this.depthBuffer=null)}}var g=i(43631),f=i(73782),m=i(66508),v=i(92797);const y=(0,m.Z)((function(t){let{viewport:e,center:i}=t;return new a.Z(e.viewProjectionMatrix).invert().transform(i)})),_=(0,m.Z)((function(t){let{viewport:e,shadowMatrices:i}=t;const n=[],o=e.pixelUnprojectionMatrix,s=e.isGeospatial?void 0:1,r=[[0,0,s],[e.width,0,s],[0,e.height,s],[e.width,e.height,s],[0,0,-1],[e.width,0,-1],[0,e.height,-1],[e.width,e.height,-1]].map((t=>function(t,e){const[i,n,o]=t,s=(0,v.CT)([i,n,o],e);if(Number.isFinite(o))return s;return[s[0],s[1],0]}(t,o)));for(const c of i){const t=c.clone().translate(new l.Z(e.center).negate()),i=r.map((e=>t.transform(e))),o=(new a.Z).ortho({left:Math.min(...i.map((t=>t[0]))),right:Math.max(...i.map((t=>t[0]))),bottom:Math.min(...i.map((t=>t[1]))),top:Math.max(...i.map((t=>t[1]))),near:Math.min(...i.map((t=>-t[2]))),far:Math.max(...i.map((t=>-t[2])))});n.push(o.multiplyRight(c))}return n})),w=[0,0,0,1],b=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0];const P={name:"shadow",dependencies:[f.Z],vs:"\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n",fs:"\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n",inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    position = shadow_setVertexPosition(geometry.position);\n    ","fs:DECKGL_FILTER_COLOR":"\n    color = shadow_filterShadowColor(color);\n    "},getUniforms:function(t,e){return void 0===t&&(t={}),void 0===e&&(e={}),"viewport"in t&&(t.drawToShadowMap||t.shadowMaps&&t.shadowMaps.length>0)?function(t,e){const{shadowEnabled:i=!0}=t;if(!i||!t.shadowMatrices||!t.shadowMatrices.length)return{shadow_uDrawShadowMap:!1,shadow_uUseShadowMap:!1};const n={shadow_uDrawShadowMap:Boolean(t.drawToShadowMap),shadow_uUseShadowMap:!!t.shadowMaps&&t.shadowMaps.length>0,shadow_uColor:t.shadowColor||w,shadow_uLightId:t.shadowLightId||0,shadow_uLightCount:t.shadowMatrices.length},o=y({viewport:t.viewport,center:e.project_uCenter}),s=[],r=_({shadowMatrices:t.shadowMatrices,viewport:t.viewport}).slice();for(let a=0;a<t.shadowMatrices.length;a++){const i=r[a],n=i.clone().translate(new l.Z(t.viewport.center).negate());e.project_uCoordinateSystem===g.Df.LNGLAT&&e.project_uProjectionMode===g.zG.WEB_MERCATOR?(r[a]=n,s[a]=o):(r[a]=i.clone().multiplyRight(b),s[a]=n.transform(o))}for(let a=0;a<r.length;a++)n["shadow_uViewProjectionMatrices["+a+"]"]=r[a],n["shadow_uProjectCenters["+a+"]"]=s[a],t.shadowMaps&&t.shadowMaps.length>0?n["shadow_uShadowMap"+a]=t.shadowMaps[a]:n["shadow_uShadowMap"+a]=t.dummyShadowMap;return n}(t,e):{}}},x={color:[255,255,255],intensity:1},C=[{color:[255,255,255],intensity:1,direction:[-1,3,-1]},{color:[255,255,255],intensity:.9,direction:[1,-8,-2.5]}],S=[0,0,0,200/255];class L{constructor(t){void 0===t&&(t={}),this.id="lighting-effect",this.shadowColor=S,this.shadowPasses=[],this.shadowMaps=[],this.dummyShadowMap=null,this.setProps(t)}setProps(t){this.ambientLight=null,this.directionalLights=[],this.pointLights=[];for(const e in t){const i=t[e];switch(i.type){case"ambient":this.ambientLight=i;break;case"directional":this.directionalLights.push(i);break;case"point":this.pointLights.push(i)}}this._applyDefaultLights(),this.shadow=this.directionalLights.some((t=>t.shadow)),this.props=t}preRender(t,e){let{layers:i,layerFilter:s,viewports:r,onViewportActive:a,views:l}=e;if(this.shadow){this.shadowMatrices=this._calculateMatrices(),0===this.shadowPasses.length&&this._createShadowPasses(t),this.programManager||(this.programManager=n.Z.getDefaultProgramManager(t),P&&this.programManager.addDefaultModule(P)),this.dummyShadowMap||(this.dummyShadowMap=new o.Z(t,{width:1,height:1}));for(let t=0;t<this.shadowPasses.length;t++){this.shadowPasses[t].render({layers:i,layerFilter:s,viewports:r,onViewportActive:a,views:l,moduleParameters:{shadowLightId:t,dummyShadowMap:this.dummyShadowMap,shadowMatrices:this.shadowMatrices}})}}}getModuleParameters(t){const e=this.shadow?{shadowMaps:this.shadowMaps,dummyShadowMap:this.dummyShadowMap,shadowColor:this.shadowColor,shadowMatrices:this.shadowMatrices}:{};return e.lightSources={ambientLight:this.ambientLight,directionalLights:this.directionalLights.map((e=>e.getProjectedLight({layer:t}))),pointLights:this.pointLights.map((e=>e.getProjectedLight({layer:t})))},e}cleanup(){for(const t of this.shadowPasses)t.delete();this.shadowPasses.length=0,this.shadowMaps.length=0,this.dummyShadowMap&&(this.dummyShadowMap.delete(),this.dummyShadowMap=null),this.shadow&&this.programManager&&(this.programManager.removeDefaultModule(P),this.programManager=null)}_calculateMatrices(){const t=[];for(const e of this.directionalLights){const i=(new a.Z).lookAt({eye:new l.Z(e.direction).negate()});t.push(i)}return t}_createShadowPasses(t){for(let e=0;e<this.directionalLights.length;e++){const i=new h(t);this.shadowPasses[e]=i,this.shadowMaps[e]=i.shadowMap}}_applyDefaultLights(){const{ambientLight:t,pointLights:e,directionalLights:i}=this;t||0!==e.length||0!==i.length||(this.ambientLight=new s.M(x),this.directionalLights.push(new r.O(C[0]),new r.O(C[1])))}}},52747:(t,e,i)=>{"use strict";i.d(e,{Z:()=>E});var n=i(19227),o=i(83757),s=i(80241);class r{constructor(t,e){this.opts=e,this.source=t}get value(){return this.source.value}getValue(){const t=this.source.getBuffer(),e=this.getAccessor();if(t)return[t,e];const{value:i}=this.source,{size:n}=e;let o=i;if(i&&i.length!==n){o=new Float32Array(n);const t=e.elementOffset||0;for(let e=0;e<n;++e)o[e]=i[t+e]}return o}getAccessor(){return{...this.source.getAccessor(),...this.opts}}}var a=i(67258),l=i(4563),c=i(89745);function d(t){return t.stride||t.size*t.bytesPerElement}function u(t,e){e.offset&&c.Z.removed("shaderAttribute.offset","vertexOffset, elementOffset")();const i=d(t),n=(void 0!==e.vertexOffset?e.vertexOffset:t.vertexOffset||0)*i+(e.elementOffset||0)*t.bytesPerElement+(t.offset||0);return{...e,offset:n,stride:i}}class p{constructor(t,e,i){this.gl=t,this.id=e.id||"",this.size=e.size||1;const s=e.logicalType||e.type,r=5130===s;let a,{defaultValue:l}=e;l=Number.isFinite(l)?[l]:l||new Array(this.size).fill(0),a=r?5126:!s&&e.isIndexed?t&&(0,n.U6)(t,o.h.ELEMENT_INDEX_UINT32)?5125:5123:s||5126;let c=function(t){switch(t){case 5126:return Float32Array;case 5130:return Float64Array;case 5123:case 33635:case 32819:case 32820:return Uint16Array;case 5125:return Uint32Array;case 5121:return Uint8ClampedArray;case 5120:return Int8Array;case 5122:return Int16Array;case 5124:return Int32Array;default:throw new Error("Unknown GL type")}}(s||a||5126);this.doublePrecision=r,r&&!1===e.fp64&&(c=Float32Array),this.value=null,this.settings={...e,defaultType:c,defaultValue:l,logicalType:s,type:a,size:this.size,bytesPerElement:c.BYTES_PER_ELEMENT},this.state={...i,externalBuffer:null,bufferAccessor:this.settings,allocatedValue:null,numInstances:0,bounds:null,constant:!1},this._buffer=null}get isConstant(){return this.state.constant}get buffer(){if(!this._buffer){const{isIndexed:t,type:e}=this.settings;this._buffer=new s.Z(this.gl,{id:this.id,target:t?34963:34962,accessor:{type:e}})}return this._buffer}get byteOffset(){const t=this.getAccessor();return t.vertexOffset?t.vertexOffset*d(t):0}get numInstances(){return this.state.numInstances}set numInstances(t){this.state.numInstances=t}delete(){this._buffer&&(this._buffer.delete(),this._buffer=null),a.Z.release(this.state.allocatedValue)}getShaderAttributes(t,e){if(this.doublePrecision){const i={},n=this.value instanceof Float64Array,o=function(t,e){const i=u(t,e);return{high:i,low:{...i,offset:i.offset+4*t.size}}}(this.getAccessor(),e||{});return i[t]=new r(this,o.high),i[t+"64Low"]=n?new r(this,o.low):new Float32Array(this.size),i}if(e){const i=u(this.getAccessor(),e);return{[t]:new r(this,i)}}return{[t]:this}}getBuffer(){return this.state.constant?null:this.state.externalBuffer||this._buffer}getValue(){return this.state.constant?this.value:[this.getBuffer(),this.getAccessor()]}getAccessor(){return this.state.bufferAccessor}getBounds(){if(this.state.bounds)return this.state.bounds;let t=null;if(this.state.constant&&this.value){const e=Array.from(this.value);t=[e,e]}else{const{value:e,numInstances:i,size:n}=this,o=i*n;if(e&&o&&e.length>=o){const i=new Array(n).fill(1/0),s=new Array(n).fill(-1/0);for(let t=0;t<o;)for(let o=0;o<n;o++){const n=e[t++];n<i[o]&&(i[o]=n),n>s[o]&&(s[o]=n)}t=[i,s]}}return this.state.bounds=t,t}setData(t){const{state:e}=this;let i;i=ArrayBuffer.isView(t)?{value:t}:t instanceof s.Z?{buffer:t}:t;const n={...this.settings,...i};if(e.bufferAccessor=n,e.bounds=null,i.constant){let t=i.value;t=this._normalizeValue(t,[],0),this.settings.normalized&&(t=this.normalizeConstant(t));if(!(!e.constant||!this._areValuesEqual(t,this.value)))return!1;e.externalBuffer=null,e.constant=!0,this.value=t}else if(i.buffer){const t=i.buffer;e.externalBuffer=t,e.constant=!1,this.value=i.value||null;const o=i.value instanceof Float64Array;n.type=i.type||t.accessor.type,n.bytesPerElement=t.accessor.BYTES_PER_ELEMENT*(o?2:1),n.stride=d(n)}else if(i.value){this._checkExternalBuffer(i);let t=i.value;e.externalBuffer=null,e.constant=!1,this.value=t,n.bytesPerElement=t.BYTES_PER_ELEMENT,n.stride=d(n);const{buffer:o,byteOffset:s}=this;this.doublePrecision&&t instanceof Float64Array&&(t=(0,l.TK)(t,n));const r=t.byteLength+s+2*n.stride;o.byteLength<r&&o.reallocate(r),o.setAccessor(null),o.subData({data:t,offset:s}),n.type=i.type||o.accessor.type}return!0}updateSubBuffer(t){void 0===t&&(t={}),this.state.bounds=null;const e=this.value,{startOffset:i=0,endOffset:n}=t;this.buffer.subData({data:this.doublePrecision&&e instanceof Float64Array?(0,l.TK)(e,{size:this.size,startIndex:i,endIndex:n}):e.subarray(i,n),offset:i*e.BYTES_PER_ELEMENT+this.byteOffset})}allocate(t,e){void 0===e&&(e=!1);const{state:i}=this,n=i.allocatedValue,o=a.Z.allocate(n,t+1,{size:this.size,type:this.settings.defaultType,copy:e});this.value=o;const{buffer:s,byteOffset:r}=this;return s.byteLength<o.byteLength+r&&(s.reallocate(o.byteLength+r),e&&n&&s.subData({data:n instanceof Float64Array?(0,l.TK)(n,this):n,offset:r})),i.allocatedValue=o,i.constant=!1,i.externalBuffer=null,i.bufferAccessor=this.settings,!0}_checkExternalBuffer(t){const{value:e}=t;if(!ArrayBuffer.isView(e))throw new Error("Attribute "+this.id+" value is not TypedArray");const i=this.settings.defaultType;let n=!1;if(this.doublePrecision&&(n=e.BYTES_PER_ELEMENT<4),n)throw new Error("Attribute "+this.id+" does not support "+e.constructor.name);e instanceof i||!this.settings.normalized||"normalized"in t||c.Z.warn("Attribute "+this.id+" is normalized")()}normalizeConstant(t){switch(this.settings.type){case 5120:return new Float32Array(t).map((t=>(t+128)/255*2-1));case 5122:return new Float32Array(t).map((t=>(t+32768)/65535*2-1));case 5121:return new Float32Array(t).map((t=>t/255));case 5123:return new Float32Array(t).map((t=>t/65535));default:return t}}_normalizeValue(t,e,i){const{defaultValue:n,size:o}=this.settings;if(Number.isFinite(t))return e[i]=t,e;if(!t)return e[i]=n[0],e;switch(o){case 4:e[i+3]=Number.isFinite(t[3])?t[3]:n[3];case 3:e[i+2]=Number.isFinite(t[2])?t[2]:n[2];case 2:e[i+1]=Number.isFinite(t[1])?t[1]:n[1];case 1:e[i+0]=Number.isFinite(t[0])?t[0]:n[0];break;default:let s=o;for(;--s>=0;)e[i+s]=Number.isFinite(t[s])?t[s]:n[s]}return e}_areValuesEqual(t,e){if(!t||!e)return!1;const{size:i}=this;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}}var h=i(13405),g=i(37944),f=i(32332);const m=[],v=[[0,1/0]];var y=i(98489);class _ extends p{constructor(t,e){super(t,e,{startIndices:null,lastExternalBuffer:null,binaryValue:null,binaryAccessor:null,needsUpdate:!0,needsRedraw:!1,updateRanges:v}),this.constant=!1,this.settings.update=e.update||(e.accessor?this._autoUpdater:void 0),Object.seal(this.settings),Object.seal(this.state),this._validateAttributeUpdaters()}get startIndices(){return this.state.startIndices}set startIndices(t){this.state.startIndices=t}needsUpdate(){return this.state.needsUpdate}needsRedraw(t){let{clearChangedFlags:e=!1}=void 0===t?{}:t;const i=this.state.needsRedraw;return this.state.needsRedraw=i&&!e,i}getUpdateTriggers(){const{accessor:t}=this.settings;return[this.id].concat("function"!=typeof t&&t||[])}supportsTransition(){return Boolean(this.settings.transition)}getTransitionSetting(t){if(!t||!this.supportsTransition())return null;const{accessor:e}=this.settings,i=this.settings.transition,n=Array.isArray(e)?t[e.find((e=>t[e]))]:t[e];return(0,y.M0)(n,i)}setNeedsUpdate(t,e){if(void 0===t&&(t=this.id),this.state.needsUpdate=this.state.needsUpdate||t,this.setNeedsRedraw(t),e){const{startRow:t=0,endRow:i=1/0}=e;this.state.updateRanges=function(t,e){if(t===v)return t;if(e[0]<0&&(e[0]=0),e[0]>=e[1])return t;const i=[],n=t.length;let o=0;for(let s=0;s<n;s++){const n=t[s];n[1]<e[0]?(i.push(n),o=s+1):n[0]>e[1]?i.push(n):e=[Math.min(n[0],e[0]),Math.max(n[1],e[1])]}return i.splice(o,0,e),i}(this.state.updateRanges,[t,i])}else this.state.updateRanges=v}clearNeedsUpdate(){this.state.needsUpdate=!1,this.state.updateRanges=m}setNeedsRedraw(t){void 0===t&&(t=this.id),this.state.needsRedraw=this.state.needsRedraw||t}allocate(t){const{state:e,settings:i}=this;return!i.noAlloc&&(!!i.update&&(super.allocate(t,e.updateRanges!==v),!0))}updateBuffer(t){let{numInstances:e,data:i,props:n,context:o}=t;if(!this.needsUpdate())return!1;const{state:{updateRanges:s},settings:{update:r,noAlloc:a}}=this;let l=!0;if(r){for(const[t,a]of s)r.call(o,this,{data:i,startRow:t,endRow:a,props:n,numInstances:e});if(this.value)if(this.constant||this.buffer.byteLength<this.value.byteLength+this.byteOffset)this.setData({value:this.value,constant:this.constant}),this.constant=!1;else for(const[t,i]of s){const n=Number.isFinite(t)?this.getVertexOffset(t):0,o=Number.isFinite(i)?this.getVertexOffset(i):a||!Number.isFinite(e)?this.value.length:e*this.size;super.updateSubBuffer({startOffset:n,endOffset:o})}else;this._checkAttributeArray()}else l=!1;return this.clearNeedsUpdate(),this.setNeedsRedraw(),l}setConstantValue(t){if(void 0===t||"function"==typeof t)return!1;return this.setData({constant:!0,value:t})&&this.setNeedsRedraw(),this.clearNeedsUpdate(),!0}setExternalBuffer(t){const{state:e}=this;return t?(this.clearNeedsUpdate(),e.lastExternalBuffer===t||(e.lastExternalBuffer=t,this.setNeedsRedraw(),this.setData(t)),!0):(e.lastExternalBuffer=null,!1)}setBinaryValue(t,e){void 0===e&&(e=null);const{state:i,settings:n}=this;if(!t)return i.binaryValue=null,i.binaryAccessor=null,!1;if(n.noAlloc)return!1;if(i.binaryValue===t)return this.clearNeedsUpdate(),!0;i.binaryValue=t,this.setNeedsRedraw();if(n.transform||e!==this.startIndices){ArrayBuffer.isView(t)&&(t={value:t});const o=t;(0,h.Z)(ArrayBuffer.isView(o.value),"invalid "+n.accessor);const s=Boolean(o.size)&&o.size!==this.size;return i.binaryAccessor=(0,g.jr)(o.value,{size:o.size||this.size,stride:o.stride,offset:o.offset,startIndices:e,nested:s}),!1}return this.clearNeedsUpdate(),this.setData(t),!0}getVertexOffset(t){const{startIndices:e}=this;return(e?t<e.length?e[t]:this.numInstances:t)*this.size}getShaderAttributes(){const t=this.settings.shaderAttributes||{[this.id]:null},e={};for(const i in t)Object.assign(e,super.getShaderAttributes(i,t[i]));return e}_autoUpdater(t,e){let{data:i,startRow:n,endRow:o,props:s,numInstances:r}=e;if(t.constant)return;const{settings:a,state:l,value:c,size:d,startIndices:u}=t,{accessor:p,transform:m}=a,v=l.binaryAccessor||("function"==typeof p?p:s[p]);(0,h.Z)("function"==typeof v,'accessor "'+p+'" is not a function');let y=t.getVertexOffset(n);const{iterable:_,objectInfo:w}=(0,g.jB)(i,n,o);for(const h of _){w.index++;let e=v(h,w);if(m&&(e=m.call(this,e)),u){const i=(w.index<u.length-1?u[w.index+1]:r)-u[w.index];if(e&&Array.isArray(e[0])){let i=y;for(const n of e)t._normalizeValue(n,c,i),i+=d}else e&&e.length>d?c.set(e,y):(t._normalizeValue(e,w.target,0),(0,f.k)({target:c,source:w.target,start:y,count:i}));y+=i*d}else t._normalizeValue(e,c,y),y+=d}}_validateAttributeUpdaters(){const{settings:t}=this;if(!(t.noAlloc||"function"==typeof t.update))throw new Error("Attribute "+this.id+" missing update or accessor")}_checkAttributeArray(){const{value:t}=this,e=Math.min(4,this.size);if(t&&t.length>=e){let i=!0;switch(e){case 4:i=i&&Number.isFinite(t[3]);case 3:i=i&&Number.isFinite(t[2]);case 2:i=i&&Number.isFinite(t[1]);case 1:i=i&&Number.isFinite(t[0]);break;default:i=!1}if(!i)throw new Error("Illegal attribute generated for "+this.id)}}}var w=i(14503),b=i(50031),P=i(62833);const x="\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";var C=i(88163),S=i(43970),L=i(79762);const M={interpolation:class{constructor(t){let{gl:e,attribute:i,timeline:n}=t;this.type="interpolation",this.gl=e,this.transition=new P.Z(n),this.attribute=i,this.attributeInTransition=new _(e,i.settings),this.currentStartIndices=i.startIndices,this.currentLength=0,this.transform=function(t,e){const i=(0,y.w)(e.size);return new b.Z(t,{vs:x,defines:{ATTRIBUTE_TYPE:i},varyings:["vCurrent"]})}(e,i);const o={byteLength:0,usage:35050};this.buffers=[new s.Z(e,o),new s.Z(e,o)]}get inProgress(){return this.transition.inProgress}start(t,e){if(t.duration<=0)return void this.transition.cancel();this.settings=t;const{gl:i,buffers:n,attribute:o}=this;(0,y.DY)(n);const s={numInstances:e,attribute:o,fromLength:this.currentLength,fromStartIndices:this.currentStartIndices,getData:t.enter};for(const r of n)(0,y.IV)({buffer:r,...s});this.currentStartIndices=o.startIndices,this.currentLength=(0,y.pi)(o,e),this.attributeInTransition.setData({buffer:n[1],value:o.value}),this.transition.start(t),this.transform.update({elementCount:Math.floor(this.currentLength/o.size),sourceBuffers:{aFrom:n[0],aTo:(0,y.AQ)(i,o)},feedbackBuffers:{vCurrent:n[1]}})}update(){const t=this.transition.update();if(t){const{duration:t,easing:e}=this.settings,{time:i}=this.transition;let n=i/t;e&&(n=e(n)),this.transform.run({uniforms:{time:n}})}return t}cancel(){this.transition.cancel(),this.transform.delete();for(const t of this.buffers)t.delete();this.buffers.length=0}},spring:class{constructor(t){let{gl:e,attribute:i,timeline:n}=t;this.type="spring",this.gl=e,this.type="spring",this.transition=new P.Z(n),this.attribute=i,this.attributeInTransition=new _(e,{...i.settings,normalized:!1}),this.currentStartIndices=i.startIndices,this.currentLength=0,this.texture=function(t){return new S.Z(t,{data:new Uint8Array(4),format:6408,type:5121,border:0,mipmaps:!1,dataFormat:6408,width:1,height:1})}(e),this.framebuffer=function(t,e){return new L.Z(t,{id:"spring-transition-is-transitioning-framebuffer",width:1,height:1,attachments:{36064:e}})}(e,this.texture),this.transform=function(t,e,i){const n=(0,y.w)(e.size);return new b.Z(t,{framebuffer:i,vs:"\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",fs:"\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",defines:{ATTRIBUTE_TYPE:n},varyings:["vNext"]})}(e,i,this.framebuffer);const o={byteLength:0,usage:35050};this.buffers=[new s.Z(e,o),new s.Z(e,o),new s.Z(e,o)]}get inProgress(){return this.transition.inProgress}start(t,e){const{gl:i,buffers:n,attribute:o}=this,s={numInstances:e,attribute:o,fromLength:this.currentLength,fromStartIndices:this.currentStartIndices,getData:t.enter};for(const r of n)(0,y.IV)({buffer:r,...s});this.settings=t,this.currentStartIndices=o.startIndices,this.currentLength=(0,y.pi)(o,e),this.attributeInTransition.setData({buffer:n[1],value:o.value}),this.transition.start({...t,duration:1/0}),this.transform.update({elementCount:Math.floor(this.currentLength/o.size),sourceBuffers:{aTo:(0,y.AQ)(i,o)}})}update(){const{buffers:t,transform:e,framebuffer:i,transition:n}=this;if(!n.update())return!1;const o=this.settings;e.update({sourceBuffers:{aPrev:t[0],aCur:t[1]},feedbackBuffers:{vNext:t[2]}}),e.run({framebuffer:i,discard:!1,clearRenderTarget:!0,uniforms:{stiffness:o.stiffness,damping:o.damping},parameters:{depthTest:!1,blend:!0,viewport:[0,0,1,1],blendFunc:[1,1],blendEquation:[32776,32776]}}),(0,y.DY)(t),this.attributeInTransition.setData({buffer:t[1],value:this.attribute.value});return(0,C.z6)(i)[0]>0||n.end(),!0}cancel(){this.transition.cancel(),this.transform.delete();for(const t of this.buffers)t.delete();this.buffers.length=0,this.texture.delete(),this.framebuffer.delete()}}};class k{constructor(t,e){let{id:i,timeline:n}=e;this.id=i,this.gl=t,this.timeline=n,this.transitions={},this.needsRedraw=!1,this.numInstances=1,this.isSupported=b.Z.isSupported(t)}finalize(){for(const t in this.transitions)this._removeTransition(t)}update(t){let{attributes:e,transitions:i,numInstances:n}=t;this.numInstances=n||1;for(const o in e){const t=e[o],n=t.getTransitionSetting(i);n&&this._updateAttribute(o,t,n)}for(const o in this.transitions){const t=e[o];t&&t.getTransitionSetting(i)||this._removeTransition(o)}}hasAttribute(t){const e=this.transitions[t];return e&&e.inProgress}getAttributes(){const t={};for(const e in this.transitions){const i=this.transitions[e];i.inProgress&&(t[e]=i.attributeInTransition)}return t}run(){if(!this.isSupported||0===this.numInstances)return!1;for(const e in this.transitions){this.transitions[e].update()&&(this.needsRedraw=!0)}const t=this.needsRedraw;return this.needsRedraw=!1,t}_removeTransition(t){this.transitions[t].cancel(),delete this.transitions[t]}_updateAttribute(t,e,i){const n=this.transitions[t];let o=!n||n.type!==i.type;if(o){if(!this.isSupported)return void c.Z.warn("WebGL2 not supported by this browser. Transition for "+t+" is disabled.")();n&&this._removeTransition(t);const s=M[i.type];s?this.transitions[t]=new s({attribute:e,timeline:this.timeline,gl:this.gl}):(c.Z.error("unsupported transition type '"+i.type+"'")(),o=!1)}(o||e.needsRedraw())&&(this.needsRedraw=!0,this.transitions[t].start(i,this.numInstances))}}const T="attributeManager.invalidate";class E{constructor(t,e){let{id:i="attribute-manager",stats:n,timeline:o}=void 0===e?{}:e;this.id=i,this.gl=t,this.attributes={},this.updateTriggers={},this.needsRedraw=!0,this.userData={},this.stats=n,this.attributeTransitionManager=new k(t,{id:i+"-transitions",timeline:o}),Object.seal(this)}finalize(){for(const t in this.attributes)this.attributes[t].delete();this.attributeTransitionManager.finalize()}getNeedsRedraw(t){void 0===t&&(t={clearRedrawFlags:!1});const e=this.needsRedraw;return this.needsRedraw=this.needsRedraw&&!t.clearRedrawFlags,e&&this.id}setNeedsRedraw(){this.needsRedraw=!0}add(t){this._add(t)}addInstanced(t){this._add(t,{instanced:1})}remove(t){for(const e of t)void 0!==this.attributes[e]&&(this.attributes[e].delete(),delete this.attributes[e])}invalidate(t,e){const i=this._invalidateTrigger(t,e);(0,w.Z)(T,this,t,i)}invalidateAll(t){for(const e in this.attributes)this.attributes[e].setNeedsUpdate(e,t);(0,w.Z)(T,this,"all")}update(t){let{data:e,numInstances:i,startIndices:n=null,transitions:o,props:s={},buffers:r={},context:a={}}=t,l=!1;(0,w.Z)("attributeManager.updateStart",this),this.stats&&this.stats.get("Update Attributes").timeStart();for(const d in this.attributes){const t=this.attributes[d],o=t.settings.accessor;t.startIndices=n,t.numInstances=i,s[d]&&c.Z.removed("props."+d,"data.attributes."+d)(),t.setExternalBuffer(r[d])||t.setBinaryValue("string"==typeof o?r[o]:void 0,e.startIndices)||"string"==typeof o&&!r[o]&&t.setConstantValue(s[o])||t.needsUpdate()&&(l=!0,this._updateAttribute({attribute:t,numInstances:i,data:e,props:s,context:a})),this.needsRedraw=this.needsRedraw||t.needsRedraw()}l&&(0,w.Z)("attributeManager.updateEnd",this,i),this.stats&&this.stats.get("Update Attributes").timeEnd(),this.attributeTransitionManager.update({attributes:this.attributes,numInstances:i,transitions:o})}updateTransition(){const{attributeTransitionManager:t}=this,e=t.run();return this.needsRedraw=this.needsRedraw||e,e}getAttributes(){return this.attributes}getChangedAttributes(t){void 0===t&&(t={clearChangedFlags:!1});const{attributes:e,attributeTransitionManager:i}=this,n={...i.getAttributes()};for(const o in e){const s=e[o];s.needsRedraw(t)&&!i.hasAttribute(o)&&(n[o]=s)}return n}getShaderAttributes(t,e){void 0===e&&(e={}),t||(t=this.getAttributes());const i={};for(const n in t)e[n]||Object.assign(i,t[n].getShaderAttributes());return i}_add(t,e){void 0===e&&(e={});for(const i in t){const n=t[i];this.attributes[i]=this._createAttribute(i,n,e)}this._mapUpdateTriggersToAttributes()}_createAttribute(t,e,i){const n={...e,id:t,size:(e.isIndexed?1:e.size)||1,divisor:i.instanced?1:e.divisor||0};return new _(this.gl,n)}_mapUpdateTriggersToAttributes(){const t={};for(const e in this.attributes){this.attributes[e].getUpdateTriggers().forEach((i=>{t[i]||(t[i]=[]),t[i].push(e)}))}this.updateTriggers=t}_invalidateTrigger(t,e){const{attributes:i,updateTriggers:n}=this,o=n[t];return o&&o.forEach((t=>{const n=i[t];n&&n.setNeedsUpdate(n.id,e)})),o}_updateAttribute(t){const{attribute:e,numInstances:i}=t;if((0,w.Z)("attribute.updateStart",e),e.constant)return void e.setConstantValue(e.value);e.allocate(i)&&(0,w.Z)("attribute.allocate",e,i);e.updateBuffer(t)&&(this.needsRedraw=!0,(0,w.Z)("attribute.updateEnd",e,i))}}},98489:(t,e,i)=>{"use strict";function n(t){const{source:e,target:i,start:n=0,size:o,getData:s}=t,r=t.end||i.length,a=e.length,l=r-n;if(a>l)return void i.set(e.subarray(0,l),n);if(i.set(e,n),!s)return;let c=a;for(;c<l;){const t=s(c,e);for(let e=0;e<o;e++)i[n+c]=t[e]||0,c++}}i.d(e,{DY:()=>l,pi:()=>c,w:()=>a,AQ:()=>r,M0:()=>s,IV:()=>d});const o={interpolation:{duration:0,easing:t=>t},spring:{stiffness:.05,damping:.5}};function s(t,e){if(!t)return null;Number.isFinite(t)&&(t={type:"interpolation",duration:t});const i=t.type||"interpolation";return{...o[i],...e,...t,type:i}}function r(t,e){const i=e.getBuffer();return i?[i,{divisor:0,size:e.size,normalized:e.settings.normalized}]:e.value}function a(t){switch(t){case 1:return"float";case 2:return"vec2";case 3:return"vec3";case 4:return"vec4";default:throw new Error('No defined attribute type for size "'+t+'"')}}function l(t){t.push(t.shift())}function c(t,e){const{doublePrecision:i,settings:n,value:o,size:s}=t,r=i&&o instanceof Float64Array?2:1;return(n.noAlloc?o.length:e*s)*r}function d(t){let{buffer:e,numInstances:i,attribute:o,fromLength:s,fromStartIndices:r,getData:a=(t=>t)}=t;const l=o.doublePrecision&&o.value instanceof Float64Array?2:1,d=o.size*l,u=o.byteOffset,p=o.startIndices,h=r&&p,g=c(o,i),f=o.isConstant;if(!h&&s>=g)return;const m=f?o.value:o.getBuffer().getData({srcByteOffset:u});if(o.settings.normalized&&!f){const t=a;a=(e,i)=>o.normalizeConstant(t(e,i))}const v=f?(t,e)=>a(m,e):(t,e)=>a(m.subarray(t,t+d),e),y=e.getData({length:s}),_=new Float32Array(g);!function(t){let{source:e,target:i,size:o,getData:s,sourceStartIndices:r,targetStartIndices:a}=t;if(!Array.isArray(a))return n({source:e,target:i,size:o,getData:s}),i;let l=0,c=0;const d=s&&((t,e)=>s(t+c,e)),u=Math.min(r.length,a.length);for(let p=1;p<u;p++){const t=r[p]*o,s=a[p]*o;n({source:e.subarray(l,t),target:i,start:c,end:s,size:o,getData:d}),l=t,c=s}c<i.length&&n({source:[],target:i,start:c,size:o,getData:d})}({source:y,target:_,sourceStartIndices:r,targetStartIndices:p,size:d,getData:v}),e.byteLength<_.byteLength+u&&e.reallocate(_.byteLength+u),e.subData({data:_,offset:u})}},19871:(t,e,i)=>{"use strict";i.d(e,{Z:()=>a});var n=i(47251),o=i(14503),s=i(32332),r=i(65663);class a extends n.Z{get isComposite(){return!0}get isLoaded(){return super.isLoaded&&this.getSubLayers().every((t=>t.isLoaded))}getSubLayers(){return this.internalState&&this.internalState.subLayers||[]}initializeState(t){}setState(t){super.setState(t),this.setNeedsUpdate()}getPickingInfo(t){let{info:e}=t;const{object:i}=e;return i&&i.__source&&i.__source.parent&&i.__source.parent.id===this.id?(e.object=i.__source.object,e.index=i.__source.index,e):e}filterSubLayer(t){return!0}shouldRenderSubLayer(t,e){return e&&e.length}getSubLayerClass(t,e){const{_subLayerProps:i}=this.props;return i&&i[t]&&i[t].type||e}getSubLayerRow(t,e,i){return t.__source={parent:this,object:e,index:i},t}getSubLayerAccessor(t){if("function"==typeof t){const e={index:-1,data:this.props.data,target:[]};return(i,n)=>i&&i.__source?(e.index=i.__source.index,t(i.__source.object,e)):t(i,n)}return t}getSubLayerProps(t){var e;void 0===t&&(t={});const{opacity:i,pickable:n,visible:o,parameters:s,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:d,coordinateSystem:u,coordinateOrigin:p,wrapLongitude:h,positionFormat:g,modelMatrix:f,extensions:m,fetch:v,operation:y,_subLayerProps:_}=this.props,w={id:"",updateTriggers:{},opacity:i,pickable:n,visible:o,parameters:s,getPolygonOffset:a,highlightedObjectIndex:l,autoHighlight:c,highlightColor:d,coordinateSystem:u,coordinateOrigin:p,wrapLongitude:h,positionFormat:g,modelMatrix:f,extensions:m,fetch:v,operation:y},b=_&&t.id&&_[t.id],P=b&&b.updateTriggers,x=t.id||"sublayer";if(b){const e=this.props[r.Wb],i=t.type?t.type._propTypes:{};for(const t in b){const n=i[t]||e[t];n&&"accessor"===n.type&&(b[t]=this.getSubLayerAccessor(b[t]))}}Object.assign(w,t,b),w.id=this.props.id+"-"+x,w.updateTriggers={all:null==(e=this.props.updateTriggers)?void 0:e.all,...t.updateTriggers,...P};for(const r of m){const t=r.getSubLayerProps.call(this,r);t&&Object.assign(w,t,{updateTriggers:Object.assign(w.updateTriggers,t.updateTriggers)})}return w}_updateAutoHighlight(t){for(const e of this.getSubLayers())e.updateAutoHighlight(t)}_getAttributeManager(){return null}_postUpdate(t,e){let i=this.internalState.subLayers;const n=!i||this.needsUpdate();if(n){const t=this.renderLayers();i=(0,s.x)(t,Boolean),this.internalState.subLayers=i}(0,o.Z)("compositeLayer.renderLayers",this,n,i);for(const o of i)o.parent=this}}a.layerName="CompositeLayer"},43631:(t,e,i)=>{"use strict";i.d(e,{Df:()=>o,FP:()=>a,iI:()=>r,zG:()=>s});var n=i(89745);const o={DEFAULT:-1,LNGLAT:1,METER_OFFSETS:2,LNGLAT_OFFSETS:3,CARTESIAN:0};Object.defineProperty(o,"IDENTITY",{get:()=>(n.Z.deprecated("COORDINATE_SYSTEM.IDENTITY","COORDINATE_SYSTEM.CARTESIAN")(),0)});const s={WEB_MERCATOR:1,GLOBE:2,WEB_MERCATOR_AUTO_OFFSET:4,IDENTITY:0},r={common:0,meters:1,pixels:2},a={click:{handler:"onClick"},panstart:{handler:"onDragStart"},panmove:{handler:"onDrag"},panend:{handler:"onDragEnd"}}},83779:(t,e,i)=>{"use strict";i.d(e,{Z:()=>et});var n=i(26236),o=i(65663),s=i(89745),r=i(14503),a=i(32332),l=i(23881),c=i(96742);class d{constructor(t,e,i){this._loadCount=0,this._subscribers=new Set,this.id=t,this.context=i,this.setData(e)}subscribe(t){this._subscribers.add(t)}unsubscribe(t){this._subscribers.delete(t)}inUse(){return this._subscribers.size>0}delete(){}getData(){return this.isLoaded?this._error?Promise.reject(this._error):this._content:this._loader.then((()=>this.getData()))}setData(t,e){if(t===this._data&&!e)return;this._data=t;const i=++this._loadCount;let n=t;"string"==typeof t&&(n=(0,c.z)(t)),n instanceof Promise?(this.isLoaded=!1,this._loader=n.then((t=>{this._loadCount===i&&(this.isLoaded=!0,this._error=void 0,this._content=t)})).catch((t=>{this._loadCount===i&&(this.isLoaded=!0,this._error=t||!0)}))):(this.isLoaded=!0,this._error=void 0,this._content=t);for(const o of this._subscribers)o.onChange(this.getData())}}class u{constructor(t){let{gl:e,protocol:i}=t;this.protocol=i||"resource://",this._context={gl:e,resourceManager:this},this._resources={},this._consumers={},this._pruneRequest=null}contains(t){return!!t.startsWith(this.protocol)||t in this._resources}add(t){let{resourceId:e,data:i,forceUpdate:n=!1,persistent:o=!0}=t,s=this._resources[e];s?s.setData(i,n):(s=new d(e,i,this._context),this._resources[e]=s),s.persistent=o}remove(t){const e=this._resources[t];e&&(e.delete(),delete this._resources[t])}unsubscribe(t){let{consumerId:e}=t;const i=this._consumers[e];if(i){for(const t in i){const e=i[t],n=this._resources[e.resourceId];n&&n.unsubscribe(e)}delete this._consumers[e],this.prune()}}subscribe(t){let{resourceId:e,onChange:i,consumerId:n,requestId:o="default"}=t;const{_resources:s,protocol:r}=this;e.startsWith(r)&&(e=e.replace(r,""),s[e]||this.add({resourceId:e,data:null,persistent:!1}));const a=s[e];if(this._track(n,o,a,i),a)return a.getData()}prune(){this._pruneRequest||(this._pruneRequest=setTimeout((()=>this._prune()),0))}finalize(){for(const t in this._resources)this._resources[t].delete()}_track(t,e,i,n){const o=this._consumers,s=o[t]=o[t]||{},r=s[e]||{},a=r.resourceId&&this._resources[r.resourceId];a&&(a.unsubscribe(r),this.prune()),i&&(s[e]=r,r.onChange=n,r.resourceId=i.id,i.subscribe(r))}_prune(){this._pruneRequest=null;for(const t of Object.keys(this._resources)){const e=this._resources[t];e.persistent||e.inUse()||(e.delete(),delete this._resources[t])}}}var p=i(48332),h=i(74797);const g=[i(73782).Z],f=["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)","vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)","vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)","fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];function m(t){const e=h.Z.getDefaultProgramManager(t);for(const i of g)e.addDefaultModule(i);for(const i of f)e.addShaderHook(i);return e}class v{constructor(t,e){let{deck:i,stats:o,viewport:s,timeline:a}=void 0===e?{}:e;this._lastRenderedLayers=[],this._needsRedraw=!1,this._needsUpdate=!1,this._nextLayers=null,this._debug=!1,this.activateViewport=t=>{(0,r.Z)("layerManager.activateViewport",this,t),t&&(this.context.viewport=t)},this.layers=[],this.resourceManager=new u({gl:t,protocol:"deck://"}),this.context={mousePosition:null,userData:{},layerManager:this,gl:t,deck:i,programManager:t&&m(t),stats:o||new l.Z({id:"deck.gl"}),viewport:s||new p.Z({id:"DEFAULT-INITIAL-VIEWPORT"}),timeline:a||new n.T,resourceManager:this.resourceManager,onError:void 0},Object.seal(this)}finalize(){this.resourceManager.finalize();for(const t of this.layers)this._finalizeLayer(t)}needsRedraw(t){void 0===t&&(t={clearRedrawFlags:!1});let e=this._needsRedraw;t.clearRedrawFlags&&(this._needsRedraw=!1);for(const i of this.layers){const n=i.getNeedsRedraw(t);e=e||n}return e}needsUpdate(){return this._nextLayers&&this._nextLayers!==this._lastRenderedLayers?"layers changed":this._needsUpdate}setNeedsRedraw(t){this._needsRedraw=this._needsRedraw||t}setNeedsUpdate(t){this._needsUpdate=this._needsUpdate||t}getLayers(t){let{layerIds:e}=void 0===t?{}:t;return e?this.layers.filter((t=>e.find((e=>0===t.id.indexOf(e))))):this.layers}setProps(t){"debug"in t&&(this._debug=t.debug),"userData"in t&&(this.context.userData=t.userData),"layers"in t&&(this._nextLayers=t.layers),"onError"in t&&(this.context.onError=t.onError)}setLayers(t,e){(0,r.Z)("layerManager.setLayers",this,e,t),this._lastRenderedLayers=t;const i=(0,a.x)(t,Boolean);for(const n of i)n.context=this.context;this._updateLayers(this.layers,i)}updateLayers(){const t=this.needsUpdate();t&&(this.setNeedsRedraw("updating layers: "+t),this.setLayers(this._nextLayers||this._lastRenderedLayers,t)),this._nextLayers=null}_handleError(t,e,i){i.raiseError(e,t+" of "+i)}_updateLayers(t,e){const i={};for(const r of t)i[r.id]?s.Z.warn("Multiple old layers with same id "+r.id)():i[r.id]=r;const n=[];this._updateSublayersRecursively(e,i,n),this._finalizeOldLayers(i);let o=!1;for(const s of n)if(s.hasUniformTransition()){o="Uniform transition in "+s;break}this._needsUpdate=o,this.layers=n}_updateSublayersRecursively(t,e,i){for(const o of t){o.context=this.context;const t=e[o.id];null===t&&s.Z.warn("Multiple new layers with same id "+o.id)(),e[o.id]=null;let r=null;try{this._debug&&t!==o&&o.validateProps(),t?(this._transferLayerState(t,o),this._updateLayer(o)):this._initializeLayer(o),i.push(o),r=o.isComposite?o.getSubLayers():null}catch(n){this._handleError("matching",n,o)}r&&this._updateSublayersRecursively(r,e,i)}}_finalizeOldLayers(t){for(const e in t){const i=t[e];i&&this._finalizeLayer(i)}}_initializeLayer(t){try{t._initialize(),t.lifecycle=o.dt.INITIALIZED}catch(e){this._handleError("initialization",e,t)}}_transferLayerState(t,e){e._transferState(t),e.lifecycle=o.dt.MATCHED,e!==t&&(t.lifecycle=o.dt.AWAITING_GC)}_updateLayer(t){try{t._update()}catch(e){this._handleError("update",e,t)}}_finalizeLayer(t){this._needsRedraw=this._needsRedraw||"finalized "+t,t.lifecycle=o.dt.AWAITING_FINALIZATION;try{t._finalize(),t.lifecycle=o.dt.FINALIZED}catch(e){this._handleError("finalization",e,t)}}}var y=i(77607);class _{constructor(t){this.views=[],this.width=100,this.height=100,this.viewState={},this.controllers={},this.timeline=t.timeline,this._viewports=[],this._viewportMap={},this._isUpdating=!1,this._needsRedraw="First render",this._needsUpdate="Initialize",this._eventManager=t.eventManager,this._eventCallbacks={onViewStateChange:t.onViewStateChange,onInteractionStateChange:t.onInteractionStateChange},Object.seal(this),this.setProps(t)}finalize(){for(const t in this.controllers){const e=this.controllers[t];e&&e.finalize()}this.controllers={}}needsRedraw(t){void 0===t&&(t={clearRedrawFlags:!1});const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}setNeedsUpdate(t){this._needsUpdate=this._needsUpdate||t,this._needsRedraw=this._needsRedraw||t}updateViewStates(){for(const t in this.controllers){const e=this.controllers[t];e&&e.updateTransition()}}getViewports(t){return t?this._viewports.filter((e=>e.containsPixel(t))):this._viewports}getViews(){const t={};return this.views.forEach((e=>{t[e.id]=e})),t}getView(t){return this.views.find((e=>e.id===t))}getViewState(t){const e="string"==typeof t?this.getView(t):t,i=e&&this.viewState[e.getViewStateId()]||this.viewState;return e?e.filterViewState(i):i}getViewport(t){return this._viewportMap[t]}unproject(t,e){const i=this.getViewports(),n={x:t[0],y:t[1]};for(let o=i.length-1;o>=0;--o){const s=i[o];if(s.containsPixel(n)){const i=t.slice();return i[0]-=s.x,i[1]-=s.y,s.unproject(i,e)}}return null}setProps(t){t.views&&this._setViews(t.views),t.viewState&&this._setViewState(t.viewState),("width"in t||"height"in t)&&this._setSize(t.width,t.height),this._isUpdating||this._update()}_update(){this._isUpdating=!0,this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._needsUpdate&&(this._needsUpdate=!1,this._rebuildViewports()),this._isUpdating=!1}_setSize(t,e){t===this.width&&e===this.height||(this.width=t,this.height=e,this.setNeedsUpdate("Size changed"))}_setViews(t){t=(0,a.x)(t,Boolean);this._diffViews(t,this.views)&&this.setNeedsUpdate("views changed"),this.views=t}_setViewState(t){if(t){!(0,y.v)(t,this.viewState,1)&&this.setNeedsUpdate("viewState changed"),this.viewState=t}else s.Z.warn("missing `viewState` or `initialViewState`")()}_onViewStateChange(t,e){this._eventCallbacks.onViewStateChange&&this._eventCallbacks.onViewStateChange({...e,viewId:t})}_createController(t,e){return new(0,e.type)({timeline:this.timeline,eventManager:this._eventManager,onViewStateChange:this._onViewStateChange.bind(this,e.id),onStateChange:this._eventCallbacks.onInteractionStateChange,makeViewport:e=>{var i;return null==(i=this.getView(t.id))?void 0:i.makeViewport({viewState:e,width:this.width,height:this.height})}})}_updateController(t,e,i,n){const o=t.controller;if(o){const s={...e,...o,id:t.id,x:i.x,y:i.y,width:i.width,height:i.height};return n||(n=this._createController(t,s)),n&&n.setProps(s),n}return null}_rebuildViewports(){const{views:t}=this,e=this.controllers;this._viewports=[],this.controllers={};let i=!1;for(let n=t.length;n--;){const o=t[n],s=this.getViewState(o),r=o.makeViewport({viewState:s,width:this.width,height:this.height});let a=e[o.id];const l=Boolean(o.controller);l&&!a&&(i=!0),!i&&l||!a||(a.finalize(),a=null),this.controllers[o.id]=this._updateController(o,s,r,a),this._viewports.unshift(r)}for(const n in e){const t=e[n];t&&!this.controllers[n]&&t.finalize()}this._buildViewportMap()}_buildViewportMap(){this._viewportMap={},this._viewports.forEach((t=>{t.id&&(this._viewportMap[t.id]=this._viewportMap[t.id]||t)}))}_diffViews(t,e){return t.length!==e.length||t.some(((i,n)=>!t[n].equals(e[n])))}}var w=i(6362),b=i(6192);const P=new b.Z;class x{constructor(){this._resolvedEffects=[],this._defaultEffects=[],this.effects=[],this._needsRedraw="Initial render",this._setEffects([])}addDefaultEffect(t){const e=this._defaultEffects;if(!e.find((e=>e.id===t.id))){const i=e.findIndex((e=>{return i=t,(null!=(n=e.order)?n:1/0)-(null!=(o=i.order)?o:1/0)>0;var i,n,o}));i<0?e.push(t):e.splice(i,0,t),this._setEffects(this.effects)}}setProps(t){"effects"in t&&(t.effects.length===this.effects.length&&(0,y.v)(t.effects,this.effects,1)||this._setEffects(t.effects))}needsRedraw(t){void 0===t&&(t={clearRedrawFlags:!1});const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}getEffects(){return this._resolvedEffects}_setEffects(t){const e={};for(const n of this.effects)e[n.id]=n;const i=[];for(const n of t){const t=e[n.id];t&&t!==n?t.setProps?(t.setProps(n.props),i.push(t)):(t.cleanup(),i.push(n)):i.push(n),delete e[n.id]}for(const n in e)e[n].cleanup();this.effects=i,this._resolvedEffects=i.concat(this._defaultEffects),t.some((t=>t instanceof b.Z))||this._resolvedEffects.push(P),this._needsRedraw="effects changed"}finalize(){for(const t of this._resolvedEffects)t.cleanup();this.effects.length=0,this._resolvedEffects.length=0,this._defaultEffects.length=0}}var C=i(5259);class S extends C.Z{shouldDrawLayer(t){const{operation:e}=t.props;return e.includes("draw")||e.includes("terrain")}}var L=i(7092);const M={blendFunc:[1,0,32771,0],blendEquation:32774};class k extends C.Z{constructor(){super(...arguments),this._colorEncoderState=null}render(t){return"pickingFBO"in t?this._drawPickingBuffer(t):super.render(t)}_drawPickingBuffer(t){let{layers:e,layerFilter:i,views:n,viewports:o,onViewportActive:s,pickingFBO:r,deviceRect:{x:a,y:l,width:c,height:d},cullRect:u,effects:p,pass:h="picking",pickZ:g,moduleParameters:f}=t;const m=this.gl;this.pickZ=g;const v=this._resetColorEncoder(g),y=(0,L.s8)(m,{scissorTest:!0,scissor:[a,l,c,d],clearColor:[0,0,0,0],depthMask:!0,depthTest:!0,depthRange:[0,1],colorMask:[!0,!0,!0,!0],...M,blend:!g},(()=>super.render({target:r,layers:e,layerFilter:i,views:n,viewports:o,onViewportActive:s,cullRect:u,effects:null==p?void 0:p.filter((t=>t.useInPicking)),pass:h,isPicking:!0,moduleParameters:f})));this._colorEncoderState=null;return{decodePickingColor:v&&T.bind(null,v),stats:y}}shouldDrawLayer(t){const{pickable:e,operation:i}=t.props;return e&&i.includes("draw")||i.includes("terrain")}getModuleParameters(){return{pickingActive:1,pickingAttribute:this.pickZ,lightSources:{}}}getLayerParameters(t,e,i){const n={...t.props.parameters},{pickable:o,operation:r}=t.props;return this._colorEncoderState?o&&r.includes("draw")&&(Object.assign(n,M),n.blend=!0,n.blendColor=function(t,e,i){const{byLayer:n,byAlpha:o}=t;let r,a=n.get(e);a?(a.viewports.push(i),r=a.a):(r=n.size+1,r<=255?(a={a:r,layer:e,viewports:[i]},n.set(e,a),o[r]=a):(s.Z.warn("Too many pickable layers, only picking the first 255")(),r=0));return[0,0,0,r/255]}(this._colorEncoderState,t,i)):n.blend=!1,r.includes("terrain")&&(n.blend=!1),n}_resetColorEncoder(t){return this._colorEncoderState=t?null:{byLayer:new Map,byAlpha:[]},this._colorEncoderState}}function T(t,e){const i=t.byAlpha[e[3]];return i&&{pickedLayer:i.layer,pickedViewports:i.viewports,pickedObjectIndex:i.layer.decodePickingColor(e)}}var E=i(79762);class I{constructor(t){this.gl=t,this.layerFilter=null,this.drawPickingColors=!1,this.drawLayersPass=new S(t),this.pickLayersPass=new k(t),this.renderCount=0,this._needsRedraw="Initial render",this.renderBuffers=[],this.lastPostProcessEffect=null}setProps(t){this.layerFilter!==t.layerFilter&&(this.layerFilter=t.layerFilter,this._needsRedraw="layerFilter changed"),this.drawPickingColors!==t.drawPickingColors&&(this.drawPickingColors=t.drawPickingColors,this._needsRedraw="drawPickingColors changed")}renderLayers(t){const e=this.drawPickingColors?this.pickLayersPass:this.drawLayersPass,i={layerFilter:this.layerFilter,isPicking:this.drawPickingColors,...t,target:t.target||E.Z.getDefaultFramebuffer(this.gl)};i.effects&&this._preRender(i.effects,i);const n=this.lastPostProcessEffect?this.renderBuffers[0]:i.target,o=e.render({...i,target:n});i.effects&&this._postRender(i.effects,i),this.renderCount++,(0,r.Z)("deckRenderer.renderLayers",this,o,t)}needsRedraw(t){void 0===t&&(t={clearRedrawFlags:!1});const e=this._needsRedraw;return t.clearRedrawFlags&&(this._needsRedraw=!1),e}finalize(){const{renderBuffers:t}=this;for(const e of t)e.delete();t.length=0}_preRender(t,e){this.lastPostProcessEffect=null,e.preRenderStats=e.preRenderStats||{};for(const i of t)e.preRenderStats[i.id]=i.preRender(this.gl,e),i.postRender&&(this.lastPostProcessEffect=i.id);this.lastPostProcessEffect&&this._resizeRenderBuffers()}_resizeRenderBuffers(){const{renderBuffers:t}=this;0===t.length&&t.push(new E.Z(this.gl),new E.Z(this.gl));for(const e of t)e.resize()}_postRender(t,e){const{renderBuffers:i}=this,n={...e,inputBuffer:i[0],swapBuffer:i[1],target:null};for(const o of t)if(o.postRender){if(o.id===this.lastPostProcessEffect){n.target=e.target,o.postRender(this.gl,n);break}const t=o.postRender(this.gl,n);n.inputBuffer=t,n.swapBuffer=t===i[0]?i[1]:i[0]}}}var A=i(43970),O=i(88163);const R={pickedColor:null,pickedObjectIndex:-1};function z(t){let{pickedColors:e,decodePickingColor:i,deviceX:n,deviceY:o,deviceRadius:r,deviceRect:a}=t;const{x:l,y:c,width:d,height:u}=a;let p=r*r,h=-1,g=0;for(let s=0;s<u;s++){const t=s+c-o,i=t*t;if(i>p)g+=4*d;else for(let o=0;o<d;o++){if(e[g+3]-1>=0){const t=o+l-n,e=t*t+i;e<=p&&(p=e,h=g)}g+=4}}if(h>=0){const t=e.slice(h,h+4),n=i(t);if(n){const e=Math.floor(h/4/d),i=h/4-e*d;return{...n,pickedColor:t,pickedX:l+i,pickedY:c+e}}s.Z.error("Picked non-existent layer. Is picking buffer corrupt?")()}return R}function j(t){let e,{pickInfo:i,viewports:n,pixelRatio:o,x:s,y:r,z:a}=t,l=n[0];if(n.length>1&&(l=function(t,e){for(let i=t.length-1;i>=0;i--){const n=t[i];if(n.containsPixel(e))return n}return t[0]}((null==i?void 0:i.pickedViewports)||n,{x:s,y:r})),l){const t=[s-l.x,r-l.y];void 0!==a&&(t[2]=a),e=l.unproject(t)}return{color:null,layer:null,viewport:l,index:-1,picked:!1,x:s,y:r,pixel:[s,r],coordinate:e,devicePixel:i&&"pickedX"in i?[i.pickedX,i.pickedY]:void 0,pixelRatio:o}}function N(t){const{pickInfo:e,lastPickedInfo:i,mode:n,layers:o}=t,{pickedColor:s,pickedLayer:r,pickedObjectIndex:a}=e,l=r?[r]:[];if("hover"===n){const t=i.index,e=i.layerId,n=r?r.props.id:null;if(n!==e||a!==t){if(n!==e){const t=o.find((t=>t.props.id===e));t&&l.unshift(t)}i.layerId=n,i.index=a,i.info=null}}const c=j(t),d=new Map;return d.set(null,c),l.forEach((t=>{let e={...c};t===r&&(e.color=s,e.index=a,e.picked=!0),e=D({layer:t,info:e,mode:n});const o=e.layer;t===r&&"hover"===n&&(i.info=e),d.set(o.id,e),"hover"===n&&o.updateAutoHighlight(e)})),d}function D(t){let{layer:e,info:i,mode:n}=t;for(;e&&i;){const t=i.layer||null;i.sourceLayer=t,i.layer=e,i=e.getPickingInfo({info:i,mode:n,sourceLayer:t}),e=e.parent}return i}class F{constructor(t){this._pickable=!0,this.gl=t,this.pickLayersPass=new k(t),this.lastPickedInfo={index:-1,layerId:null,info:null}}setProps(t){"layerFilter"in t&&(this.layerFilter=t.layerFilter),"_pickable"in t&&(this._pickable=t._pickable)}finalize(){this.pickingFBO&&this.pickingFBO.delete(),this.depthFBO&&(this.depthFBO.color.delete(),this.depthFBO.delete())}pickObject(t){return this._pickClosestObject(t)}pickObjects(t){return this._pickVisibleObjects(t)}getLastPickedObject(t,e){let{x:i,y:n,layers:o,viewports:s}=t;void 0===e&&(e=this.lastPickedInfo.info);const r=e&&e.layer&&e.layer.id,a=e&&e.viewport&&e.viewport.id,l=r?o.find((t=>t.id===r)):null,c=a&&s.find((t=>t.id===a))||s[0],d=c&&c.unproject([i-c.x,n-c.y]),u={x:i,y:n,viewport:c,coordinate:d,layer:l};return{...e,...u}}_resizeBuffer(){var t,e;const{gl:i}=this;if(!this.pickingFBO&&(this.pickingFBO=new E.Z(i),E.Z.isSupported(i,{colorBufferFloat:!0}))){const t=new E.Z(i);t.attach({36064:new A.Z(i,{format:(0,L.D0)(i)?34836:6408,type:5126})}),this.depthFBO=t}null==(t=this.pickingFBO)||t.resize({width:i.canvas.width,height:i.canvas.height}),null==(e=this.depthFBO)||e.resize({width:i.canvas.width,height:i.canvas.height})}_getPickable(t){if(!1===this._pickable)return null;const e=t.filter((t=>this.pickLayersPass.shouldDrawLayer(t)&&!t.isComposite));return e.length?e:null}_pickClosestObject(t){let{layers:e,views:i,viewports:n,x:o,y:s,radius:r=0,depth:a=1,mode:l="query",unproject3D:c,onViewportActive:d,effects:u}=t;const p=this._getPickable(e),h=(0,L.w)(this.gl);if(!p)return{result:[],emptyInfo:j({viewports:n,x:o,y:s,pixelRatio:h})};this._resizeBuffer();const g=(0,L.JY)(this.gl,[o,s],!0),f=[g.x+Math.floor(g.width/2),g.y+Math.floor(g.height/2)],m=Math.round(r*h),{width:v,height:y}=this.pickingFBO,_=this._getPickingRect({deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceWidth:v,deviceHeight:y}),w={x:o-r,y:s-r,width:2*r+1,height:2*r+1};let b;const P=[],x=new Set;for(let C=0;C<a;C++){let t,e;if(_){t=z({...this._drawAndSample({layers:p,views:i,viewports:n,onViewportActive:d,deviceRect:_,cullRect:w,effects:u,pass:"picking:"+l}),deviceX:f[0],deviceY:f[1],deviceRadius:m,deviceRect:_})}else t={pickedColor:null,pickedObjectIndex:-1};if(t.pickedLayer&&c&&this.depthFBO){const{pickedColors:o}=this._drawAndSample({layers:[t.pickedLayer],views:i,viewports:n,onViewportActive:d,deviceRect:{x:t.pickedX,y:t.pickedY,width:1,height:1},cullRect:w,effects:u,pass:"picking:"+l+":z"},!0);o[3]&&(e=o[0])}t.pickedLayer&&C+1<a&&(x.add(t.pickedLayer),t.pickedLayer.disablePickingIndex(t.pickedObjectIndex)),b=N({pickInfo:t,lastPickedInfo:this.lastPickedInfo,mode:l,layers:p,viewports:n,x:o,y:s,z:e,pixelRatio:h});for(const i of b.values())i.layer&&P.push(i);if(!t.pickedColor)break}for(const C of x)C.restorePickingColors();return{result:P,emptyInfo:b.get(null)}}_pickVisibleObjects(t){let{layers:e,views:i,viewports:n,x:o,y:r,width:a=1,height:l=1,mode:c="query",maxObjects:d=null,onViewportActive:u,effects:p}=t;const h=this._getPickable(e);if(!h)return[];this._resizeBuffer();const g=(0,L.w)(this.gl),f=(0,L.JY)(this.gl,[o,r],!0),m=f.x,v=f.y+f.height,y=(0,L.JY)(this.gl,[o+a,r+l],!0),_=y.x+y.width,w=y.y,b={x:m,y:w,width:_-m,height:v-w},P=function(t){let{pickedColors:e,decodePickingColor:i}=t;const n=new Map;if(e)for(let o=0;o<e.length;o+=4)if(e[o+3]-1>=0){const t=e.slice(o,o+4),r=t.join(",");if(!n.has(r)){const e=i(t);e?n.set(r,{...e,color:t}):s.Z.error("Picked non-existent layer. Is picking buffer corrupt?")()}}return Array.from(n.values())}(this._drawAndSample({layers:h,views:i,viewports:n,onViewportActive:u,deviceRect:b,cullRect:{x:o,y:r,width:a,height:l},effects:p,pass:"picking:"+c})),x=new Map,C=Number.isFinite(d);for(let s=0;s<P.length&&!(C&&d&&x.size>=d);s++){const t=P[s];let e={color:t.pickedColor,layer:null,index:t.pickedObjectIndex,picked:!0,x:o,y:r,pixelRatio:g};e=D({layer:t.pickedLayer,info:e,mode:c}),x.has(e.object)||x.set(e.object,e)}return Array.from(x.values())}_drawAndSample(t,e){let{layers:i,views:n,viewports:o,onViewportActive:s,deviceRect:r,cullRect:a,effects:l,pass:c}=t;void 0===e&&(e=!1);const d=e?this.depthFBO:this.pickingFBO,u={layers:i,layerFilter:this.layerFilter,views:n,viewports:o,onViewportActive:s,pickingFBO:d,deviceRect:r,cullRect:a,effects:l,pass:c,pickZ:e,preRenderStats:{}};for(const y of l)y.useInPicking&&(u.preRenderStats[y.id]=y.preRender(this.gl,u));const{decodePickingColor:p}=this.pickLayersPass.render(u),{x:h,y:g,width:f,height:m}=r,v=new(e?Float32Array:Uint8Array)(f*m*4);return(0,O.z6)(d,{sourceX:h,sourceY:g,sourceWidth:f,sourceHeight:m,target:v}),{pickedColors:v,decodePickingColor:p}}_getPickingRect(t){let{deviceX:e,deviceY:i,deviceRadius:n,deviceWidth:o,deviceHeight:s}=t;const r=Math.max(0,e-n),a=Math.max(0,i-n),l=Math.min(o,e+n+1)-r,c=Math.min(s,i+n+1)-a;return l<=0||c<=0?null:{x:r,y:a,width:l,height:c}}}const U={zIndex:"1",position:"absolute",pointerEvents:"none",color:"#a0a7b4",backgroundColor:"#29323c",padding:"10px",top:"0",left:"0",display:"none"};class Z{constructor(t){this.el=null,this.isVisible=!1;const e=t.parentElement;e&&(this.el=document.createElement("div"),this.el.className="deck-tooltip",Object.assign(this.el.style,U),e.appendChild(this.el))}setTooltip(t,e,i){const n=this.el;if(n){if("string"==typeof t)n.innerText=t;else{if(!t)return this.isVisible=!1,void(n.style.display="none");t.text&&(n.innerText=t.text),t.html&&(n.innerHTML=t.html),t.className&&(n.className=t.className),Object.assign(n.style,t.style)}this.isVisible=!0,n.style.display="block",n.style.transform="translate("+e+"px, "+i+"px)"}}remove(){this.el&&(this.el.remove(),this.el=null)}}var V=i(67258),B=i(28119),W=i(17074);const G={id:"JSON",name:"JSON",module:"",version:"",options:{},extensions:["json","geojson"],mimeTypes:["application/json","application/geo+json"],testText:function(t){const e=t[0],i=t[t.length-1];return"{"===e&&"}"===i||"["===e&&"]"===i},parseTextSync:JSON.parse};const H=function(){const t="0.0.0",e=globalThis.deck&&globalThis.deck.VERSION;if(e&&e!==t)throw new Error("deck.gl - multiple versions detected: "+e+" vs "+t);return e||(s.Z.log(1,"deck.gl "+t)(),globalThis.deck={...globalThis.deck,VERSION:t,version:t,log:s.Z,_registerLoggers:r.z},(0,B.fh)([G,[W.S,{imagebitmap:{premultiplyAlpha:"none"}}]])),t}();var q=i(9749),K=i(28775),Y=i(65259),X=i(10437),J=i(13405),$=i(43631);function Q(){}const tt={id:"",width:"100%",height:"100%",style:null,viewState:null,initialViewState:null,pickingRadius:0,layerFilter:null,glOptions:{},parameters:{},parent:null,gl:null,canvas:null,layers:[],effects:[],views:null,controller:null,useDevicePixels:!0,touchAction:"none",eventRecognizerOptions:{},_framebuffer:null,_animate:!1,_pickable:!0,_typedArrayManagerProps:{},_customRender:null,onWebGLInitialized:Q,onResize:Q,onViewStateChange:Q,onInteractionStateChange:Q,onBeforeRender:Q,onAfterRender:Q,onLoad:Q,onError:t=>s.Z.error(t.message)(),onHover:null,onClick:null,onDragStart:null,onDrag:null,onDragEnd:null,_onMetrics:null,getCursor:t=>{let{isDragging:e}=t;return e?"grabbing":"grab"},getTooltip:null,debug:!1,drawPickingColors:!1};class et{constructor(t){this.width=0,this.height=0,this.userData={},this.canvas=null,this.viewManager=null,this.layerManager=null,this.effectManager=null,this.deckRenderer=null,this.deckPicker=null,this.eventManager=null,this.tooltip=null,this._lastPointerDownInfo=null,this._onPointerMove=t=>{const{_pickRequest:e}=this;if("pointerleave"===t.type)e.x=-1,e.y=-1,e.radius=0;else{if(t.leftButton||t.rightButton)return;{const i=t.offsetCenter;if(!i)return;e.x=i.x,e.y=i.y,e.radius=this.props.pickingRadius}}this.layerManager&&(this.layerManager.context.mousePosition={x:e.x,y:e.y}),e.event=t},this._onEvent=t=>{const e=$.FP[t.type],i=t.offsetCenter;if(!e||!i||!this.layerManager)return;const n=this.layerManager.getLayers(),o=this.deckPicker.getLastPickedObject({x:i.x,y:i.y,layers:n,viewports:this.getViewports(i)},this._lastPointerDownInfo),{layer:s}=o,r=s&&(s[e.handler]||s.props[e.handler]),a=this.props[e.handler];let l=!1;r&&(l=r.call(s,o,t)),!l&&a&&a(o,t)},this._onPointerDown=t=>{const e=t.offsetCenter,i=this._pick("pickObject","pickObject Time",{x:e.x,y:e.y,radius:this.props.pickingRadius});this._lastPointerDownInfo=i.result[0]||i.emptyInfo},this.props={...tt,...t},t=this.props,this._needsRedraw="Initial render",this._pickRequest={mode:"hover",x:-1,y:-1,radius:0,event:null},this.cursorState={isHovering:!1,isDragging:!1},t.viewState&&t.initialViewState&&s.Z.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(),"IE"===(0,q.Z)()&&s.Z.warn("IE 11 is not supported")(),this.viewState=t.initialViewState,t.gl||"undefined"!=typeof document&&(this.canvas=this._createCanvas(t)),this.animationLoop=this._createAnimationLoop(t),this.stats=new l.Z({id:"deck.gl"}),this.metrics={fps:0,setPropsTime:0,updateAttributesTime:0,framesRedrawn:0,pickTime:0,pickCount:0,gpuTime:0,gpuTimePerFrame:0,cpuTime:0,cpuTimePerFrame:0,bufferMemory:0,textureMemory:0,renderbufferMemory:0,gpuMemory:0},this._metricsCounter=0,this.setProps(t),t._typedArrayManagerProps&&V.Z.setOptions(t._typedArrayManagerProps),this.animationLoop.start()}finalize(){var t,e,i,n,o,s,r,a;(this.animationLoop.stop(),this.animationLoop=null,this._lastPointerDownInfo=null,null==(t=this.layerManager)||t.finalize(),this.layerManager=null,null==(e=this.viewManager)||e.finalize(),this.viewManager=null,null==(i=this.effectManager)||i.finalize(),this.effectManager=null,null==(n=this.deckRenderer)||n.finalize(),this.deckRenderer=null,null==(o=this.deckPicker)||o.finalize(),this.deckPicker=null,null==(s=this.eventManager)||s.destroy(),this.eventManager=null,null==(r=this.tooltip)||r.remove(),this.tooltip=null,this.props.canvas||this.props.gl||!this.canvas)||(null==(a=this.canvas.parentElement)||a.removeChild(this.canvas),this.canvas=null)}setProps(t){this.stats.get("setProps Time").timeStart(),"onLayerHover"in t&&s.Z.removed("onLayerHover","onHover")(),"onLayerClick"in t&&s.Z.removed("onLayerClick","onClick")(),t.initialViewState&&!(0,y.v)(this.props.initialViewState,t.initialViewState,1)&&(this.viewState=t.initialViewState),Object.assign(this.props,t),this._setCanvasSize(this.props);const e=Object.create(this.props);Object.assign(e,{views:this._getViews(),width:this.width,height:this.height,viewState:this._getViewState()}),this.animationLoop.setProps(e),this.layerManager&&(this.viewManager.setProps(e),this.layerManager.activateViewport(this.getViewports()[0]),this.layerManager.setProps(e),this.effectManager.setProps(e),this.deckRenderer.setProps(e),this.deckPicker.setProps(e)),this.stats.get("setProps Time").timeEnd()}needsRedraw(t){if(void 0===t&&(t={clearRedrawFlags:!1}),!this.layerManager)return!1;if(this.props._animate)return"Deck._animate";let e=this._needsRedraw;t.clearRedrawFlags&&(this._needsRedraw=!1);const i=this.viewManager.needsRedraw(t),n=this.layerManager.needsRedraw(t),o=this.effectManager.needsRedraw(t),s=this.deckRenderer.needsRedraw(t);return e=e||i||n||o||s,e}redraw(t){if(!this.layerManager)return;let e=this.needsRedraw({clearRedrawFlags:!0});e=t||e,e&&(this.stats.get("Redraw Count").incrementCount(),this.props._customRender?this.props._customRender(e):this._drawLayers(e))}get isInitialized(){return null!==this.viewManager}getViews(){return(0,J.Z)(this.viewManager),this.viewManager.views}getViewports(t){return(0,J.Z)(this.viewManager),this.viewManager.getViewports(t)}pickObject(t){const e=this._pick("pickObject","pickObject Time",t).result;return e.length?e[0]:null}pickMultipleObjects(t){return t.depth=t.depth||10,this._pick("pickObject","pickMultipleObjects Time",t).result}pickObjects(t){return this._pick("pickObjects","pickObjects Time",t)}_addResources(t,e){void 0===e&&(e=!1);for(const i in t)this.layerManager.resourceManager.add({resourceId:i,data:t[i],forceUpdate:e})}_removeResources(t){for(const e of t)this.layerManager.resourceManager.remove(e)}_addDefaultEffect(t){this.effectManager.addDefaultEffect(t)}_pick(t,e,i){(0,J.Z)(this.deckPicker);const{stats:n}=this;n.get("Pick Count").incrementCount(),n.get(e).timeStart();const o=this.deckPicker[t]({layers:this.layerManager.getLayers(i),views:this.viewManager.getViews(),viewports:this.getViewports(i),onViewportActive:this.layerManager.activateViewport,effects:this.effectManager.getEffects(),...i});return n.get(e).timeEnd(),o}_createCanvas(t){let e=t.canvas;if("string"==typeof e&&(e=document.getElementById(e),(0,J.Z)(e)),!e){e=document.createElement("canvas"),e.id=t.id||"deckgl-overlay";(t.parent||document.body).appendChild(e)}return Object.assign(e.style,t.style),e}_setCanvasSize(t){if(!this.canvas)return;const{width:e,height:i}=t;if(e||0===e){const t=Number.isFinite(e)?e+"px":e;this.canvas.style.width=t}if(i||0===i){var n;const e=Number.isFinite(i)?i+"px":i;this.canvas.style.position=(null==(n=t.style)?void 0:n.position)||"absolute",this.canvas.style.height=e}}_updateCanvasSize(){const{canvas:t}=this;if(!t)return;const e=t.clientWidth||t.width,i=t.clientHeight||t.height;var n;e===this.width&&i===this.height||(this.width=e,this.height=i,null==(n=this.viewManager)||n.setProps({width:e,height:i}),this.props.onResize({width:e,height:i}))}_createAnimationLoop(t){const{width:e,height:i,gl:n,glOptions:o,debug:s,onError:r,onBeforeRender:a,onAfterRender:l,useDevicePixels:c}=t;return new K.Z({width:e,height:i,useDevicePixels:c,autoResizeViewport:!1,gl:n,onCreateContext:t=>(0,L.s9)({...o,...t,canvas:this.canvas,debug:s,onContextLost:()=>this._onContextLost()}),onInitialize:t=>this._setGLContext(t.gl),onRender:this._onRenderFrame.bind(this),onBeforeRender:a,onAfterRender:l,onError:r})}_getViewState(){return this.props.viewState||this.viewState}_getViews(){let t=this.props.views||[new w.Z({id:"default-view"})];return t=Array.isArray(t)?t:[t],t.length&&this.props.controller&&(t[0].props.controller=this.props.controller),t}_onContextLost(){const{onError:t}=this.props;this.animationLoop&&t&&t(new Error("WebGL context is lost"))}_pickAndCallback(){const{_pickRequest:t}=this;if(t.event){const{result:i,emptyInfo:n}=this._pick("pickObject","pickObject Time",t);this.cursorState.isHovering=i.length>0;let o=n,s=!1;for(const r of i){var e;o=r,s=(null==(e=r.layer)?void 0:e.onHover(r,t.event))||s}if(!s&&this.props.onHover&&this.props.onHover(o,t.event),this.props.getTooltip&&this.tooltip){const t=this.props.getTooltip(o);this.tooltip.setTooltip(t,o.x,o.y)}t.event=null}}_updateCursor(){const t=this.props.parent||this.canvas;t&&(t.style.cursor=this.props.getCursor(this.cursorState))}_setGLContext(t){if(this.layerManager)return;this.canvas||(this.canvas=t.canvas,(0,L.yW)(t,{enable:!0,copyState:!0})),this.tooltip=new Z(this.canvas),(0,L.dR)(t,{blend:!0,blendFunc:[770,771,1,771],polygonOffsetFill:!0,depthTest:!0,depthFunc:515}),this.props.onWebGLInitialized(t);const e=new n.T;e.play(),this.animationLoop.attachTimeline(e),this.eventManager=new X.Q(this.props.parent||t.canvas,{touchAction:this.props.touchAction,recognizerOptions:this.props.eventRecognizerOptions,events:{pointerdown:this._onPointerDown,pointermove:this._onPointerMove,pointerleave:this._onPointerMove}});for(const n in $.FP)this.eventManager.on(n,this._onEvent);this.viewManager=new _({timeline:e,eventManager:this.eventManager,onViewStateChange:this._onViewStateChange.bind(this),onInteractionStateChange:this._onInteractionStateChange.bind(this),views:this._getViews(),viewState:this._getViewState(),width:this.width,height:this.height});const i=this.viewManager.getViewports()[0];this.layerManager=new v(t,{deck:this,stats:this.stats,viewport:i,timeline:e}),this.effectManager=new x,this.deckRenderer=new I(t),this.deckPicker=new F(t),this.setProps(this.props),this._updateCanvasSize(),this.props.onLoad()}_drawLayers(t,e){const{gl:i}=this.layerManager.context;(0,L.dR)(i,this.props.parameters),this.props.onBeforeRender({gl:i}),this.deckRenderer.renderLayers({target:this.props._framebuffer,layers:this.layerManager.getLayers(),viewports:this.viewManager.getViewports(),onViewportActive:this.layerManager.activateViewport,views:this.viewManager.getViews(),pass:"screen",effects:this.effectManager.getEffects(),...e}),this.props.onAfterRender({gl:i})}_onRenderFrame(t){this._getFrameStats(),this._metricsCounter++%60==0&&(this._getMetrics(),this.stats.reset(),s.Z.table(4,this.metrics)(),this.props._onMetrics&&this.props._onMetrics(this.metrics)),this._updateCanvasSize(),this._updateCursor(),this.tooltip.isVisible&&this.viewManager.needsRedraw()&&this.tooltip.setTooltip(null),this.layerManager.updateLayers(),this._pickAndCallback(),this.redraw(),this.viewManager&&this.viewManager.updateViewStates()}_onViewStateChange(t){const e=this.props.onViewStateChange(t)||t.viewState;this.viewState&&(this.viewState={...this.viewState,[t.viewId]:e},this.props.viewState||this.viewManager&&this.viewManager.setProps({viewState:this.viewState}))}_onInteractionStateChange(t){this.cursorState.isDragging=t.isDragging||!1,this.props.onInteractionStateChange(t)}_getFrameStats(){const{stats:t}=this;t.get("frameRate").timeEnd(),t.get("frameRate").timeStart();const e=this.animationLoop.stats;t.get("GPU Time").addTime(e.get("GPU Time").lastTiming),t.get("CPU Time").addTime(e.get("CPU Time").lastTiming)}_getMetrics(){const{metrics:t,stats:e}=this;t.fps=e.get("frameRate").getHz(),t.setPropsTime=e.get("setProps Time").time,t.updateAttributesTime=e.get("Update Attributes").time,t.framesRedrawn=e.get("Redraw Count").count,t.pickTime=e.get("pickObject Time").time+e.get("pickMultipleObjects Time").time+e.get("pickObjects Time").time,t.pickCount=e.get("Pick Count").count,t.gpuTime=e.get("GPU Time").time,t.cpuTime=e.get("CPU Time").time,t.gpuTimePerFrame=e.get("GPU Time").getAverageTime(),t.cpuTimePerFrame=e.get("CPU Time").getAverageTime();const i=Y.lR.get("Memory Usage");t.bufferMemory=i.get("Buffer Memory").count,t.textureMemory=i.get("Texture Memory").count,t.renderbufferMemory=i.get("Renderbuffer Memory").count,t.gpuMemory=i.get("GPU Memory").count}}et.defaultProps=tt,et.VERSION=H},47251:(t,e,i)=>{"use strict";i.d(e,{Z:()=>it});var n=i(43631),o=i(52747),s=i(98489),r=i(28835),a=i(62833);class l extends a.Z{get value(){return this._value}_onUpdate(){const{time:t,settings:{fromValue:e,toValue:i,duration:n,easing:o}}=this,s=o(t/n);this._value=(0,r.t7)(e,i,s)}}const c=1e-5;function d(t,e,i,n,o){const s=e-t;return(i-e)*o+-s*n+s+e}function u(t,e){if(Array.isArray(t)){let i=0;for(let n=0;n<t.length;n++){const o=t[n]-e[n];i+=o*o}return Math.sqrt(i)}return Math.abs(t-e)}class p extends a.Z{get value(){return this._currValue}_onUpdate(){const{fromValue:t,toValue:e,damping:i,stiffness:n}=this.settings,{_prevValue:o=t,_currValue:s=t}=this;let r=function(t,e,i,n,o){if(Array.isArray(i)){const s=[];for(let r=0;r<i.length;r++)s[r]=d(t[r],e[r],i[r],n,o);return s}return d(t,e,i,n,o)}(o,s,e,i,n);const a=u(r,e),l=u(r,s);a<c&&l<c&&(r=e,this.end()),this._prevValue=s,this._currValue=r}}var h=i(89745);const g={interpolation:l,spring:p};class f{constructor(t){this.transitions=new Map,this.timeline=t}get active(){return this.transitions.size>0}add(t,e,i,n){const{transitions:o}=this;if(o.has(t)){const i=o.get(t),{value:n=i.settings.fromValue}=i;e=n,this.remove(t)}if(!(n=(0,s.M0)(n)))return;const r=g[n.type];if(!r)return void h.Z.error("unsupported transition type '"+n.type+"'")();const a=new r(this.timeline);a.start({...n,fromValue:e,toValue:i}),o.set(t,a)}remove(t){const{transitions:e}=this;e.has(t)&&(e.get(t).cancel(),e.delete(t))}update(){const t={};for(const[e,i]of this.transitions)i.update(),t[e]=i.value,i.inProgress||this.remove(e);return t}clear(){for(const t of this.transitions.keys())this.remove(t)}}var m=i(65756),v=i(65663);const y="count(): argument not an object",_="count(): argument not a container";function w(t){if(null===(e=t)||"object"!=typeof e)throw new Error(y);var e;if("function"==typeof t.count)return t.count();if(Number.isFinite(t.size))return t.size;if(Number.isFinite(t.length))return t.length;if(function(t){return null!==t&&"object"==typeof t&&t.constructor===Object}(t))return Object.keys(t).length;throw new Error(_)}var b=i(14503),P=i(7092),x=i(13405),C=i(66508),S=i(16862),L=i(50961),M=i(67258),k=i(37944),T=i(43970);const E={10241:9987,10240:9729,10242:33071,10243:33071},I={};var A=i(77607);const O={boolean:{validate:(t,e)=>!0,equal:(t,e,i)=>Boolean(t)===Boolean(e)},number:{validate:(t,e)=>Number.isFinite(t)&&(!("max"in e)||t<=e.max)&&(!("min"in e)||t>=e.min)},color:{validate:(t,e)=>e.optional&&!t||N(t)&&(3===t.length||4===t.length),equal:(t,e,i)=>R(t,e)},accessor:{validate(t,e){const i=D(t);return"function"===i||i===D(e.value)},equal:(t,e,i)=>"function"==typeof e||R(t,e)},array:{validate:(t,e)=>e.optional&&!t||N(t),equal:(t,e,i)=>i.compare?R(t,e):t===e},object:{equal:(t,e,i)=>i.compare?(0,A.v)(t,e,i.depth||0):t===e},function:{validate:(t,e)=>e.optional&&!t||"function"==typeof t,equal:(t,e,i)=>!i.compare||t===e},data:{transform:(t,e,i)=>{const{dataTransform:n}=i.props;return n&&t?n(t):t}},image:{transform:(t,e,i)=>{const n=i.context;return n&&n.gl?function(t,e,i){if(e instanceof T.Z)return e;e.constructor&&"Object"!==e.constructor.name&&(e={data:e});let n=null;e.compressed&&(n={10241:e.data.length>1?9985:9729});const o=new T.Z(t,{...e,parameters:{...E,...n,...i}});return I[o.id]=!0,o}(n.gl,t,{...e.parameters,...i.props.textureParameters}):null},release:t=>{var e;(e=t)&&e instanceof T.Z&&I[e.id]&&(e.delete(),delete I[e.id])}}};function R(t,e){if(t===e)return!0;if(!N(t)||!N(e))return!1;const i=t.length;if(i!==e.length)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}function z(t,e){switch(D(e)){case"object":return j(t,e);case"array":return j(t,{type:"array",value:e,compare:!1});case"boolean":return j(t,{type:"boolean",value:e});case"number":return j(t,{type:"number",value:e});case"function":return j(t,{type:"function",value:e,compare:!0});default:return{name:t,type:"unknown",value:e}}}function j(t,e){return"type"in e?{name:t,...O[e.type],...e}:"value"in e?{name:t,type:D(e.value),...e}:{name:t,type:"object",value:e}}function N(t){return Array.isArray(t)||ArrayBuffer.isView(t)}function D(t){return N(t)?"array":null===t?"null":typeof t}const F="_mergedDefaultProps";function U(t,e){let i=F;if(e)for(const o of e){const t=o.constructor;t&&(i+=":"+(t.extensionName||t.name))}const n=B(t,i);return n||(t[i]=function(t,e){const i=t.prototype;if(!i)return null;const n=Object.getPrototypeOf(t),o=U(n),s=B(t,"defaultProps")||{},r=function(t){const e={},i={},n={};for(const[o,s]of Object.entries(t)){const t=null==s?void 0:s.deprecatedFor;if(t)n[o]=Array.isArray(t)?t:[t];else{const t=z(o,s);e[o]=t,i[o]=t.value}}return{propTypes:e,defaultProps:i,deprecatedProps:n}}(s),a=Object.assign(Object.create(null),o,r.defaultProps),l=Object.assign(Object.create(null),null==o?void 0:o[v.Wb],r.propTypes),c=Object.assign(Object.create(null),null==o?void 0:o[v.E7],r.deprecatedProps);for(const d of e){const t=U(d.constructor);t&&(Object.assign(a,t),Object.assign(l,t[v.Wb]),Object.assign(c,t[v.E7]))}(function(t,e){const i=function(t){const e=B(t,"layerName")||B(t,"componentName");e||h.Z.once(0,t.name+".componentName not specified")();return e||t.name}(e);Object.defineProperties(t,{id:{writable:!0,value:i}})})(a,t),function(t,e){const i={},n={};for(const o in e){const t=e[o],{name:s,value:r}=t;t.async&&(i[s]=r,n[s]=Z(s))}t[v.lY]=i,t[v.fO]={},Object.defineProperties(t,n)}(a,l),function(t,e){for(const i in e)Object.defineProperty(t,i,{enumerable:!1,set(t){const n=this.id+": "+i;for(const o of e[i])V(this,o)||(this[o]=t);h.Z.deprecated(n,e[i].join("/"))()}})}(a,c),a[v.Wb]=l,a[v.E7]=c,0!==e.length||V(t,"_propTypes")||(t._propTypes=l);return a}(t,e||[]))}function Z(t){return{enumerable:!0,set(e){"string"==typeof e||e instanceof Promise||(0,k.D0)(e)?this[v.fO][t]=e:this[v.bN][t]=e},get(){if(this[v.bN]){if(t in this[v.bN]){return this[v.bN][t]||this[v.lY][t]}if(t in this[v.fO]){const e=this[v.fm]&&this[v.fm].internalState;if(e&&e.hasAsyncProp(t))return e.getAsyncProp(t)||this[v.lY][t]}}return this[v.lY][t]}}}function V(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function B(t,e){return V(t,e)&&t[e]}let W=0;class G{constructor(){for(var t=arguments.length,e=new Array(t),i=0;i<t;i++)e[i]=arguments[i];this.props=function(t,e){let i;for(let s=e.length-1;s>=0;s--){const t=e[s];"extensions"in t&&(i=t.extensions)}const n=U(t.constructor,i),o=Object.create(n);o[v.fm]=t,o[v.fO]={},o[v.bN]={};for(let s=0;s<e.length;++s){const t=e[s];for(const e in t)o[e]=t[e]}return Object.freeze(o),o}(this,e),this.id=this.props.id,this.count=W++}clone(t){const{props:e}=this,i={};for(const n in e[v.lY])n in e[v.bN]?i[n]=e[v.bN][n]:n in e[v.fO]&&(i[n]=e[v.fO][n]);return new this.constructor({...e,...i,...t})}}G.componentName="Component",G.defaultProps={};const H=Object.freeze({});class q{constructor(t){this.component=t,this.asyncProps={},this.onAsyncPropUpdated=()=>{},this.oldProps=null,this.oldAsyncProps=null}finalize(){for(const t in this.asyncProps){const e=this.asyncProps[t];e&&e.type&&e.type.release&&e.type.release(e.resolvedValue,e.type,this.component)}this.asyncProps={},this.component=null,this.resetOldProps()}getOldProps(){return this.oldAsyncProps||this.oldProps||H}resetOldProps(){this.oldAsyncProps=null,this.oldProps=this.component?this.component.props:null}hasAsyncProp(t){return t in this.asyncProps}getAsyncProp(t){const e=this.asyncProps[t];return e&&e.resolvedValue}isAsyncPropLoading(t){if(t){const e=this.asyncProps[t];return Boolean(e&&e.pendingLoadCount>0&&e.pendingLoadCount!==e.resolvedLoadCount)}for(const e in this.asyncProps)if(this.isAsyncPropLoading(e))return!0;return!1}reloadAsyncProp(t,e){this._watchPromise(t,Promise.resolve(e))}setAsyncProps(t){this.component=t[v.fm]||this.component;const e=t[v.bN]||{},i=t[v.fO]||t,n=t[v.lY]||{};for(const o in e){const t=e[o];this._createAsyncPropData(o,n[o]),this._updateAsyncProp(o,t),e[o]=this.getAsyncProp(o)}for(const o in i){const t=i[o];this._createAsyncPropData(o,n[o]),this._updateAsyncProp(o,t)}}_fetch(t,e){return null}_onResolve(t,e){}_onError(t,e){}_updateAsyncProp(t,e){this._didAsyncInputValueChange(t,e)&&("string"==typeof e&&(e=this._fetch(t,e)),e instanceof Promise?this._watchPromise(t,e):(0,k.D0)(e)?this._resolveAsyncIterable(t,e):this._setPropValue(t,e))}_freezeAsyncOldProps(){if(!this.oldAsyncProps&&this.oldProps){this.oldAsyncProps=Object.create(this.oldProps);for(const t in this.asyncProps)Object.defineProperty(this.oldAsyncProps,t,{enumerable:!0,value:this.oldProps[t]})}}_didAsyncInputValueChange(t,e){const i=this.asyncProps[t];return e!==i.resolvedValue&&e!==i.lastValue&&(i.lastValue=e,!0)}_setPropValue(t,e){this._freezeAsyncOldProps();const i=this.asyncProps[t];i&&(e=this._postProcessValue(i,e),i.resolvedValue=e,i.pendingLoadCount++,i.resolvedLoadCount=i.pendingLoadCount)}_setAsyncPropValue(t,e,i){const n=this.asyncProps[t];n&&i>=n.resolvedLoadCount&&void 0!==e&&(this._freezeAsyncOldProps(),n.resolvedValue=e,n.resolvedLoadCount=i,this.onAsyncPropUpdated(t,e))}_watchPromise(t,e){const i=this.asyncProps[t];if(i){i.pendingLoadCount++;const n=i.pendingLoadCount;e.then((e=>{this.component&&(e=this._postProcessValue(i,e),this._setAsyncPropValue(t,e,n),this._onResolve(t,e))})).catch((e=>{this._onError(t,e)}))}}async _resolveAsyncIterable(t,e){if("data"!==t)return void this._setPropValue(t,e);const i=this.asyncProps[t];if(!i)return;i.pendingLoadCount++;const n=i.pendingLoadCount;let o=[],s=0;for await(const r of e){if(!this.component)return;const{dataTransform:e}=this.component.props;o=e?e(r,o):o.concat(r),Object.defineProperty(o,"__diff",{enumerable:!1,value:[{startRow:s,endRow:o.length}]}),s=o.length,this._setAsyncPropValue(t,o,n)}this._onResolve(t,o)}_postProcessValue(t,e){const i=t.type;return i&&this.component&&(i.release&&i.release(t.resolvedValue,i,this.component),i.transform)?i.transform(e,i,this.component):e}_createAsyncPropData(t,e){if(!this.asyncProps[t]){const i=this.component&&this.component.props[v.Wb];this.asyncProps[t]={type:i&&i[t],lastValue:null,resolvedValue:e,pendingLoadCount:0,resolvedLoadCount:0}}}}class K extends q{constructor(t){let{attributeManager:e,layer:i}=t;super(i),this.attributeManager=e,this.needsRedraw=!0,this.needsUpdate=!0,this.subLayers=null,this.usesPickingColorCache=!1}get layer(){return this.component}_fetch(t,e){const i=this.layer,n=null==i?void 0:i.props.fetch;return n?n(e,{propName:t,layer:i}):super._fetch(t,e)}_onResolve(t,e){const i=this.layer;if(i){const n=i.props.onDataLoad;"data"===t&&n&&n(e,{propName:t,layer:i})}}_onError(t,e){const i=this.layer;i&&i.raiseError(e,"loading "+t+" of "+this.layer)}}var Y=i(92797),X=i(96742);const J=2**24-1,$=Object.freeze([]),Q=(0,C.Z)((t=>{let{oldViewport:e,viewport:i}=t;return e.equals(i)}));let tt=new Uint8ClampedArray(0);const et={data:{type:"data",value:$,async:!0},dataComparator:{type:"function",value:null,compare:!1,optional:!0},_dataDiff:{type:"function",value:t=>t&&t.__diff,compare:!1,optional:!0},dataTransform:{type:"function",value:null,compare:!1,optional:!0},onDataLoad:{type:"function",value:null,compare:!1,optional:!0},onError:{type:"function",value:null,compare:!1,optional:!0},fetch:{type:"function",value:(t,e)=>{let{propName:i,layer:n,loaders:o,loadOptions:s,signal:r}=e;const{resourceManager:a}=n.context;var l;(s=s||n.getLoadOptions(),o=o||n.props.loaders,r)&&(s={...s,fetch:{...null==(l=s)?void 0:l.fetch,signal:r}});let c=a.contains(t);return c||s||(a.add({resourceId:t,data:(0,X.z)(t,o),persistent:!1}),c=!0),c?a.subscribe({resourceId:t,onChange:t=>{var e;return null==(e=n.internalState)?void 0:e.reloadAsyncProp(i,t)},consumerId:n.id,requestId:i}):(0,X.z)(t,o,s)},compare:!1},updateTriggers:{},visible:!0,pickable:!1,opacity:{type:"number",min:0,max:1,value:1},operation:"draw",onHover:{type:"function",value:null,compare:!1,optional:!0},onClick:{type:"function",value:null,compare:!1,optional:!0},onDragStart:{type:"function",value:null,compare:!1,optional:!0},onDrag:{type:"function",value:null,compare:!1,optional:!0},onDragEnd:{type:"function",value:null,compare:!1,optional:!0},coordinateSystem:n.Df.DEFAULT,coordinateOrigin:{type:"array",value:[0,0,0],compare:!0},modelMatrix:{type:"array",value:null,compare:!0,optional:!0},wrapLongitude:!1,positionFormat:"XYZ",colorFormat:"RGBA",parameters:{type:"object",value:{},optional:!0,compare:!0,depth:1},loadOptions:{type:"object",value:null,optional:!0,compare:!0,depth:3},transitions:null,extensions:[],loaders:{type:"array",value:[],optional:!0,compare:!0},getPolygonOffset:{type:"function",value:t=>{let{layerIndex:e}=t;return[0,100*-e]},compare:!1},highlightedObjectIndex:null,autoHighlight:!1,highlightColor:{type:"accessor",value:[0,0,128,128]}};class it extends G{constructor(){super(...arguments),this.internalState=null,this.lifecycle=v.dt.NO_STATE,this.parent=null}get root(){let t=this;for(;t.parent;)t=t.parent;return t}toString(){return(this.constructor.layerName||this.constructor.name)+"({id: '"+this.props.id+"'})"}project(t){(0,x.Z)(this.internalState);const e=this.internalState.viewport||this.context.viewport,i=(0,L.T)(t,{viewport:e,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem}),[n,o,s]=(0,Y.aW)(i,e.pixelProjectionMatrix);return 2===t.length?[n,o]:[n,o,s]}unproject(t){(0,x.Z)(this.internalState);return(this.internalState.viewport||this.context.viewport).unproject(t)}projectPosition(t,e){(0,x.Z)(this.internalState);const i=this.internalState.viewport||this.context.viewport;return(0,L.D)(t,{viewport:i,modelMatrix:this.props.modelMatrix,coordinateOrigin:this.props.coordinateOrigin,coordinateSystem:this.props.coordinateSystem,...e})}get isComposite(){return!1}setState(t){this.setChangeFlags({stateChanged:!0}),Object.assign(this.state,t),this.setNeedsRedraw()}setNeedsRedraw(){this.internalState&&(this.internalState.needsRedraw=!0)}setNeedsUpdate(){this.internalState&&(this.context.layerManager.setNeedsUpdate(String(this)),this.internalState.needsUpdate=!0)}get isLoaded(){return!!this.internalState&&!this.internalState.isAsyncPropLoading()}get wrapLongitude(){return this.props.wrapLongitude}isPickable(){return this.props.pickable&&this.props.visible}getModels(){return this.state&&(this.state.models||this.state.model&&[this.state.model])||[]}setModuleParameters(t){for(const e of this.getModels())e.updateModuleSettings(t)}getAttributeManager(){return this.internalState&&this.internalState.attributeManager}getCurrentLayer(){return this.internalState&&this.internalState.layer}getLoadOptions(){return this.props.loadOptions}use64bitPositions(){const{coordinateSystem:t}=this.props;return t===n.Df.DEFAULT||t===n.Df.LNGLAT||t===n.Df.CARTESIAN}onHover(t,e){return this.props.onHover&&this.props.onHover(t,e)||!1}onClick(t,e){return this.props.onClick&&this.props.onClick(t,e)||!1}nullPickingColor(){return[0,0,0]}encodePickingColor(t,e){return void 0===e&&(e=[]),e[0]=t+1&255,e[1]=t+1>>8&255,e[2]=t+1>>8>>8&255,e}decodePickingColor(t){(0,x.Z)(t instanceof Uint8Array);const[e,i,n]=t;return e+256*i+65536*n-1}getNumInstances(){return Number.isFinite(this.props.numInstances)?this.props.numInstances:this.state&&void 0!==this.state.numInstances?this.state.numInstances:w(this.props.data)}getStartIndices(){return this.props.startIndices?this.props.startIndices:this.state&&this.state.startIndices?this.state.startIndices:null}getBounds(){var t;const e=this.getAttributeManager();if(!e)return null;const{positions:i,instancePositions:n}=e.attributes;return null==(t=i||n)?void 0:t.getBounds()}getShaders(t){for(const e of this.props.extensions)t=(0,S.l)(t,e.getShaders.call(this,e));return t}shouldUpdateState(t){return t.changeFlags.propsOrDataChanged}updateState(t){const e=this.getAttributeManager(),{dataChanged:i}=t.changeFlags;if(i&&e)if(Array.isArray(i))for(const n of i)e.invalidateAll(n);else e.invalidateAll();if(e){const{props:i}=t,n=this.internalState.hasPickingBuffer,o=Number.isInteger(i.highlightedObjectIndex)||i.pickable||i.extensions.some((t=>t.getNeedsPickingBuffer.call(this,t)));if(n!==o){this.internalState.hasPickingBuffer=o;const{pickingColors:t,instancePickingColors:i}=e.attributes,n=t||i;n&&(o&&n.constant&&(n.constant=!1,e.invalidate(n.id)),n.value||o||(n.constant=!0,n.value=[0,0,0]))}}}finalizeState(t){for(const i of this.getModels())i.delete();const e=this.getAttributeManager();e&&e.finalize(),this.context&&this.context.resourceManager.unsubscribe({consumerId:this.id}),this.internalState&&(this.internalState.uniformTransitions.clear(),this.internalState.finalize())}draw(t){for(const e of this.getModels())e.draw(t)}getPickingInfo(t){let{info:e,mode:i,sourceLayer:n}=t;const{index:o}=e;return o>=0&&Array.isArray(this.props.data)&&(e.object=this.props.data[o]),e}raiseError(t,e){var i,n,o;(e&&(t.message=e+": "+t.message),null!=(i=(n=this.props).onError)&&i.call(n,t))||(null==(o=this.context)||null==o.onError||o.onError(t,this))}getNeedsRedraw(t){return void 0===t&&(t={clearRedrawFlags:!1}),this._getNeedsRedraw(t)}needsUpdate(){return!!this.internalState&&(this.internalState.needsUpdate||this.hasUniformTransition()||this.shouldUpdateState(this._getUpdateParams()))}hasUniformTransition(){var t;return(null==(t=this.internalState)?void 0:t.uniformTransitions.active)||!1}activateViewport(t){if(!this.internalState)return;const e=this.internalState.viewport;this.internalState.viewport=t,e&&Q({oldViewport:e,viewport:t})||(this.setChangeFlags({viewportChanged:!0}),this.isComposite?this.needsUpdate()&&this.setNeedsUpdate():this._update())}invalidateAttribute(t){void 0===t&&(t="all");const e=this.getAttributeManager();e&&("all"===t?e.invalidateAll():e.invalidate(t))}updateAttributes(t){for(const e of this.getModels())this._setModelAttributes(e,t)}_updateAttributes(){const t=this.getAttributeManager();if(!t)return;const e=this.props,i=this.getNumInstances(),n=this.getStartIndices();t.update({data:e.data,numInstances:i,startIndices:n,props:e,transitions:e.transitions,buffers:e.data.attributes,context:this});const o=t.getChangedAttributes({clearChangedFlags:!0});this.updateAttributes(o)}_updateAttributeTransition(){const t=this.getAttributeManager();t&&t.updateTransition()}_updateUniformTransition(){const{uniformTransitions:t}=this.internalState;if(t.active){const e=t.update(),i=Object.create(this.props);for(const t in e)Object.defineProperty(i,t,{value:e[t]});return i}return this.props}calculateInstancePickingColors(t,e){let{numInstances:i}=e;if(t.constant)return;const n=Math.floor(tt.length/3);if(this.internalState.usesPickingColorCache=!0,n<i){i>J&&h.Z.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(),tt=M.Z.allocate(tt,i,{size:3,copy:!0,maxCount:Math.max(i,J)});const t=Math.floor(tt.length/3),e=[];for(let i=n;i<t;i++)this.encodePickingColor(i,e),tt[3*i+0]=e[0],tt[3*i+1]=e[1],tt[3*i+2]=e[2]}t.value=tt.subarray(0,3*i)}_setModelAttributes(t,e){const i=this.getAttributeManager(),n=t.userData.excludeAttributes||{},o=i.getShaderAttributes(e,n);t.setAttributes(o)}disablePickingIndex(t){this._disablePickingIndex(t)}_disablePickingIndex(t){const{pickingColors:e,instancePickingColors:i}=this.getAttributeManager().attributes,n=e||i;if(!n)return;const o=n.getVertexOffset(t),s=n.getVertexOffset(t+1);n.buffer.subData({data:new Uint8Array(s-o),offset:o})}restorePickingColors(){const{pickingColors:t,instancePickingColors:e}=this.getAttributeManager().attributes,i=t||e;i&&(this.internalState.usesPickingColorCache&&i.value.buffer!==tt.buffer&&(i.value=tt.subarray(0,i.value.length)),i.updateSubBuffer({startOffset:0}))}_initialize(){(0,x.Z)(!this.internalState),(0,x.Z)(Number.isFinite(this.props.coordinateSystem)),(0,b.Z)("layer.initialize",this);const t=this._getAttributeManager();t&&t.addInstanced({instancePickingColors:{type:5121,size:3,noAlloc:!0,update:this.calculateInstancePickingColors}}),this.internalState=new K({attributeManager:t,layer:this}),this._clearChangeFlags(),this.state={},Object.defineProperty(this.state,"attributeManager",{get:()=>(h.Z.deprecated("layer.state.attributeManager","layer.getAttributeManager()")(),t)}),this.internalState.uniformTransitions=new f(this.context.timeline),this.internalState.onAsyncPropUpdated=this._onAsyncPropUpdated.bind(this),this.internalState.setAsyncProps(this.props),this.initializeState(this.context);for(const e of this.props.extensions)e.initializeState.call(this,this.context,e);this.setChangeFlags({dataChanged:"init",propsChanged:"init",viewportChanged:!0,extensionsChanged:!0}),this._update()}_transferState(t){(0,b.Z)("layer.matched",this,this===t);const{state:e,internalState:i}=t;this!==t&&(this.internalState=i,this.state=e,this.internalState.setAsyncProps(this.props),this._diffProps(this.props,this.internalState.getOldProps()))}_update(){const t=this.needsUpdate();if((0,b.Z)("layer.update",this,t),!t)return;const e=this.props,i=this.context,n=this.internalState,o=i.viewport,s=this._updateUniformTransition();n.propsInTransition=s,i.viewport=n.viewport||o,this.props=s;try{const t=this._getUpdateParams(),e=this.getModels();if(i.gl)this.updateState(t);else try{this.updateState(t)}catch(r){}for(const i of this.props.extensions)i.updateState.call(this,t,i);const n=this.getModels()[0]!==e[0];this._postUpdate(t,n)}finally{i.viewport=o,this.props=e,this._clearChangeFlags(),n.needsUpdate=!1,n.resetOldProps()}}_finalize(){(0,b.Z)("layer.finalize",this),this.finalizeState(this.context);for(const t of this.props.extensions)t.finalizeState.call(this,this.context,t)}_drawLayer(t){let{moduleParameters:e=null,uniforms:i={},parameters:n={}}=t;this._updateAttributeTransition();const o=this.props,s=this.context;this.props=this.internalState.propsInTransition||o;const r=this.props.opacity;i.opacity=Math.pow(r,1/2.2);try{e&&this.setModuleParameters(e);const{getPolygonOffset:t}=this.props,o=t&&t(i)||[0,0];(0,P.dR)(s.gl,{polygonOffset:o}),(0,P.s8)(s.gl,n,(()=>{const t={moduleParameters:e,uniforms:i,parameters:n,context:s};for(const e of this.props.extensions)e.draw.call(this,t,e);this.draw(t)}))}finally{this.props=o}}getChangeFlags(){var t;return null==(t=this.internalState)?void 0:t.changeFlags}setChangeFlags(t){if(!this.internalState)return;const{changeFlags:e}=this.internalState;for(const n in t)if(t[n]){let i=!1;if("dataChanged"===n){const o=t[n],s=e[n];o&&Array.isArray(s)&&(e.dataChanged=Array.isArray(o)?s.concat(o):o,i=!0)}e[n]||(e[n]=t[n],i=!0),i&&(0,b.Z)("layer.changeFlag",this,n,t)}const i=Boolean(e.dataChanged||e.updateTriggersChanged||e.propsChanged||e.extensionsChanged);e.propsOrDataChanged=i,e.somethingChanged=i||e.viewportChanged||e.stateChanged}_clearChangeFlags(){this.internalState.changeFlags={dataChanged:!1,propsChanged:!1,updateTriggersChanged:!1,viewportChanged:!1,stateChanged:!1,extensionsChanged:!1,propsOrDataChanged:!1,somethingChanged:!1}}_diffProps(t,e){const i=(0,m.Yt)(t,e);if(i.updateTriggersChanged)for(const o in i.updateTriggersChanged)i.updateTriggersChanged[o]&&this.invalidateAttribute(o);if(i.transitionsChanged)for(const o in i.transitionsChanged){var n;this.internalState.uniformTransitions.add(o,e[o],t[o],null==(n=t.transitions)?void 0:n[o])}return this.setChangeFlags(i)}validateProps(){(0,m.eQ)(this.props)}updateAutoHighlight(t){this.props.autoHighlight&&!Number.isInteger(this.props.highlightedObjectIndex)&&this._updateAutoHighlight(t)}_updateAutoHighlight(t){const e={pickingSelectedColor:t.picked?t.color:null},{highlightColor:i}=this.props;t.picked&&"function"==typeof i&&(e.pickingHighlightColor=i(t)),this.setModuleParameters(e),this.setNeedsRedraw()}_getAttributeManager(){const t=this.context;return new o.Z(t.gl,{id:this.props.id,stats:t.stats,timeline:t.timeline})}_postUpdate(t,e){const{props:i,oldProps:n}=t;this.setNeedsRedraw(),this._updateAttributes();const{model:o}=this.state;null==o||o.setInstanceCount(this.getNumInstances());const{autoHighlight:s,highlightedObjectIndex:r,highlightColor:a}=i;if(e||n.autoHighlight!==s||n.highlightedObjectIndex!==r||n.highlightColor!==a){const t={};s||(t.pickingSelectedColor=null),Array.isArray(a)&&(t.pickingHighlightColor=a),(e||r!==n.highlightedObjectIndex)&&(t.pickingSelectedColor=Number.isFinite(r)&&r>=0?this.encodePickingColor(r):null),this.setModuleParameters(t)}}_getUpdateParams(){return{props:this.props,oldProps:this.internalState.getOldProps(),context:this.context,changeFlags:this.internalState.changeFlags}}_getNeedsRedraw(t){if(!this.internalState)return!1;let e=!1;e=e||this.internalState.needsRedraw&&this.id;const i=this.getAttributeManager(),n=!!i&&i.getNeedsRedraw(t);if(e=e||n,e)for(const o of this.props.extensions)o.onNeedsRedraw.call(this,o);return this.internalState.needsRedraw=this.internalState.needsRedraw&&!t.clearRedrawFlags,e}_onAsyncPropUpdated(){this._diffProps(this.props,this.internalState.getOldProps()),this.setNeedsUpdate()}}it.defaultProps=et,it.layerName="Layer"},65663:(t,e,i)=>{"use strict";i.d(e,{E7:()=>r,Wb:()=>s,bN:()=>c,dt:()=>n,fO:()=>l,fm:()=>o,lY:()=>a});const n={NO_STATE:"Awaiting state",MATCHED:"Matched. State transferred from previous layer",INITIALIZED:"Initialized",AWAITING_GC:"Discarded. Awaiting garbage collection",AWAITING_FINALIZATION:"No longer matched. Awaiting garbage collection",FINALIZED:"Finalized! Awaiting garbage collection"},o=Symbol.for("component"),s=Symbol.for("propTypes"),r=Symbol.for("deprecatedProps"),a=Symbol.for("asyncPropDefaults"),l=Symbol.for("asyncPropOriginal"),c=Symbol.for("asyncPropResolved")},65756:(t,e,i)=>{"use strict";i.d(e,{Yt:()=>s,eQ:()=>o,tg:()=>a});var n=i(65663);function o(t){const e=t[n.Wb];for(const i in e){const n=e[i],{validate:o}=n;if(o&&!o(t[i],n))throw new Error("Invalid prop "+i+": "+t[i])}}function s(t,e){const i=a({newProps:t,oldProps:e,propTypes:t[n.Wb],ignoreProps:{data:null,updateTriggers:null,extensions:null,transitions:null}}),o=function(t,e){if(null===e)return"oldProps is null, initial diff";let i=!1;const{dataComparator:n,_dataDiff:o}=t;n?n(t.data,e.data)||(i="Data comparator detected a change"):t.data!==e.data&&(i="A new data container was supplied");i&&o&&(i=o(t.data,e.data)||i);return i}(t,e);let s=!1;return o||(s=function(t,e){if(null===e)return{all:!0};if("all"in t.updateTriggers){if(d(t,e,"all"))return{all:!0}}const i={};let n=!1;for(const o in t.updateTriggers)if("all"!==o){d(t,e,o)&&(i[o]=!0,n=!0)}return!!n&&i}(t,e)),{dataChanged:o,propsChanged:i,updateTriggersChanged:s,extensionsChanged:c(t,e),transitionsChanged:r(t,e)}}function r(t,e){if(!t.transitions)return!1;const i={},o=t[n.Wb];let s=!1;for(const n in t.transitions){const r=o[n],a=r&&r.type;("number"===a||"color"===a||"array"===a)&&l(t[n],e[n],r)&&(i[n]=!0,s=!0)}return!!s&&i}function a(t){let{newProps:e,oldProps:i,ignoreProps:n={},propTypes:o={},triggerName:s="props"}=t;if(i===e)return!1;if("object"!=typeof e||null===e)return s+" changed shallowly";if("object"!=typeof i||null===i)return s+" changed shallowly";for(const r of Object.keys(e))if(!(r in n)){if(!(r in i))return s+"."+r+" added";const t=l(e[r],i[r],o[r]);if(t)return s+"."+r+" "+t}for(const r of Object.keys(i))if(!(r in n)){if(!(r in e))return s+"."+r+" dropped";if(!Object.hasOwnProperty.call(e,r)){const t=l(e[r],i[r],o[r]);if(t)return s+"."+r+" "+t}}return!1}function l(t,e,i){let n=i&&i.equal;return n&&!n(t,e,i)?"changed deeply":n||(n=t&&e&&t.equals,!n||n.call(t,e))?n||e===t?null:"changed shallowly":"changed deeply"}function c(t,e){if(null===e)return!0;const i=e.extensions,{extensions:n}=t;if(n===i)return!1;if(!i||!n)return!0;if(n.length!==i.length)return!0;for(let o=0;o<n.length;o++)if(!n[o].equals(i[o]))return!0;return!1}function d(t,e,i){let n=t.updateTriggers[i];n=null==n?{}:n;let o=e.updateTriggers[i];o=null==o?{}:o;return a({oldProps:o,newProps:n,triggerName:i})}},5259:(t,e,i)=>{"use strict";i.d(e,{Z:()=>r});class n{constructor(t,e){void 0===e&&(e={id:"pass"});const{id:i}=e;this.id=i,this.gl=t,this.props={...e}}setProps(t){Object.assign(this.props,t)}render(t){}cleanup(){}}var o=i(7092),s=i(97581);class r extends n{constructor(){super(...arguments),this._lastRenderIndex=-1}render(t){const e=this.gl;return(0,o.dR)(e,{framebuffer:t.target}),this._drawLayers(t)}_drawLayers(t){const{target:e,moduleParameters:i,viewports:n,views:s,onViewportActive:r,clearStack:a=!0,clearCanvas:l=!0}=t;t.pass=t.pass||"unknown";const c=this.gl;l&&function(t,e){const i=e?e.width:t.drawingBufferWidth,n=e?e.height:t.drawingBufferHeight;(0,o.dR)(t,{viewport:[0,0,i,n]}),t.clear(16640)}(c,e),a&&(this._lastRenderIndex=-1);const d=[];for(const o of n){const n=s&&s[o.id];null==r||r(o);const a=this._getDrawLayerParams(o,t),l=o.subViewports||[o];for(const o of l){const s=this._drawLayersInViewport(c,{target:e,moduleParameters:i,viewport:o,view:n,pass:t.pass,layers:t.layers},a);d.push(s)}}return d}_getDrawLayerParams(t,e,i){let{layers:n,pass:o,isPicking:s=!1,layerFilter:r,cullRect:l,effects:c,moduleParameters:d}=e;void 0===i&&(i=!1);const u=[],p=a(this._lastRenderIndex+1),h={layer:n[0],viewport:t,isPicking:s,renderPass:o,cullRect:l},g={};for(let a=0;a<n.length;a++){const e=n[a],s=this._shouldDrawLayer(e,h,r,g),l={shouldDrawLayer:s};s&&!i&&(l.layerRenderIndex=p(e,s),l.moduleParameters=this._getModuleParameters(e,c,o,d),l.layerParameters=this.getLayerParameters(e,a,t)),u[a]=l}return u}_drawLayersInViewport(t,e,i){let{layers:n,moduleParameters:r,pass:a,target:l,viewport:c,view:d}=e;const u=function(t,e){let{moduleParameters:i,target:n,viewport:s}=e;const r=n&&"default-framebuffer"!==n.id,a=i&&i.devicePixelRatio||(0,o.w)(t),l=r?n.height:t.drawingBufferHeight,c=s;return[c.x*a,l-(c.y+c.height)*a,c.width*a,c.height*a]}(t,{moduleParameters:r,target:l,viewport:c});if(d&&d.props.clear){const e=!0===d.props.clear?{color:!0,depth:!0}:d.props.clear;(0,o.s8)(t,{scissorTest:!0,scissor:u},(()=>(0,s.Z)(t,e)))}const p={totalCount:n.length,visibleCount:0,compositeCount:0,pickableCount:0};(0,o.dR)(t,{viewport:u});for(let o=0;o<n.length;o++){const t=n[o],{shouldDrawLayer:e,layerRenderIndex:s,moduleParameters:r,layerParameters:l}=i[o];if(e&&t.props.pickable&&p.pickableCount++,t.isComposite)p.compositeCount++;else if(e){p.visibleCount++,this._lastRenderIndex=Math.max(this._lastRenderIndex,s),r.viewport=c;try{t._drawLayer({moduleParameters:r,uniforms:{layerIndex:s},parameters:l})}catch(h){t.raiseError(h,"drawing "+t+" to "+a)}}}return p}shouldDrawLayer(t){return!0}getModuleParameters(t,e){return null}getLayerParameters(t,e,i){return t.props.parameters}_shouldDrawLayer(t,e,i,n){if(!(t.props.visible&&this.shouldDrawLayer(t)))return!1;e.layer=t;let o=t.parent;for(;o;){if(!o.props.visible||!o.filterSubLayer(e))return!1;e.layer=o,o=o.parent}if(i){const t=e.layer.id;if(t in n||(n[t]=i(e)),!n[t])return!1}return t.activateViewport(e.viewport),!0}_getModuleParameters(t,e,i,n){var s;const r=Object.assign(Object.create((null==(s=t.internalState)?void 0:s.propsInTransition)||t.props),{autoWrapLongitude:t.wrapLongitude,viewport:t.context.viewport,mousePosition:t.context.mousePosition,pickingActive:0,devicePixelRatio:(0,o.w)(this.gl)});if(e)for(const o of e)Object.assign(r,null==o.getModuleParameters?void 0:o.getModuleParameters(t));return Object.assign(r,this.getModuleParameters(t,e),n)}}function a(t,e){void 0===t&&(t=0),void 0===e&&(e={});const i={},n=(o,s)=>{const r=o.props._offset,l=o.id,c=o.parent&&o.parent.id;let d;if(c&&!(c in e)&&n(o.parent,!1),c in i){const t=i[c]=i[c]||a(e[c],e);d=t(o,s),i[l]=t}else Number.isFinite(r)?(d=r+(e[c]||0),i[l]=null):d=t;return s&&d>=t&&(t=d+1),e[l]=d,d};return n}},71693:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});const n={inject:{"vs:DECKGL_FILTER_GL_POSITION":"\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ","vs:DECKGL_FILTER_COLOR":"\n  picking_setPickingColor(geometry.pickingColor);\n  ","fs:DECKGL_FILTER_COLOR":{order:99,injection:"\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "}},...i(98254).q}},50961:(t,e,i)=>{"use strict";i.d(e,{D:()=>p,T:()=>u});var n=i(43631),o=i(66084),s=i(11199),r=i(98333),a=i(77160),l=i(92797);const c=[0,0,0];function d(t,e,i){void 0===i&&(i=!1);const n=e.projectPosition(t);if(i&&e instanceof s.Z){const[i,o,s=0]=t,r=e.getDistanceScales([i,o]);n[2]=s*r.unitsPerMeter[2]}return n}function u(t,e){let{viewport:i,modelMatrix:o,coordinateSystem:s,coordinateOrigin:a,offsetMode:c}=e,[u,p,h=0]=t;switch(o&&([u,p,h]=r.fF([],[u,p,h,1],o)),s){case n.Df.LNGLAT:return d([u,p,h],i,c);case n.Df.LNGLAT_OFFSETS:return d([u+a[0],p+a[1],h+(a[2]||0)],i,c);case n.Df.METER_OFFSETS:return d((0,l.eG)(a,[u,p,h]),i,c);case n.Df.CARTESIAN:default:return i.isGeospatial?[u+a[0],p+a[1],h+a[2]]:i.projectPosition([u,p,h])}}function p(t,e){const{viewport:i,coordinateSystem:s,coordinateOrigin:r,modelMatrix:l,fromCoordinateSystem:d,fromCoordinateOrigin:p}=function(t){const{viewport:e,modelMatrix:i,coordinateOrigin:o}=t;let{coordinateSystem:s,fromCoordinateSystem:r,fromCoordinateOrigin:a}=t;return s===n.Df.DEFAULT&&(s=e.isGeospatial?n.Df.LNGLAT:n.Df.CARTESIAN),void 0===r&&(r=s),void 0===a&&(a=o),{viewport:e,coordinateSystem:s,coordinateOrigin:o,modelMatrix:i,fromCoordinateSystem:r,fromCoordinateOrigin:a}}(e),{autoOffset:h=!0}=e,{geospatialOrigin:g=c,shaderCoordinateOrigin:f=c,offsetMode:m=!1}=h?(0,o.v)(i,s,r):{},v=u(t,{viewport:i,modelMatrix:l,coordinateSystem:d,coordinateOrigin:p,offsetMode:m});if(m){const t=i.projectPosition(g||f);a.lu(v,v,t)}return v}},73782:(t,e,i)=>{"use strict";i.d(e,{Z:()=>d});var n=i(97678);const o="#define SMOOTH_EDGE_RADIUS 0.5",s={name:"geometry",vs:"\n"+o+"\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n",fs:"\n"+o+"\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n"};var r=i(43631);const a=Object.keys(r.Df).map((t=>"const int COORDINATE_SYSTEM_"+t+" = "+r.Df[t]+";")).join("")+"\n"+Object.keys(r.zG).map((t=>"const int PROJECTION_MODE_"+t+" = "+r.zG[t]+";")).join("")+"\n"+Object.keys(r.iI).map((t=>"const int UNIT_"+t.toUpperCase()+" = "+r.iI[t]+";")).join("")+"\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n";var l=i(66084);const c={};const d={name:"project",dependencies:[n.O,s],vs:a,getUniforms:function(t){return void 0===t&&(t=c),"viewport"in t?(0,l.C)(t):{}}}},66084:(t,e,i)=>{"use strict";i.d(e,{C:()=>g,v:()=>h});var n=i(85975),o=i(98333),s=i(43631),r=i(66508);const a=[0,0,0,0],l=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0],c=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],d=[0,0,0],u=[0,0,0],p=(0,r.Z)((function(t){let{viewport:e,devicePixelRatio:i,coordinateSystem:r,coordinateOrigin:u}=t;const{projectionCenter:p,viewProjectionMatrix:g,originCommon:f,cameraPosCommon:m,shaderCoordinateOrigin:v,geospatialOrigin:y}=function(t,e,i){const{viewMatrixUncentered:s,projectionMatrix:r}=t;let{viewMatrix:c,viewProjectionMatrix:d}=t,u=a,p=a,g=t.cameraPosition;const{geospatialOrigin:f,shaderCoordinateOrigin:m,offsetMode:v}=h(t,e,i);v&&(p=t.projectPosition(f||m),g=[g[0]-p[0],g[1]-p[1],g[2]-p[2]],p[3]=1,u=o.fF([],p,d),c=s||c,d=n.Jp([],r,c),d=n.Jp([],d,l));return{viewMatrix:c,viewProjectionMatrix:d,projectionCenter:u,originCommon:p,cameraPosCommon:g,shaderCoordinateOrigin:m,geospatialOrigin:f}}(e,r,u),_=e.getDistanceScales(),w=[e.width*i,e.height*i],b=o.fF([],[0,0,-e.focalDistance,1],e.projectionMatrix)[3]||1,P={project_uCoordinateSystem:r,project_uProjectionMode:e.projectionMode,project_uCoordinateOrigin:v,project_uCommonOrigin:f.slice(0,3),project_uCenter:p,project_uPseudoMeters:Boolean(e._pseudoMeters),project_uViewportSize:w,project_uDevicePixelRatio:i,project_uFocalDistance:b,project_uCommonUnitsPerMeter:_.unitsPerMeter,project_uCommonUnitsPerWorldUnit:_.unitsPerMeter,project_uCommonUnitsPerWorldUnit2:d,project_uScale:e.scale,project_uWrapLongitude:!1,project_uViewProjectionMatrix:g,project_uModelMatrix:c,project_uCameraPosition:m};if(y){const t=e.getDistanceScales(y);switch(r){case s.Df.METER_OFFSETS:P.project_uCommonUnitsPerWorldUnit=t.unitsPerMeter,P.project_uCommonUnitsPerWorldUnit2=t.unitsPerMeter2;break;case s.Df.LNGLAT:case s.Df.LNGLAT_OFFSETS:e._pseudoMeters||(P.project_uCommonUnitsPerMeter=t.unitsPerMeter),P.project_uCommonUnitsPerWorldUnit=t.unitsPerDegree,P.project_uCommonUnitsPerWorldUnit2=t.unitsPerDegree2;break;case s.Df.CARTESIAN:P.project_uCommonUnitsPerWorldUnit=[1,1,t.unitsPerMeter[2]],P.project_uCommonUnitsPerWorldUnit2=[0,0,t.unitsPerMeter2[2]]}}return P}));function h(t,e,i){void 0===i&&(i=u),i.length<3&&(i=[i[0],i[1],0]);let n,o=i,r=!0;switch(n=e===s.Df.LNGLAT_OFFSETS||e===s.Df.METER_OFFSETS?i:t.isGeospatial?[Math.fround(t.longitude),Math.fround(t.latitude),0]:null,t.projectionMode){case s.zG.WEB_MERCATOR:e!==s.Df.LNGLAT&&e!==s.Df.CARTESIAN||(n=[0,0,0],r=!1);break;case s.zG.WEB_MERCATOR_AUTO_OFFSET:e===s.Df.LNGLAT?o=n:e===s.Df.CARTESIAN&&(o=[Math.fround(t.center[0]),Math.fround(t.center[1]),0],n=t.unprojectPosition(o),o[0]-=i[0],o[1]-=i[1],o[2]-=i[2]);break;case s.zG.IDENTITY:o=t.position.map(Math.fround),o[2]=o[2]||0;break;case s.zG.GLOBE:r=!1,n=null;break;default:r=!1}return{geospatialOrigin:n,shaderCoordinateOrigin:o,offsetMode:r}}function g(t){let{viewport:e,devicePixelRatio:i=1,modelMatrix:n=null,coordinateSystem:o=s.Df.DEFAULT,coordinateOrigin:r=u,autoWrapLongitude:a=!1}=t;o===s.Df.DEFAULT&&(o=e.isGeospatial?s.Df.LNGLAT:s.Df.CARTESIAN);const l=p({viewport:e,devicePixelRatio:i,coordinateSystem:o,coordinateOrigin:r});return l.project_uWrapLongitude=a,l.project_uModelMatrix=n||c,l}},18056:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});const n={name:"project32",dependencies:[i(73782).Z],vs:"\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n"}},60499:(t,e,i)=>{"use strict";i.d(e,{Z:()=>a});var n=i(4153),o=i(28835);const s=["longitude","latitude","zoom","bearing","pitch"],r=["longitude","latitude","zoom"];class a extends n.Z{constructor(t){void 0===t&&(t={});const e=Array.isArray(t)?t:t.transitionProps,i=Array.isArray(t)?{}:t;i.transitionProps=Array.isArray(e)?{compare:e,required:e}:e||{compare:s,required:r},super(i.transitionProps),this.opts=i}initializeProps(t,e){const i=super.initializeProps(t,e),{makeViewport:n,around:o}=this.opts;if(n&&o){const s=n(t),r=n(e),a=s.unproject(o);i.start.around=o,Object.assign(i.end,{around:r.project(a),aroundPosition:a,width:e.width,height:e.height})}return i}interpolateProps(t,e,i){const n={};for(const s of this._propsToExtract)n[s]=(0,o.t7)(t[s]||0,e[s]||0,i);if(e.aroundPosition&&this.opts.makeViewport){const s=this.opts.makeViewport({...e,...n});Object.assign(n,s.panByPosition(e.aroundPosition,(0,o.t7)(t.around,e.around,i)))}return n}}},4153:(t,e,i)=>{"use strict";i.d(e,{Z:()=>s});var n=i(28835),o=i(13405);class s{constructor(t){const{compare:e,extract:i,required:n}=t;this._propsToCompare=e,this._propsToExtract=i||e,this._requiredProps=n}arePropsEqual(t,e){for(const i of this._propsToCompare)if(!(i in t)||!(i in e)||!(0,n.fS)(t[i],e[i]))return!1;return!0}initializeProps(t,e){const i={},n={};for(const o of this._propsToExtract)(o in t||o in e)&&(i[o]=t[o],n[o]=e[o]);return this._checkRequiredProps(i),this._checkRequiredProps(n),{start:i,end:n}}getDuration(t,e){return e.transitionDuration}_checkRequiredProps(t){this._requiredProps&&this._requiredProps.forEach((e=>{const i=t[e];(0,o.Z)(Number.isFinite(i)||Array.isArray(i),e+" is required for transition")}))}}},62833:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});class n{constructor(t){this._inProgress=!1,this._handle=null,this._timeline=t,this.time=0,this.settings={duration:0}}get inProgress(){return this._inProgress}start(t){var e,i;this.cancel(),this.settings=t,this._inProgress=!0,null==(e=(i=this.settings).onStart)||e.call(i,this)}end(){var t,e;this._inProgress&&(this._timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1,null==(t=(e=this.settings).onEnd)||t.call(e,this))}cancel(){var t,e;this._inProgress&&(null==(t=(e=this.settings).onInterrupt)||t.call(e,this),this._timeline.removeChannel(this._handle),this._handle=null,this._inProgress=!1)}update(){var t,e;if(!this._inProgress)return!1;if(null===this._handle){const{_timeline:t,settings:e}=this;this._handle=t.addChannel({delay:t.getTime(),duration:e.duration})}return this.time=this._timeline.getTime(this._handle),this._onUpdate(),null==(t=(e=this.settings).onUpdate)||t.call(e,this),this._timeline.isFinished(this._handle)&&this.end(),!0}_onUpdate(){}}},13405:(t,e,i)=>{"use strict";function n(t,e){if(!t)throw new Error(e||"deck.gl: assertion failed.")}i.d(e,{Z:()=>n})},77607:(t,e,i)=>{"use strict";function n(t,e,i){if(t===e)return!0;if(!t||!e||Array.isArray(t)!==Array.isArray(e)||"object"!=typeof t||"object"!=typeof e)return!1;if(Array.isArray(e)){if(e.length!==t.length)return!1}else for(const n in e)if(!(n in t))return!1;for(const o in t)if(i){if(t[o]!==e[o]&&!n(t[o],e[o],i-1))return!1}else if(t[o]!==e[o])return!1;return!0}i.d(e,{v:()=>n})},32332:(t,e,i)=>{"use strict";function n(t,e){return void 0===e&&(e=()=>!0),Array.isArray(t)?o(t,e,[]):e(t)?[t]:[]}function o(t,e,i){let n=-1;for(;++n<t.length;){const s=t[n];Array.isArray(s)?o(s,e,i):e(s)&&i.push(s)}return i}function s(t){let{target:e,source:i,start:n=0,count:o=1}=t;const s=i.length,r=o*s;let a=0;for(let l=n;a<s;a++)e[l++]=i[a];for(;a<r;)a<r-a?(e.copyWithin(n+a,n,n+a),a*=2):(e.copyWithin(n+a,n,n+r-a),a=r);return e}i.d(e,{k:()=>s,x:()=>n})},37944:(t,e,i)=>{"use strict";i.d(e,{D0:()=>r,jB:()=>s,jr:()=>a});const n=[],o=[];function s(t,e,i){void 0===e&&(e=0),void 0===i&&(i=1/0);let s=n;const r={index:-1,data:t,target:[]};return t?"function"==typeof t[Symbol.iterator]?s=t:t.length>0&&(o.length=t.length,s=o):s=n,(e>0||Number.isFinite(i))&&(s=(Array.isArray(s)?s:Array.from(s)).slice(e,i),r.index=e-1),{iterable:s,objectInfo:r}}function r(t){return t&&t[Symbol.asyncIterator]}function a(t,e){const{size:i,stride:n,offset:o,startIndices:s,nested:r}=e,a=t.BYTES_PER_ELEMENT,l=n?n/a:i,c=o?o/a:0,d=Math.floor((t.length-c)/l);return(e,n)=>{let{index:o,target:a}=n;if(!s){const e=o*l+c;for(let n=0;n<i;n++)a[n]=t[e+n];return a}const u=s[o],p=s[o+1]||d;let h;if(r){h=new Array(p-u);for(let e=u;e<p;e++){const n=e*l+c;a=new Array(i);for(let e=0;e<i;e++)a[e]=t[n+e];h[e-u]=a}}else if(l===i)h=t.subarray(u*i+c,p*i+c);else{h=new t.constructor((p-u)*i);let e=0;for(let n=u;n<p;n++){const o=n*l+c;for(let n=0;n<i;n++)h[e++]=t[o+n]}}return h}}},89745:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});const n=new(i(91916).Z)({id:"deck"})},4563:(t,e,i)=>{"use strict";i.d(e,{Du:()=>l,Ks:()=>u,TK:()=>h,Xt:()=>a,bS:()=>s,wQ:()=>r});var n=i(67258),o=i(59122);function s(){return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}function r(t,e){const i=t%e;return i<0?e+i:i}function a(t){return[t[12],t[13],t[14]]}function l(t){return{left:d(t[3]+t[0],t[7]+t[4],t[11]+t[8],t[15]+t[12]),right:d(t[3]-t[0],t[7]-t[4],t[11]-t[8],t[15]-t[12]),bottom:d(t[3]+t[1],t[7]+t[5],t[11]+t[9],t[15]+t[13]),top:d(t[3]-t[1],t[7]-t[5],t[11]-t[9],t[15]-t[13]),near:d(t[3]+t[2],t[7]+t[6],t[11]+t[10],t[15]+t[14]),far:d(t[3]-t[2],t[7]-t[6],t[11]-t[10],t[15]-t[14])}}const c=new o.Z;function d(t,e,i,n){c.set(t,e,i);const s=c.len();return{distance:n/s,normal:new o.Z(-t/s,-e/s,-i/s)}}function u(t){return t-Math.fround(t)}let p;function h(t,e){const{size:i=1,startIndex:o=0}=e,s=void 0!==e.endIndex?e.endIndex:t.length,r=(s-o)/i;p=n.Z.allocate(p,r,{type:Float32Array,size:2*i});let a=o,l=0;for(;a<s;){for(let e=0;e<i;e++){const n=t[a++];p[l+e]=n,p[l+e+i]=u(n)}l+=2*i}return p.subarray(0,r*i*2)}},66508:(t,e,i)=>{"use strict";function n(t,e){if(t===e)return!0;if(Array.isArray(t)){const i=t.length;if(!e||e.length!==i)return!1;for(let n=0;n<i;n++)if(t[n]!==e[n])return!1;return!0}return!1}function o(t){let e,i={};return o=>{for(const s in o)if(!n(o[s],i[s])){e=t(o),i=o;break}return e}}i.d(e,{Z:()=>o})},16862:(t,e,i)=>{"use strict";function n(t,e){if(!e)return t;const i={...t,...e};if("defines"in e&&(i.defines={...t.defines,...e.defines}),"modules"in e&&(i.modules=(t.modules||[]).concat(e.modules),e.modules.some((t=>"project64"===t.name)))){const t=i.modules.findIndex((t=>"project32"===t.name));t>=0&&i.modules.splice(t,1)}if("inject"in e)if(t.inject){const n={...t.inject};for(const t in e.inject)n[t]=(n[t]||"")+e.inject[t];i.inject=n}else i.inject=e.inject;return i}i.d(e,{l:()=>n})},68318:(t,e,i)=>{"use strict";i.d(e,{Z:()=>a});var n=i(37944),o=i(67258),s=i(13405),r=i(80241);class a{constructor(t){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:e={}}=t;this.typedArrayManager=o.Z,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:i={},getGeometry:n,geometryBuffer:o,positionFormat:r,dataChanged:a,normalize:l=!0}=this.opts;if(this.data=e,this.getGeometry=n,this.positionSize=o&&o.size||("XY"===r?2:3),this.buffers=i,this.normalize=l,o&&((0,s.Z)(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),l||(i.positions=o)),this.geometryBuffer=i.positions,Array.isArray(a))for(const s of a)this._rebuildGeometry(s);else this._rebuildGeometry()}updatePartialGeometry(t){let{startRow:e,endRow:i}=t;this._rebuildGeometry({startRow:e,endRow:i})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?(0,n.jr)(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:i,buffers:n,_attributeDefs:o,typedArrayManager:s}=this;for(const r in o)if(r in n)s.release(i[r]),i[r]=null;else{const n=o[r];n.copy=e,i[r]=s.allocate(i[r],t,n)}}_forEachGeometry(t,e,i){const{data:o,getGeometry:s}=this,{iterable:r,objectInfo:a}=(0,n.jB)(o,e,i);for(const n of r){a.index++;t(s?s(n,a):null,a.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:i,instanceCount:n}=this;const{data:o,geometryBuffer:s}=this,{startRow:a=0,endRow:l=1/0}=t||{},c={};if(t||(e=[0],i=[0]),this.normalize||!s)this._forEachGeometry(((t,e)=>{const n=t&&this.normalizeGeometry(t);c[e]=n,i[e+1]=i[e]+(n?this.getGeometrySize(n):0)}),a,l),n=i[i.length-1];else if(i=o.startIndices,n=i[o.length]||0,ArrayBuffer.isView(s))n=n||s.length/this.positionSize;else if(s instanceof r.Z){const t=s.accessor.stride||4*this.positionSize;n=n||s.byteLength/t}else if(s.buffer){const t=s.stride||4*this.positionSize;n=n||s.buffer.byteLength/t}else if(s.value){const t=s.value,e=s.stride/t.BYTES_PER_ELEMENT||this.positionSize;n=n||t.length/e}this._allocate(n,Boolean(t)),this.indexStarts=e,this.vertexStarts=i,this.instanceCount=n;const d={};this._forEachGeometry(((t,o)=>{const s=c[o]||t;d.vertexStart=i[o],d.indexStart=e[o];const r=o<i.length-1?i[o+1]:n;d.geometrySize=r-i[o],d.geometryIndex=o,this.updateGeometryAttributes(s,d)}),a,l),this.vertexCount=e[e.length-1]}}},67258:(t,e,i)=>{"use strict";i.d(e,{Z:()=>n});const n=new class{constructor(t){void 0===t&&(t={}),this._pool=[],this.opts={overAlloc:2,poolSize:100},this.setOptions(t)}setOptions(t){Object.assign(this.opts,t)}allocate(t,e,i){let{size:n=1,type:o,padding:s=0,copy:r=!1,initialize:a=!1,maxCount:l}=i;const c=o||t&&t.constructor||Float32Array,d=e*n+s;if(ArrayBuffer.isView(t)){if(d<=t.length)return t;if(d*t.BYTES_PER_ELEMENT<=t.buffer.byteLength)return new c(t.buffer,0,d)}let u=1/0;l&&(u=l*n+s);const p=this._allocate(c,d,a,u);return t&&r?p.set(t):a||p.fill(0,0,4),this._release(t),p}release(t){this._release(t)}_allocate(t,e,i,n){let o=Math.max(Math.ceil(e*this.opts.overAlloc),1);o>n&&(o=n);const s=this._pool,r=t.BYTES_PER_ELEMENT*o,a=s.findIndex((t=>t.byteLength>=r));if(a>=0){const e=new t(s.splice(a,1)[0],0,o);return i&&e.fill(0),e}return new t(o)}_release(t){if(!ArrayBuffer.isView(t))return;const e=this._pool,{buffer:i}=t,{byteLength:n}=i,o=e.findIndex((t=>t.byteLength>=n));o<0?e.push(i):(o>0||e.length<this.opts.poolSize)&&e.splice(o,0,i),e.length>this.opts.poolSize&&e.shift()}}},48332:(t,e,i)=>{"use strict";i.d(e,{Z:()=>f});var n=i(89745),o=i(4563),s=i(76450),r=i(28835),a=i(59122),l=i(85975),c=i(92797),d=i(43631);const u=Math.PI/180,p=(0,o.bS)(),h=[0,0,0],g={unitsPerMeter:[1,1,1],metersPerUnit:[1,1,1]};class f{constructor(t){void 0===t&&(t={}),this._frustumPlanes={},this.id=t.id||this.constructor.displayName||"viewport",this.x=t.x||0,this.y=t.y||0,this.width=t.width||1,this.height=t.height||1,this.zoom=t.zoom||0,this.padding=t.padding,this.distanceScales=t.distanceScales||g,this.focalDistance=t.focalDistance||1,this.position=t.position||h,this.modelMatrix=t.modelMatrix||null;const{longitude:e,latitude:i}=t;this.isGeospatial=Number.isFinite(i)&&Number.isFinite(e),this._initProps(t),this._initMatrices(t),this.equals=this.equals.bind(this),this.project=this.project.bind(this),this.unproject=this.unproject.bind(this),this.projectPosition=this.projectPosition.bind(this),this.unprojectPosition=this.unprojectPosition.bind(this),this.projectFlat=this.projectFlat.bind(this),this.unprojectFlat=this.unprojectFlat.bind(this)}get subViewports(){return null}get metersPerPixel(){return this.distanceScales.metersPerUnit[2]/this.scale}get projectionMode(){return this.isGeospatial?this.zoom<12?d.zG.WEB_MERCATOR:d.zG.WEB_MERCATOR_AUTO_OFFSET:d.zG.IDENTITY}equals(t){return t instanceof f&&(this===t||t.width===this.width&&t.height===this.height&&t.scale===this.scale&&(0,r.fS)(t.projectionMatrix,this.projectionMatrix)&&(0,r.fS)(t.viewMatrix,this.viewMatrix))}project(t,e){let{topLeft:i=!0}=void 0===e?{}:e;const n=this.projectPosition(t),o=(0,c.aW)(n,this.pixelProjectionMatrix),[s,r]=o,a=i?r:this.height-r;return 2===t.length?[s,a]:[s,a,o[2]]}unproject(t,e){let{topLeft:i=!0,targetZ:n}=void 0===e?{}:e;const[o,s,r]=t,a=i?s:this.height-s,l=n&&n*this.distanceScales.unitsPerMeter[2],d=(0,c.CT)([o,a,r],this.pixelUnprojectionMatrix,l),[u,p,h]=this.unprojectPosition(d);return Number.isFinite(r)?[u,p,h]:Number.isFinite(n)?[u,p,n]:[u,p]}projectPosition(t){const[e,i]=this.projectFlat(t);return[e,i,(t[2]||0)*this.distanceScales.unitsPerMeter[2]]}unprojectPosition(t){const[e,i]=this.unprojectFlat(t);return[e,i,(t[2]||0)*this.distanceScales.metersPerUnit[2]]}projectFlat(t){if(this.isGeospatial){const e=(0,c.w5)(t);return e[1]=(0,r.uZ)(e[1],-318,830),e}return t}unprojectFlat(t){return this.isGeospatial?(0,c.es)(t):t}getBounds(t){void 0===t&&(t={});const e={targetZ:t.z||0},i=this.unproject([0,0],e),n=this.unproject([this.width,0],e),o=this.unproject([0,this.height],e),s=this.unproject([this.width,this.height],e);return[Math.min(i[0],n[0],o[0],s[0]),Math.min(i[1],n[1],o[1],s[1]),Math.max(i[0],n[0],o[0],s[0]),Math.max(i[1],n[1],o[1],s[1])]}getDistanceScales(t){return t?(0,c.ro)({longitude:t[0],latitude:t[1],highPrecision:!0}):this.distanceScales}containsPixel(t){let{x:e,y:i,width:n=1,height:o=1}=t;return e<this.x+this.width&&this.x<e+n&&i<this.y+this.height&&this.y<i+o}getFrustumPlanes(){return this._frustumPlanes.near||Object.assign(this._frustumPlanes,(0,o.Du)(this.viewProjectionMatrix)),this._frustumPlanes}panByPosition(t,e){return null}_initProps(t){const e=t.longitude,i=t.latitude;this.isGeospatial&&(Number.isFinite(t.zoom)||(this.zoom=(0,c.Bf)({latitude:i})+Math.log2(this.focalDistance)),this.distanceScales=t.distanceScales||(0,c.ro)({latitude:i,longitude:e}));const n=Math.pow(2,this.zoom);this.scale=n;const{position:o,modelMatrix:r}=t;let l=h;if(o&&(l=r?new s.Z(r).transformAsVector(o,[]):o),this.isGeospatial){const t=this.projectPosition([e,i,0]);this.center=new a.Z(l).scale(this.distanceScales.unitsPerMeter).add(t)}else this.center=this.projectPosition(l)}_initMatrices(t){const{viewMatrix:e=p,projectionMatrix:i=null,orthographic:c=!1,fovyRadians:d,fovy:h=75,near:g=.1,far:f=1e3,padding:m=null,focalDistance:v=1}=t;this.viewMatrixUncentered=e,this.viewMatrix=(new s.Z).multiplyRight(e).translate(new a.Z(this.center).negate()),this.projectionMatrix=i||function(t){let{width:e,height:i,orthographic:n,fovyRadians:o,focalDistance:a,padding:l,near:c,far:d}=t;const u=e/i,p=n?(new s.Z).orthographic({fovy:o,aspect:u,focalDistance:a,near:c,far:d}):(new s.Z).perspective({fovy:o,aspect:u,near:c,far:d});if(l){const{left:t=0,right:n=0,top:o=0,bottom:s=0}=l,a=(0,r.uZ)((t+e-n)/2,0,e)-e/2,c=(0,r.uZ)((o+i-s)/2,0,i)-i/2;p[8]-=2*a/e,p[9]+=2*c/i}return p}({width:this.width,height:this.height,orthographic:c,fovyRadians:d||h*u,focalDistance:v,padding:m,near:g,far:f});const y=(0,o.bS)();l.Jp(y,y,this.projectionMatrix),l.Jp(y,y,this.viewMatrix),this.viewProjectionMatrix=y,this.viewMatrixInverse=l.U_([],this.viewMatrix)||this.viewMatrix,this.cameraPosition=(0,o.Xt)(this.viewMatrixInverse);const _=(0,o.bS)(),w=(0,o.bS)();l.bA(_,_,[this.width/2,-this.height/2,1]),l.Iu(_,_,[1,-1,0]),l.Jp(w,_,this.viewProjectionMatrix),this.pixelProjectionMatrix=w,this.pixelUnprojectionMatrix=l.U_((0,o.bS)(),this.pixelProjectionMatrix),this.pixelUnprojectionMatrix||n.Z.warn("Pixel project matrix not invertible")()}}f.displayName="Viewport"},11199:(t,e,i)=>{"use strict";i.d(e,{Z:()=>l});var n=i(48332),o=i(92797),s=i(31437),r=i(28835),a=i(76450);class l extends n.Z{constructor(t){void 0===t&&(t={});const{latitude:e=0,longitude:i=0,zoom:n=0,pitch:s=0,bearing:l=0,nearZMultiplier:c=.1,farZMultiplier:d=1.01,orthographic:u=!1,projectionMatrix:p,repeat:h=!1,worldOffset:g=0,position:f,padding:m,legacyMeterSizes:v=!1}=t;let{width:y,height:_,altitude:w=1.5}=t;const b=Math.pow(2,n);let P;y=y||1,_=_||1;let x=null;if(p)w=p[5]/2,P=(0,o.Lu)(w);else{let i;if(t.fovy?(P=t.fovy,w=(0,o.sj)(P)):P=(0,o.Lu)(w),m){const{top:t=0,bottom:e=0}=m;i=[0,(0,r.uZ)((t+_-e)/2,0,_)-_/2]}x=(0,o.wl)({width:y,height:_,scale:b,center:f&&[0,0,f[2]*(0,o.NC)(e)],offset:i,pitch:s,fovy:P,nearZMultiplier:c,farZMultiplier:d})}let C=(0,o.lf)({height:_,pitch:s,bearing:l,scale:b,altitude:w});if(g){C=(new a.Z).translate([512*g,0,0]).multiplyLeft(C)}super({...t,width:y,height:_,viewMatrix:C,longitude:i,latitude:e,zoom:n,...x,fovy:P,focalDistance:w}),this.latitude=e,this.longitude=i,this.zoom=n,this.pitch=s,this.bearing=l,this.altitude=w,this.fovy=P,this.orthographic=u,this._subViewports=h?[]:null,this._pseudoMeters=v,Object.freeze(this)}get subViewports(){if(this._subViewports&&!this._subViewports.length){const t=this.getBounds(),e=Math.floor((t[0]+180)/360),i=Math.ceil((t[2]-180)/360);for(let n=e;n<=i;n++){const t=n?new l({...this,worldOffset:n}):this;this._subViewports.push(t)}}return this._subViewports}projectPosition(t){if(this._pseudoMeters)return super.projectPosition(t);const[e,i]=this.projectFlat(t);return[e,i,(t[2]||0)*(0,o.NC)(t[1])]}unprojectPosition(t){if(this._pseudoMeters)return super.unprojectPosition(t);const[e,i]=this.unprojectFlat(t);return[e,i,(t[2]||0)/(0,o.NC)(i)]}addMetersToLngLat(t,e){return(0,o.eG)(t,e)}panByPosition(t,e){const i=(0,o.CT)(e,this.pixelUnprojectionMatrix),n=this.projectFlat(t),r=s.IH([],n,s.tk([],i)),a=s.IH([],this.center,r),[l,c]=this.unprojectFlat(a);return{longitude:l,latitude:c}}getBounds(t){void 0===t&&(t={});const e=(0,o.zX)(this,t.z||0);return[Math.min(e[0][0],e[1][0],e[2][0],e[3][0]),Math.min(e[0][1],e[1][1],e[2][1],e[3][1]),Math.max(e[0][0],e[1][0],e[2][0],e[3][0]),Math.max(e[0][1],e[1][1],e[2][1],e[3][1])]}fitBounds(t,e){void 0===e&&(e={});const{width:i,height:n}=this,{longitude:s,latitude:r,zoom:a}=(0,o.Xg)({width:i,height:n,bounds:t,...e});return new l({width:i,height:n,longitude:s,latitude:r,zoom:a})}}l.displayName="WebMercatorViewport"},6362:(t,e,i)=>{"use strict";i.d(e,{Z:()=>r});var n=i(45213),o=i(11199),s=i(26810);class r extends n.Z{get ViewportType(){return o.Z}get ControllerType(){return s.Z}}r.displayName="MapView"},45213:(t,e,i)=>{"use strict";i.d(e,{Z:()=>c});var n=i(48332);const o=/([0-9]+\.?[0-9]*)(%|px)/;function s(t){switch(typeof t){case"number":return{position:t,relative:!1};case"string":const e=o.exec(t);if(e&&e.length>=3){const t="%"===e[2],i=parseFloat(e[1]);return{position:t?i/100:i,relative:t}}default:throw new Error("Could not parse position string "+t)}}function r(t,e){return t.relative?Math.round(t.position*e):t.position}var a=i(77607),l=i(13405);class c{constructor(t){const{id:e,x:i=0,y:o=0,width:r="100%",height:a="100%",padding:c=null,viewportInstance:d}=t||{};(0,l.Z)(!d||d instanceof n.Z),this.viewportInstance=d,this.id=e||this.constructor.displayName||"view",this.props={...t,id:this.id},this._x=s(i),this._y=s(o),this._width=s(r),this._height=s(a),this._padding=c&&{left:s(c.left||0),right:s(c.right||0),top:s(c.top||0),bottom:s(c.bottom||0)},this.equals=this.equals.bind(this),Object.seal(this)}equals(t){return this===t||(this.viewportInstance?!!t.viewportInstance&&this.viewportInstance.equals(t.viewportInstance):this.ViewportType===t.ViewportType&&(0,a.v)(this.props,t.props,2))}makeViewport(t){let{width:e,height:i,viewState:n}=t;if(this.viewportInstance)return this.viewportInstance;n=this.filterViewState(n);const o=this.getDimensions({width:e,height:i});return new this.ViewportType({...n,...this.props,...o})}getViewStateId(){const{viewState:t}=this.props;return"string"==typeof t?t:(null==t?void 0:t.id)||this.id}filterViewState(t){if(this.props.viewState&&"object"==typeof this.props.viewState){if(!this.props.viewState.id)return this.props.viewState;const e={...t};for(const t in this.props.viewState)"id"!==t&&(e[t]=this.props.viewState[t]);return e}return t}getDimensions(t){let{width:e,height:i}=t;const n={x:r(this._x,e),y:r(this._y,i),width:r(this._width,e),height:r(this._height,i)};return this._padding&&(n.padding={left:r(this._padding.left,e),top:r(this._padding.top,i),right:r(this._padding.right,e),bottom:r(this._padding.bottom,i)}),n}get controller(){const t=this.props.controller;return t?!0===t?{type:this.ControllerType}:"function"==typeof t?{type:t}:{type:this.ControllerType,...t}:null}}},62253:(t,e,i)=>{"use strict";i.d(e,{Z:()=>u});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(95321),l=i(15804);const c=[0,0,0,255],d={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getSourceColor:{type:"accessor",value:c},getTargetColor:{type:"accessor",value:c},getWidth:{type:"accessor",value:1},getHeight:{type:"accessor",value:1},getTilt:{type:"accessor",value:0},greatCircle:!1,widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class u extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME arc-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec4 instanceSourceColors;\nattribute vec4 instanceTargetColors;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\nattribute float instanceHeights;\nattribute float instanceTilts;\n\nuniform bool greatCircle;\nuniform bool useShortestPath;\nuniform float numSegments;\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nfloat paraboloid(float distance, float sourceZ, float targetZ, float ratio) {\n\n  float deltaZ = targetZ - sourceZ;\n  float dh = distance * instanceHeights;\n  if (dh == 0.0) {\n    return sourceZ + deltaZ * ratio;\n  }\n  float unitZ = deltaZ / dh;\n  float p2 = unitZ * unitZ + 1.0;\n  float dir = step(deltaZ, 0.0);\n  float z0 = mix(sourceZ, targetZ, dir);\n  float r = mix(ratio, 1.0 - ratio, dir);\n  return sqrt(r * (p2 - r)) * dh + z0;\n}\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nfloat getSegmentRatio(float index) {\n  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));\n}\n\nvec3 interpolateFlat(vec3 source, vec3 target, float segmentRatio) {\n  float distance = length(source.xy - target.xy);\n  float z = paraboloid(distance, source.z, target.z, segmentRatio);\n\n  float tiltAngle = radians(instanceTilts);\n  vec2 tiltDirection = normalize(target.xy - source.xy);\n  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * z * sin(tiltAngle);\n\n  return vec3(\n    mix(source.xy, target.xy, segmentRatio) + tilt,\n    z * cos(tiltAngle)\n  );\n}\nfloat getAngularDist (vec2 source, vec2 target) {\n  vec2 sourceRadians = radians(source);\n  vec2 targetRadians = radians(target);\n  vec2 sin_half_delta = sin((sourceRadians - targetRadians) / 2.0);\n  vec2 shd_sq = sin_half_delta * sin_half_delta;\n\n  float a = shd_sq.y + cos(sourceRadians.y) * cos(targetRadians.y) * shd_sq.x;\n  return 2.0 * asin(sqrt(a));\n}\n\nvec3 interpolateGreatCircle(vec3 source, vec3 target, vec3 source3D, vec3 target3D, float angularDist, float t) {\n  vec2 lngLat;\n  if(abs(angularDist - PI) < 0.001) {\n    lngLat = (1.0 - t) * source.xy + t * target.xy;\n  } else {\n    float a = sin((1.0 - t) * angularDist);\n    float b = sin(t * angularDist);\n    vec3 p = source3D.yxz * a + target3D.yxz * b;\n    lngLat = degrees(vec2(atan(p.y, -p.x), atan(p.z, length(p.xy))));\n  }\n\n  float z = paraboloid(angularDist * EARTH_RADIUS, source.z, target.z, t);\n\n  return vec3(lngLat, z);\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  float segmentIndex = positions.x;\n  float segmentRatio = getSegmentRatio(segmentIndex);\n  float prevSegmentRatio = getSegmentRatio(max(0.0, segmentIndex - 1.0));\n  float nextSegmentRatio = getSegmentRatio(min(numSegments - 1.0, segmentIndex + 1.0));\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\n  isValid = 1.0;\n\n  uv = vec2(segmentRatio, positions.y);\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n\n  vec4 curr;\n  vec4 next;\n  vec3 source;\n  vec3 target;\n\n  if ((greatCircle || project_uProjectionMode == PROJECTION_MODE_GLOBE) && project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n    source = project_globe_(vec3(instanceSourcePositions.xy, 0.0));\n    target = project_globe_(vec3(instanceTargetPositions.xy, 0.0));\n    float angularDist = getAngularDist(instanceSourcePositions.xy, instanceTargetPositions.xy);\n\n    vec3 prevPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, prevSegmentRatio);\n    vec3 currPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, segmentRatio);\n    vec3 nextPos = interpolateGreatCircle(instanceSourcePositions, instanceTargetPositions, source, target, angularDist, nextSegmentRatio);\n\n    if (abs(currPos.x - prevPos.x) > 180.0) {\n      indexDir = -1.0;\n      isValid = 0.0;\n    } else if (abs(currPos.x - nextPos.x) > 180.0) {\n      indexDir = 1.0;\n      isValid = 0.0;\n    }\n    nextPos = indexDir < 0.0 ? prevPos : nextPos;\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n\n    if (isValid == 0.0) {\n      nextPos.x += nextPos.x > 0.0 ? -360.0 : 360.0;\n      float t = ((currPos.x > 0.0 ? 180.0 : -180.0) - currPos.x) / (nextPos.x - currPos.x);\n      currPos = mix(currPos, nextPos, t);\n      segmentRatio = mix(segmentRatio, nextSegmentRatio, t);\n    }\n\n    vec3 currPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, segmentRatio);\n    vec3 nextPos64Low = mix(instanceSourcePositions64Low, instanceTargetPositions64Low, nextSegmentRatio);\n  \n    curr = project_position_to_clipspace(currPos, currPos64Low, vec3(0.0), geometry.position);\n    next = project_position_to_clipspace(nextPos, nextPos64Low, vec3(0.0));\n  \n  } else {\n    vec3 source_world = instanceSourcePositions;\n    vec3 target_world = instanceTargetPositions;\n    if (useShortestPath) {\n      source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n      target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n\n      float deltaLng = target_world.x - source_world.x;\n      if (deltaLng > 180.) target_world.x -= 360.;\n      if (deltaLng < -180.) source_world.x -= 360.;\n    }\n    source = project_position(source_world, instanceSourcePositions64Low);\n    target = project_position(target_world, instanceTargetPositions64Low);\n    float antiMeridianX = 0.0;\n\n    if (useShortestPath) {\n      if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n        antiMeridianX = -(project_uCoordinateOrigin.x + 180.) / 360. * TILE_SIZE;\n      }\n      float thresholdRatio = (antiMeridianX - source.x) / (target.x - source.x);\n\n      if (prevSegmentRatio <= thresholdRatio && nextSegmentRatio > thresholdRatio) {\n        isValid = 0.0;\n        indexDir = sign(segmentRatio - thresholdRatio);\n        segmentRatio = thresholdRatio;\n      }\n    }\n\n    nextSegmentRatio = indexDir < 0.0 ? prevSegmentRatio : nextSegmentRatio;\n    vec3 currPos = interpolateFlat(source, target, segmentRatio);\n    vec3 nextPos = interpolateFlat(source, target, nextSegmentRatio);\n\n    if (useShortestPath) {\n      if (nextPos.x < antiMeridianX) {\n        currPos.x += TILE_SIZE;\n        nextPos.x += TILE_SIZE;\n      }\n    }\n\n    curr = project_common_position_to_clipspace(vec4(currPos, 1.0));\n    next = project_common_position_to_clipspace(vec4(nextPos, 1.0));\n    geometry.position = vec4(currPos, 1.0);\n  }\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(curr, geometry);\n  gl_Position = curr + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n\n  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio);\n  vColor = vec4(color.rgb, color.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME arc-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvarying float isValid;\n\nvoid main(void) {\n  if (isValid == 0.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  geometry.uv = uv;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceSourceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getSourceColor",defaultValue:c},instanceTargetColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getTargetColor",defaultValue:c},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1},instanceHeights:{size:1,transition:!0,accessor:"getHeight",defaultValue:1},instanceTilts:{size:1,transition:!0,accessor:"getTilt",defaultValue:0}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null==(e=this.state.model)||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{widthUnits:i,widthScale:n,widthMinPixels:o,widthMaxPixels:s,greatCircle:a,wrapLongitude:l}=this.props;this.state.model.setUniforms(e).setUniforms({greatCircle:a,widthUnits:r.iI[i],widthScale:n,widthMinPixels:o,widthMaxPixels:s,useShortestPath:l}).draw()}_getModel(t){let e=[];for(let n=0;n<50;n++)e=e.concat([n,1,0,n,-1,0]);const i=new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:5,attributes:{positions:new Float32Array(e)}}),isInstanced:!0});return i.setUniforms({numSegments:50}),i}}u.layerName="ArcLayer",u.defaultProps=d},99147:(t,e,i)=>{"use strict";i.d(e,{Z:()=>m});var n=i(43631),o=i(47251),s=i(18056),r=i(71693),a=i(95321),l=i(15804),c=i(92797),d=i(28835);const u=new Uint16Array([0,2,1,0,3,2]),p=new Float32Array([0,1,0,0,1,0,1,1]);function h(t,e){if(!e)return function(t){const e=new Float64Array(12);for(let i=0;i<t.length;i++)e[3*i+0]=t[i][0],e[3*i+1]=t[i][1],e[3*i+2]=t[i][2]||0;return{vertexCount:6,positions:e,indices:u,texCoords:p}}(t);const i=Math.max(Math.abs(t[0][0]-t[3][0]),Math.abs(t[1][0]-t[2][0])),n=Math.max(Math.abs(t[1][1]-t[0][1]),Math.abs(t[2][1]-t[3][1])),o=Math.ceil(i/e)+1,s=Math.ceil(n/e)+1,r=(o-1)*(s-1)*6,a=new Uint32Array(r),l=new Float32Array(o*s*2),c=new Float64Array(o*s*3);let d=0,h=0;for(let u=0;u<o;u++){const e=u/(o-1);for(let i=0;i<s;i++){const n=i/(s-1),o=g(t,e,n);c[3*d+0]=o[0],c[3*d+1]=o[1],c[3*d+2]=o[2]||0,l[2*d+0]=e,l[2*d+1]=1-n,u>0&&i>0&&(a[h++]=d-s,a[h++]=d-s-1,a[h++]=d-1,a[h++]=d-s,a[h++]=d-1,a[h++]=d),d++}}return{vertexCount:r,positions:c,indices:a,texCoords:l}}function g(t,e,i){return(0,d.t7)((0,d.t7)(t[0],t[1],i),(0,d.t7)(t[3],t[2],i),e)}const f={image:{type:"image",value:null,async:!0},bounds:{type:"array",value:[1,0,0,1],compare:!0},_imageCoordinateSystem:n.Df.DEFAULT,desaturate:{type:"number",min:0,max:1,value:0},transparentColor:{type:"color",value:[0,0,0,0]},tintColor:{type:"color",value:[255,255,255]}};class m extends o.Z{getShaders(){return super.getShaders({vs:"\n#define SHADER_NAME bitmap-layer-vertex-shader\n\nattribute vec2 texCoords;\nattribute vec3 positions;\nattribute vec3 positions64Low;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float coordinateConversion;\n\nconst vec3 pickingColor = vec3(1.0, 0.0, 0.0);\n\nvoid main(void) {\n  geometry.worldPosition = positions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = pickingColor;\n\n  gl_Position = project_position_to_clipspace(positions, positions64Low, vec3(0.0), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vTexCoord = texCoords;\n\n  if (coordinateConversion < -0.5) {\n    vTexPos = geometry.position.xy + project_uCommonOrigin.xy;\n  } else if (coordinateConversion > 0.5) {\n    vTexPos = geometry.worldPosition.xy;\n  }\n\n  vec4 color = vec4(0.0);\n  DECKGL_FILTER_COLOR(color, geometry);\n}\n",fs:"\n#define SHADER_NAME bitmap-layer-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D bitmapTexture;\n\nvarying vec2 vTexCoord;\nvarying vec2 vTexPos;\n\nuniform float desaturate;\nuniform vec4 transparentColor;\nuniform vec3 tintColor;\nuniform float opacity;\n\nuniform float coordinateConversion;\nuniform vec4 bounds;\n\n/* projection utils */\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / PI / 2.0;\n\n// from degrees to Web Mercator\nvec2 lnglat_to_mercator(vec2 lnglat) {\n  float x = lnglat.x;\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// from Web Mercator to degrees\nvec2 mercator_to_lnglat(vec2 xy) {\n  xy /= WORLD_SCALE;\n  return degrees(vec2(\n    xy.x - PI,\n    atan(exp(xy.y - PI)) * 2.0 - PI * 0.5\n  ));\n}\n/* End projection utils */\n\n// apply desaturation\nvec3 color_desaturate(vec3 color) {\n  float luminance = (color.r + color.g + color.b) * 0.333333333;\n  return mix(color, vec3(luminance), desaturate);\n}\n\n// apply tint\nvec3 color_tint(vec3 color) {\n  return color * tintColor;\n}\n\n// blend with background color\nvec4 apply_opacity(vec3 color, float alpha) {\n  if (transparentColor.a == 0.0) {\n    return vec4(color, alpha);\n  }\n  float blendedAlpha = alpha + transparentColor.a * (1.0 - alpha);\n  float highLightRatio = alpha / blendedAlpha;\n  vec3 blendedRGB = mix(transparentColor.rgb, color, highLightRatio);\n  return vec4(blendedRGB, blendedAlpha);\n}\n\nvec2 getUV(vec2 pos) {\n  return vec2(\n    (pos.x - bounds[0]) / (bounds[2] - bounds[0]),\n    (pos.y - bounds[3]) / (bounds[1] - bounds[3])\n  );\n}\n\n\nvec3 packUVsIntoRGB(vec2 uv) {\n  // Extract the top 8 bits. We want values to be truncated down so we can add a fraction\n  vec2 uv8bit = floor(uv * 256.);\n\n  // Calculate the normalized remainders of u and v parts that do not fit into 8 bits\n  // Scale and clamp to 0-1 range\n  vec2 uvFraction = fract(uv * 256.);\n  vec2 uvFraction4bit = floor(uvFraction * 16.);\n\n  // Remainder can be encoded in blue channel, encode as 4 bits for pixel coordinates\n  float fractions = uvFraction4bit.x + uvFraction4bit.y * 16.;\n\n  return vec3(uv8bit, fractions) / 255.;\n}\n\n\nvoid main(void) {\n  vec2 uv = vTexCoord;\n  if (coordinateConversion < -0.5) {\n    vec2 lnglat = mercator_to_lnglat(vTexPos);\n    uv = getUV(lnglat);\n  } else if (coordinateConversion > 0.5) {\n    vec2 commonPos = lnglat_to_mercator(vTexPos);\n    uv = getUV(commonPos);\n  }\n  vec4 bitmapColor = texture2D(bitmapTexture, uv);\n\n  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);\n\n  geometry.uv = uv;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n\n  if (picking_uActive) {\n    // Since instance information is not used, we can use picking color for pixel index\n    gl_FragColor.rgb = packUVsIntoRGB(uv);\n  }\n}\n",modules:[s.Z,r.Z]})}initializeState(){const t=this.getAttributeManager();t.remove(["instancePickingColors"]);const e=!0;t.add({indices:{size:1,isIndexed:!0,update:t=>t.value=this.state.mesh.indices,noAlloc:e},positions:{size:3,type:5130,fp64:this.use64bitPositions(),update:t=>t.value=this.state.mesh.positions,noAlloc:e},texCoords:{size:2,update:t=>t.value=this.state.mesh.texCoords,noAlloc:e}})}updateState(t){let{props:e,oldProps:i,changeFlags:n}=t;const o=this.getAttributeManager();if(n.extensionsChanged){var s;const{gl:t}=this.context;null==(s=this.state.model)||s.delete(),this.state.model=this._getModel(t),o.invalidateAll()}if(e.bounds!==i.bounds){const t=this.state.mesh,e=this._createMesh();this.state.model.setVertexCount(e.vertexCount);for(const i in e)t&&t[i]!==e[i]&&o.invalidate(i);this.setState({mesh:e,...this._getCoordinateUniforms()})}else e._imageCoordinateSystem!==i._imageCoordinateSystem&&this.setState(this._getCoordinateUniforms())}getPickingInfo(t){const{image:e}=this.props,i=t.info;if(!i.color||!e)return i.bitmap=null,i;const{width:n,height:o}=e;i.index=0;const s=function(t){const[e,i,n]=t;return[(e+(15&n)/16)/256,(i+(240&n)/256)/256]}(i.color),r=[Math.floor(s[0]*n),Math.floor(s[1]*o)];return i.bitmap={size:{width:n,height:o},uv:s,pixel:r},i}disablePickingIndex(){this.setState({disablePicking:!0})}restorePickingColors(){this.setState({disablePicking:!1})}_updateAutoHighlight(t){super._updateAutoHighlight({...t,color:this.encodePickingColor(0)})}_createMesh(){const{bounds:t}=this.props;let e=t;return v(t)&&(e=[[t[0],t[1]],[t[0],t[3]],[t[2],t[3]],[t[2],t[1]]]),h(e,this.context.viewport.resolution)}_getModel(t){return t?new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:4,vertexCount:6}),isInstanced:!1}):null}draw(t){const{uniforms:e,moduleParameters:i}=t,{model:n,coordinateConversion:o,bounds:s,disablePicking:r}=this.state,{image:a,desaturate:l,transparentColor:c,tintColor:d}=this.props;i.pickingActive&&r||a&&n&&n.setUniforms(e).setUniforms({bitmapTexture:a,desaturate:l,transparentColor:c.map((t=>t/255)),tintColor:d.slice(0,3).map((t=>t/255)),coordinateConversion:o,bounds:s}).draw()}_getCoordinateUniforms(){const{LNGLAT:t,CARTESIAN:e,DEFAULT:i}=n.Df;let{_imageCoordinateSystem:o}=this.props;if(o!==i){const{bounds:i}=this.props;if(!v(i))throw new Error("_imageCoordinateSystem only supports rectangular bounds");const n=this.context.viewport.resolution?t:e;if(o=o===t?t:e,o===t&&n===e)return{coordinateConversion:-1,bounds:i};if(o===e&&n===t){const t=(0,c.w5)([i[0],i[1]]),e=(0,c.w5)([i[2],i[3]]);return{coordinateConversion:1,bounds:[t[0],t[1],e[0],e[1]]}}}return{coordinateConversion:0,bounds:[0,0,0,0]}}}function v(t){return Number.isFinite(t[0])}m.layerName="BitmapLayer",m.defaultProps=f},68797:(t,e,i)=>{"use strict";i.d(e,{Z:()=>_});var n=i(47251),o=i(18056),s=i(89771),r=i(71693),a=i(43631),l=i(7092),c=i(19227),d=i(83757),u=i(95321),p=i(89745),h=i(15804),g=i(51355),f=i(59021);class m extends h.Z{constructor(t){const{id:e=(0,g.hQ)("column-geometry")}=t,{indices:i,attributes:n}=function(t){const{radius:e,height:i=1,nradial:n=10}=t;let{vertices:o}=t;o&&(p.Z.assert(o.length>=n),o=o.flatMap((t=>[t[0],t[1]])),(0,f.Ny)(o,f.wG.COUNTER_CLOCKWISE));const s=i>0,r=n+1,a=s?3*r+1:n,l=2*Math.PI/n,c=new Uint16Array(s?3*n*2:0),d=new Float32Array(3*a),u=new Float32Array(3*a);let h=0;if(s){for(let t=0;t<r;t++){const s=t*l,r=t%n,a=Math.sin(s),c=Math.cos(s);for(let t=0;t<2;t++)d[h+0]=o?o[2*r]:c*e,d[h+1]=o?o[2*r+1]:a*e,d[h+2]=(.5-t)*i,u[h+0]=o?o[2*r]:c,u[h+1]=o?o[2*r+1]:a,h+=3}d[h+0]=d[h-3],d[h+1]=d[h-2],d[h+2]=d[h-1],h+=3}for(let p=s?0:1;p<r;p++){const t=Math.floor(p/2)*Math.sign(.5-p%2),s=t*l,r=(t+n)%n,a=Math.sin(s),c=Math.cos(s);d[h+0]=o?o[2*r]:c*e,d[h+1]=o?o[2*r+1]:a*e,d[h+2]=i/2,u[h+2]=1,h+=3}if(s){let t=0;for(let e=0;e<n;e++)c[t++]=2*e+0,c[t++]=2*e+2,c[t++]=2*e+0,c[t++]=2*e+1,c[t++]=2*e+1,c[t++]=2*e+3}return{indices:c,attributes:{POSITION:{size:3,value:d},NORMAL:{size:3,value:u}}}}(t);super({...t,id:e,indices:i,attributes:n})}}const v=[0,0,0,255],y={diskResolution:{type:"number",min:4,value:20},vertices:null,radius:{type:"number",min:0,value:1e3},angle:{type:"number",value:0},offset:{type:"array",value:[0,0]},coverage:{type:"number",min:0,max:1,value:1},elevationScale:{type:"number",min:0,value:1},radiusUnits:"meters",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,extruded:!0,wireframe:!1,filled:!0,stroked:!1,getPosition:{type:"accessor",value:t=>t.position},getFillColor:{type:"accessor",value:v},getLineColor:{type:"accessor",value:v},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0,getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class _ extends n.Z{getShaders(){const{gl:t}=this.context,e=!(0,l.D0)(t),i={},n=this.props.flatShading&&(0,c.U6)(t,d.h.GLSL_DERIVATIVES);return n&&(i.FLAT_SHADING=1),super.getShaders({vs:"#version 300 es\n\n#define SHADER_NAME column-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\n\nin vec3 instancePickingColors;\nuniform float opacity;\nuniform float radius;\nuniform float angle;\nuniform vec2 offset;\nuniform bool extruded;\nuniform bool stroked;\nuniform bool isStroke;\nuniform float coverage;\nuniform float elevationScale;\nuniform float edgeDistance;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform int radiusUnits;\nuniform int widthUnits;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n\n  vec4 color = isStroke ? instanceLineColors : instanceFillColors;\n  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n  float elevation = 0.0;\n  float strokeOffsetRatio = 1.0;\n\n  if (extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;\n  } else if (stroked) {\n    float widthPixels = clamp(\n      project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n      widthMinPixels, widthMaxPixels) / 2.0;\n    float halfOffset = project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);\n    if (isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float dotRadius = radius * coverage * shouldRender;\n\n  geometry.pickingColor = instancePickingColors;\n  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\n  vec3 centroidPosition64Low = instancePositions64Low;\n  vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius;\n  if (radiusUnits == UNIT_METERS) {\n    offset = project_size(offset);\n  }\n  vec3 pos = vec3(offset, 0.);\n  DECKGL_FILTER_SIZE(pos, geometry);\n\n  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\n  geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  if (extruded && !isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\n\nprecision highp float;\n\nuniform vec3 project_uCameraPosition;\nuniform bool extruded;\nuniform bool isStroke;\n\nout vec4 fragColor;\n\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  fragColor = vColor;\n#ifdef FLAT_SHADING\n  if (extruded && !isStroke && !picking_uActive) {\n    vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n    fragColor.rgb = lighting_getLightColor(vColor.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\n  }\n#endif\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n",defines:i,transpileToGLSL100:e,modules:[o.Z,n?s.s:s.N,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceElevations:{size:1,transition:!0,accessor:"getElevation"},instanceFillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getFillColor",defaultValue:v},instanceLineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getLineColor",defaultValue:v},instanceStrokeWidths:{size:1,accessor:"getLineWidth",transition:!0}})}updateState(t){super.updateState(t);const{props:e,oldProps:i,changeFlags:n}=t,o=n.extensionsChanged||e.flatShading!==i.flatShading;if(o){var s;const{gl:t}=this.context;null==(s=this.state.model)||s.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}(o||e.diskResolution!==i.diskResolution||e.vertices!==i.vertices||(e.extruded||e.stroked)!==(i.extruded||i.stroked))&&this._updateGeometry(e)}getGeometry(t,e,i){const n=new m({radius:1,height:i?2:0,vertices:e,nradial:t});let o=0;if(e)for(let s=0;s<t;s++){const i=e[s];o+=Math.sqrt(i[0]*i[0]+i[1]*i[1])/t}else o=1;return this.setState({edgeDistance:Math.cos(Math.PI/t)*o}),n}_getModel(t){return new u.Z(t,{...this.getShaders(),id:this.props.id,isInstanced:!0})}_updateGeometry(t){let{diskResolution:e,vertices:i,extruded:n,stroked:o}=t;const s=this.getGeometry(e,i,n||o);this.setState({fillVertexCount:s.attributes.POSITION.value.length/3,wireframeVertexCount:s.indices.value.length}),this.state.model.setProps({geometry:s})}draw(t){let{uniforms:e}=t;const{lineWidthUnits:i,lineWidthScale:n,lineWidthMinPixels:o,lineWidthMaxPixels:s,radiusUnits:r,elevationScale:l,extruded:c,filled:d,stroked:u,wireframe:p,offset:h,coverage:g,radius:f,angle:m}=this.props,{model:v,fillVertexCount:y,wireframeVertexCount:_,edgeDistance:w}=this.state;v.setUniforms(e).setUniforms({radius:f,angle:m/180*Math.PI,offset:h,extruded:c,stroked:u,coverage:g,elevationScale:l,edgeDistance:w,radiusUnits:a.iI[r],widthUnits:a.iI[i],widthScale:n,widthMinPixels:o,widthMaxPixels:s}),c&&p&&(v.setProps({isIndexed:!0}),v.setVertexCount(_).setDrawMode(1).setUniforms({isStroke:!0}).draw()),d&&(v.setProps({isIndexed:!1}),v.setVertexCount(y).setDrawMode(5).setUniforms({isStroke:!1}).draw()),!c&&u&&(v.setProps({isIndexed:!1}),v.setVertexCount(2*y/3).setDrawMode(5).setUniforms({isStroke:!0}).draw())}}_.layerName="ColumnLayer",_.defaultProps=y},31759:(t,e,i)=>{"use strict";i.d(e,{Z:()=>r});var n=i(32900),o=i(43631),s=i(68797);class r extends s.Z{getGeometry(t){return new n.Z}draw(t){let{uniforms:e}=t;const{elevationScale:i,extruded:n,offset:s,coverage:r,cellSize:a,angle:l,radiusUnits:c}=this.props;this.state.model.setUniforms(e).setUniforms({radius:a/2,radiusUnits:o.iI[c],angle:l,offset:s,extruded:n,coverage:r,elevationScale:i,edgeDistance:1,isWireframe:!1}).draw()}}r.layerName="GridCellLayer",r.defaultProps={cellSize:{type:"number",min:0,value:1e3},offset:{type:"array",value:[1,1]}}},88123:(t,e,i)=>{"use strict";i.d(e,{Z:()=>x});var n=i(19871),o=i(46025);var s=i(6735),r=i(24309),a=i(27800),l=i(52329),c=i(57654);const d={circle:{type:r.Z,props:{filled:"filled",stroked:"stroked",lineWidthMaxPixels:"lineWidthMaxPixels",lineWidthMinPixels:"lineWidthMinPixels",lineWidthScale:"lineWidthScale",lineWidthUnits:"lineWidthUnits",pointRadiusMaxPixels:"radiusMaxPixels",pointRadiusMinPixels:"radiusMinPixels",pointRadiusScale:"radiusScale",pointRadiusUnits:"radiusUnits",pointAntialiasing:"antialiasing",pointBillboard:"billboard",getFillColor:"getFillColor",getLineColor:"getLineColor",getLineWidth:"getLineWidth",getPointRadius:"getRadius"}},icon:{type:s.Z,props:{iconAtlas:"iconAtlas",iconMapping:"iconMapping",iconSizeMaxPixels:"sizeMaxPixels",iconSizeMinPixels:"sizeMinPixels",iconSizeScale:"sizeScale",iconSizeUnits:"sizeUnits",iconAlphaCutoff:"alphaCutoff",iconBillboard:"billboard",getIcon:"getIcon",getIconAngle:"getAngle",getIconColor:"getColor",getIconPixelOffset:"getPixelOffset",getIconSize:"getSize"}},text:{type:a.Z,props:{textSizeMaxPixels:"sizeMaxPixels",textSizeMinPixels:"sizeMinPixels",textSizeScale:"sizeScale",textSizeUnits:"sizeUnits",textBackground:"background",textBackgroundPadding:"backgroundPadding",textFontFamily:"fontFamily",textFontWeight:"fontWeight",textLineHeight:"lineHeight",textMaxWidth:"maxWidth",textOutlineColor:"outlineColor",textOutlineWidth:"outlineWidth",textWordBreak:"wordBreak",textCharacterSet:"characterSet",textBillboard:"billboard",textFontSettings:"fontSettings",getText:"getText",getTextAngle:"getAngle",getTextColor:"getColor",getTextPixelOffset:"getPixelOffset",getTextSize:"getSize",getTextAnchor:"getTextAnchor",getTextAlignmentBaseline:"getAlignmentBaseline",getTextBackgroundColor:"getBackgroundColor",getTextBorderColor:"getBorderColor",getTextBorderWidth:"getBorderWidth"}}},u={type:l.Z,props:{lineWidthUnits:"widthUnits",lineWidthScale:"widthScale",lineWidthMinPixels:"widthMinPixels",lineWidthMaxPixels:"widthMaxPixels",lineJointRounded:"jointRounded",lineCapRounded:"capRounded",lineMiterLimit:"miterLimit",lineBillboard:"billboard",getLineColor:"getColor",getLineWidth:"getWidth"}},p={type:c.Z,props:{extruded:"extruded",filled:"filled",wireframe:"wireframe",elevationScale:"elevationScale",material:"material",_full3d:"_full3d",getElevation:"getElevation",getFillColor:"getFillColor",getLineColor:"getLineColor"}};function h(t){let{type:e,props:i}=t;const n={};for(const o in i)n[o]=e.defaultProps[i[o]];return n}function g(t,e){const{transitions:i,updateTriggers:n}=t.props,o={updateTriggers:{},transitions:i&&{getPosition:i.geometry}};for(const s in e){const r=e[s];let a=t.props[s];s.startsWith("get")&&(a=t.getSubLayerAccessor(a),o.updateTriggers[r]=n[s],i&&(o.transitions[r]=i[s])),o[r]=a}return o}var f=i(89745);function m(t,e,i){void 0===i&&(i={});const n={pointFeatures:[],lineFeatures:[],polygonFeatures:[],polygonOutlineFeatures:[]},{startRow:o=0,endRow:s=t.length}=i;for(let r=o;r<s;r++){const i=t[r],{geometry:o}=i;if(o)if("GeometryCollection"===o.type){f.Z.assert(Array.isArray(o.geometries),"GeoJSON does not have geometries array");const{geometries:t}=o;for(let o=0;o<t.length;o++){v(t[o],n,e,i,r)}}else v(o,n,e,i,r)}return n}function v(t,e,i,n,o){const{type:s,coordinates:r}=t,{pointFeatures:a,lineFeatures:l,polygonFeatures:c,polygonOutlineFeatures:d}=e;if(function(t,e){let i=y[t];f.Z.assert(i,"Unknown GeoJSON type "+t);for(;e&&--i>0;)e=e[0];return e&&Number.isFinite(e[0])}(s,r))switch(s){case"Point":a.push(i({geometry:t},n,o));break;case"MultiPoint":r.forEach((t=>{a.push(i({geometry:{type:"Point",coordinates:t}},n,o))}));break;case"LineString":l.push(i({geometry:t},n,o));break;case"MultiLineString":r.forEach((t=>{l.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"Polygon":c.push(i({geometry:t},n,o)),r.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}));break;case"MultiPolygon":r.forEach((t=>{c.push(i({geometry:{type:"Polygon",coordinates:t}},n,o)),t.forEach((t=>{d.push(i({geometry:{type:"LineString",coordinates:t}},n,o))}))}))}else f.Z.warn(s+" coordinates are malformed")()}const y={Point:1,MultiPoint:2,LineString:2,MultiLineString:3,Polygon:3,MultiPolygon:4};function _(t){return t.geometry.coordinates}function w(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{points:n,lines:o,polygons:s}=t,r=function(t,e){const i={points:null,lines:null,polygons:null};for(const n in i){const o=t[n].globalFeatureIds.value;i[n]=new Uint8ClampedArray(3*o.length);const s=[];for(let t=0;t<o.length;t++)e(o[t],s),i[n][3*t+0]=s[0],i[n][3*t+1]=s[1],i[n][3*t+2]=s[2]}return i}(t,e);return i.points.data={length:n.positions.value.length/n.positions.size,attributes:{...n.attributes,getPosition:n.positions,instancePickingColors:{size:3,value:r.points}},properties:n.properties,numericProps:n.numericProps,featureIds:n.featureIds},i.lines.data={length:o.pathIndices.value.length-1,startIndices:o.pathIndices.value,attributes:{...o.attributes,getPath:o.positions,instancePickingColors:{size:3,value:r.lines}},properties:o.properties,numericProps:o.numericProps,featureIds:o.featureIds},i.lines._pathType="open",i.polygons.data={length:s.polygonIndices.value.length-1,startIndices:s.polygonIndices.value,attributes:{...s.attributes,getPolygon:s.positions,pickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygons._normalize=!1,s.triangles&&(i.polygons.data.attributes.indices=s.triangles.value),i.polygonsOutline.data={length:s.primitivePolygonIndices.value.length-1,startIndices:s.primitivePolygonIndices.value,attributes:{...s.attributes,getPath:s.positions,instancePickingColors:{size:3,value:r.polygons}},properties:s.properties,numericProps:s.numericProps,featureIds:s.featureIds},i.polygonsOutline._pathType="open",i}const b=["points","linestrings","polygons"],P={...h(d.circle),...h(d.icon),...h(d.text),...h(u),...h(p),stroked:!0,filled:!0,extruded:!1,wireframe:!1,_full3d:!1,iconAtlas:{type:"object",value:null},iconMapping:{type:"object",value:{}},getIcon:{type:"accessor",value:t=>t.properties.icon},getText:{type:"accessor",value:t=>t.properties.text},pointType:"circle",getRadius:{deprecatedFor:"getPointRadius"}};class x extends n.Z{initializeState(){this.state={layerProps:{},features:{}}}updateState(t){let{props:e,changeFlags:i}=t;if(!i.dataChanged)return;const{data:n}=this.props,o=n&&"points"in n&&"polygons"in n&&"lines"in n;this.setState({binary:o}),o?this._updateStateBinary({props:e,changeFlags:i}):this._updateStateJSON({props:e,changeFlags:i})}_updateStateBinary(t){let{props:e,changeFlags:i}=t;const n=w(e.data,this.encodePickingColor);this.setState({layerProps:n})}_updateStateJSON(t){let{props:e,changeFlags:i}=t;const n=function(t){if(Array.isArray(t))return t;switch(f.Z.assert(t.type,"GeoJSON does not have type"),t.type){case"Feature":return[t];case"FeatureCollection":return f.Z.assert(Array.isArray(t.features),"GeoJSON does not have features array"),t.features;default:return[{geometry:t}]}}(e.data),s=this.getSubLayerRow.bind(this);let r={};const a={};if(Array.isArray(i.dataChanged)){const t=this.state.features;for(const e in t)r[e]=t[e].slice(),a[e]=[];for(const e of i.dataChanged){const i=m(n,s,e);for(const n in t)a[n].push((0,o.b)({data:r[n],getIndex:t=>t.__source.index,dataRange:e,replace:i[n]}))}}else r=m(n,s);const l=function(t,e){const i={points:{},lines:{},polygons:{},polygonsOutline:{}},{pointFeatures:n,lineFeatures:o,polygonFeatures:s,polygonOutlineFeatures:r}=t;return i.points.data=n,i.points._dataDiff=e.pointFeatures&&(()=>e.pointFeatures),i.points.getPosition=_,i.lines.data=o,i.lines._dataDiff=e.lineFeatures&&(()=>e.lineFeatures),i.lines.getPath=_,i.polygons.data=s,i.polygons._dataDiff=e.polygonFeatures&&(()=>e.polygonFeatures),i.polygons.getPolygon=_,i.polygonsOutline.data=r,i.polygonsOutline._dataDiff=e.polygonOutlineFeatures&&(()=>e.polygonOutlineFeatures),i.polygonsOutline.getPath=_,i}(r,a);this.setState({features:r,featuresDiff:a,layerProps:l})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i,sourceLayer:n}=e;return e.featureType=b.find((t=>n.id.startsWith(this.id+"-"+t+"-"))),i>=0&&n.id.startsWith(this.id+"-points-text")&&this.state.binary&&(e.index=this.props.data.points.globalFeatureIds.value[i]),e}_updateAutoHighlight(t){const e=this.id+"-points-",i="points"===t.featureType;for(const n of this.getSubLayers())n.id.startsWith(e)===i&&n.updateAutoHighlight(t)}_renderPolygonLayer(){const{extruded:t,wireframe:e}=this.props,{layerProps:i}=this.state,n="polygons-fill",o=this.shouldRenderSubLayer(n,i.polygons.data)&&this.getSubLayerClass(n,p.type);if(o){const s=g(this,p.props),r=t&&e;return r||delete s.getLineColor,s.updateTriggers.lineColors=r,new o(s,this.getSubLayerProps({id:n,updateTriggers:s.updateTriggers}),i.polygons)}return null}_renderLineLayers(){const{extruded:t,stroked:e}=this.props,{layerProps:i}=this.state,n="polygons-stroke",o="linestrings",s=!t&&e&&this.shouldRenderSubLayer(n,i.polygonsOutline.data)&&this.getSubLayerClass(n,u.type),r=this.shouldRenderSubLayer(o,i.lines.data)&&this.getSubLayerClass(o,u.type);if(s||r){const t=g(this,u.props);return[s&&new s(t,this.getSubLayerProps({id:n,updateTriggers:t.updateTriggers}),i.polygonsOutline),r&&new r(t,this.getSubLayerProps({id:o,updateTriggers:t.updateTriggers}),i.lines)]}return null}_renderPointLayers(){const{pointType:t}=this.props,{layerProps:e,binary:i}=this.state;let{highlightedObjectIndex:n}=this.props;!i&&Number.isFinite(n)&&(n=e.points.data.findIndex((t=>t.__source.index===n)));const o=new Set(t.split("+")),s=[];for(const r of o){const t="points-"+r,o=d[r],a=o&&this.shouldRenderSubLayer(t,e.points.data)&&this.getSubLayerClass(t,o.type);if(a){const l=g(this,o.props);let c=e.points;if("text"===r&&i){const{instancePickingColors:t,...e}=c.data.attributes;c={...c,data:{...c.data,attributes:e}}}s.push(new a(l,this.getSubLayerProps({id:t,updateTriggers:l.updateTriggers,highlightedObjectIndex:n}),c))}}return s}renderLayers(){const{extruded:t}=this.props,e=this._renderPolygonLayer();return[!t&&e,this._renderLineLayers(),this._renderPointLayers(),t&&e]}getSubLayerAccessor(t){const{binary:e}=this.state;return e&&"function"==typeof t?(e,i)=>{const{data:n,index:o}=i,s=function(t,e){if(!t)return null;const i="startIndices"in t?t.startIndices[e]:e,n=t.featureIds.value[i];return-1!==i?function(t,e,i){const n={properties:{...t.properties[e]}};for(const o in t.numericProps)n.properties[o]=t.numericProps[o].value[i];return n}(t,n,i):null}(n,o);return t(s,i)}:super.getSubLayerAccessor(t)}}x.layerName="GeoJsonLayer",x.defaultProps=P},6735:(t,e,i)=>{"use strict";i.d(e,{Z:()=>P});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(89745),l=i(95321),c=i(15804);var d=i(43970),u=i(88163),p=i(96742),h=i(37944);const g=()=>{},f={10241:9987,10240:9729,10242:33071,10243:33071};function m(t,e,i,n){const o=Math.min(i/e.width,n/e.height),s=Math.floor(e.width*o),r=Math.floor(e.height*o);return 1===o?{data:e,width:s,height:r}:(t.canvas.height=r,t.canvas.width=s,t.clearRect(0,0,s,r),t.drawImage(e,0,0,e.width,e.height,0,0,s,r),{data:t.canvas,width:s,height:r})}function v(t){return t&&(t.id||t.url)}function y(t,e,i){for(let n=0;n<e.length;n++){const{icon:o,xOffset:s}=e[n];t[v(o)]={...o,x:s,y:i}}}class _{constructor(t,e){let{onUpdate:i=g,onError:n=g}=e;this._loadOptions=null,this._texture=null,this._externalTexture=null,this._mapping={},this._textureParameters=null,this._pendingCount=0,this._autoPacking=!1,this._xOffset=0,this._yOffset=0,this._rowHeight=0,this._buffer=4,this._canvasWidth=1024,this._canvasHeight=0,this._canvas=null,this.gl=t,this.onUpdate=i,this.onError=n}finalize(){var t;null==(t=this._texture)||t.delete()}getTexture(){return this._texture||this._externalTexture}getIconMapping(t){const e=this._autoPacking?v(t):t;return this._mapping[e]||{}}setProps(t){let{loadOptions:e,autoPacking:i,iconAtlas:n,iconMapping:o,textureParameters:s}=t;var r;(e&&(this._loadOptions=e),void 0!==i&&(this._autoPacking=i),o&&(this._mapping=o),n)&&(null==(r=this._texture)||r.delete(),this._texture=null,this._externalTexture=n);s&&(this._textureParameters=s)}get isLoaded(){return 0===this._pendingCount}packIcons(t,e){if(!this._autoPacking||"undefined"==typeof document)return;const i=Object.values(function(t,e,i){if(!t||!e)return null;i=i||{};const n={},{iterable:o,objectInfo:s}=(0,h.jB)(t);for(const r of o){s.index++;const t=e(r,s),o=v(t);if(!t)throw new Error("Icon is missing.");if(!t.url)throw new Error("Icon url is missing.");n[o]||i[o]&&t.url===i[o].url||(n[o]={...t,source:r,sourceIndex:s.index})}return n}(t,e,this._mapping)||{});if(i.length>0){const{mapping:t,xOffset:e,yOffset:n,rowHeight:o,canvasHeight:s}=function(t){let{icons:e,buffer:i,mapping:n={},xOffset:o=0,yOffset:s=0,rowHeight:r=0,canvasWidth:a}=t,l=[];for(let d=0;d<e.length;d++){const t=e[d];if(!n[v(t)]){const{height:e,width:c}=t;o+c+i>a&&(y(n,l,s),o=0,s=r+s+i,r=0,l=[]),l.push({icon:t,xOffset:o}),o=o+c+i,r=Math.max(r,e)}}return l.length>0&&y(n,l,s),{mapping:n,rowHeight:r,xOffset:o,yOffset:s,canvasWidth:a,canvasHeight:(c=r+s+i,Math.pow(2,Math.ceil(Math.log2(c))))};var c}({icons:i,buffer:this._buffer,canvasWidth:this._canvasWidth,mapping:this._mapping,rowHeight:this._rowHeight,xOffset:this._xOffset,yOffset:this._yOffset});this._rowHeight=o,this._mapping=t,this._xOffset=e,this._yOffset=n,this._canvasHeight=s,this._texture||(this._texture=new d.Z(this.gl,{width:this._canvasWidth,height:this._canvasHeight,parameters:this._textureParameters||f})),this._texture.height!==this._canvasHeight&&(this._texture=function(t,e,i,n){const o=t.width,s=t.height,r=new d.Z(t.gl,{width:e,height:i,parameters:n});return(0,u.Lv)(t,r,{targetY:0,width:o,height:s}),t.delete(),r}(this._texture,this._canvasWidth,this._canvasHeight,this._textureParameters||f)),this.onUpdate(),this._canvas=this._canvas||document.createElement("canvas"),this._loadIcons(i)}}_loadIcons(t){const e=this._canvas.getContext("2d",{willReadFrequently:!0});for(const i of t)this._pendingCount++,(0,p.z)(i.url,this._loadOptions).then((t=>{const n=v(i),o=this._mapping[n],{x:s,y:r,width:a,height:l}=o,{data:c,width:d,height:u}=m(e,t,a,l);this._texture.setSubImageData({data:c,x:s+(a-d)/2,y:r+(l-u)/2,width:d,height:u}),o.width=d,o.height=u,this._texture.generateMipmap(),this.onUpdate()})).catch((t=>{this.onError({url:i.url,source:i.source,sourceIndex:i.sourceIndex,loadOptions:this._loadOptions,error:t})})).finally((()=>{this._pendingCount--}))}}const w=[0,0,0,255],b={iconAtlas:{type:"image",value:null,async:!0},iconMapping:{type:"object",value:{},async:!0},sizeScale:{type:"number",value:1,min:0},billboard:!0,sizeUnits:"pixels",sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},alphaCutoff:{type:"number",value:.05,min:0,max:1},getPosition:{type:"accessor",value:t=>t.position},getIcon:{type:"accessor",value:t=>t.icon},getColor:{type:"accessor",value:w},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},onIconError:{type:"function",value:null,compare:!1,optional:!0}};class P extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME icon-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec4 instanceIconFrames;\nattribute float instanceColorModes;\nattribute vec2 instanceOffsets;\nattribute vec2 instancePixelOffset;\n\nuniform float sizeScale;\nuniform vec2 iconsTextureDim;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform bool billboard;\nuniform int sizeUnits;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = angle * PI / 180.0;\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n\n  vec2 iconSize = instanceIconFrames.zw;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits), \n    sizeMinPixels, sizeMaxPixels\n  );\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\n  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;\n  pixelOffset += instancePixelOffset;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position); \n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n\n  vTextureCoords = mix(\n    instanceIconFrames.xy,\n    instanceIconFrames.xy + iconSize,\n    (positions.xy + 1.0) / 2.0\n  ) / iconsTextureDim;\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n\n  vColorMode = instanceColorModes;\n}\n",fs:"#define SHADER_NAME icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float alphaCutoff;\n\nvarying float vColorMode;\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\n  float a = texColor.a * opacity * vColor.a;\n\n  if (a < alphaCutoff) {\n    discard;\n  }\n\n  gl_FragColor = vec4(color, a);\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}initializeState(){this.state={iconManager:new _(this.context.gl,{onUpdate:this._onUpdate.bind(this),onError:this._onError.bind(this)})};this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceOffsets:{size:2,accessor:"getIcon",transform:this.getInstanceOffset},instanceIconFrames:{size:4,accessor:"getIcon",transform:this.getInstanceIconFrame},instanceColorModes:{size:1,type:5121,accessor:"getIcon",transform:this.getInstanceColorMode},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:w},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instancePixelOffset:{size:2,transition:!0,accessor:"getPixelOffset"}})}updateState(t){super.updateState(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager(),{iconAtlas:s,iconMapping:r,data:a,getIcon:l,textureParameters:c}=e,{iconManager:d}=this.state,u=s||this.internalState.isAsyncPropLoading("iconAtlas");if(d.setProps({loadOptions:e.loadOptions,autoPacking:!u,iconAtlas:s,iconMapping:u?r:null,textureParameters:c}),u?i.iconMapping!==e.iconMapping&&o.invalidate("getIcon"):(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getIcon))&&d.packIcons(a,l),n.extensionsChanged){var p;const{gl:t}=this.context;null==(p=this.state.model)||p.delete(),this.state.model=this._getModel(t),o.invalidateAll()}}get isLoaded(){return super.isLoaded&&this.state.iconManager.isLoaded}finalizeState(t){super.finalizeState(t),this.state.iconManager.finalize()}draw(t){let{uniforms:e}=t;const{sizeScale:i,sizeMinPixels:n,sizeMaxPixels:o,sizeUnits:s,billboard:a,alphaCutoff:l}=this.props,{iconManager:c}=this.state,d=c.getTexture();d&&this.state.model.setUniforms(e).setUniforms({iconsTexture:d,iconsTextureDim:[d.width,d.height],sizeUnits:r.iI[s],sizeScale:i,sizeMinPixels:n,sizeMaxPixels:o,billboard:a,alphaCutoff:l}).draw()}_getModel(t){return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:6,attributes:{positions:{size:2,value:new Float32Array([-1,-1,-1,1,1,1,1,-1])}}}),isInstanced:!0})}_onUpdate(){this.setNeedsRedraw()}_onError(t){var e;const i=null==(e=this.getCurrentLayer())?void 0:e.props.onIconError;i?i(t):a.Z.error(t.error.message)()}getInstanceOffset(t){const{width:e,height:i,anchorX:n=e/2,anchorY:o=i/2}=this.state.iconManager.getIconMapping(t);return[e/2-n,i/2-o]}getInstanceColorMode(t){return this.state.iconManager.getIconMapping(t).mask?1:0}getInstanceIconFrame(t){const{x:e,y:i,width:n,height:o}=this.state.iconManager.getIconMapping(t);return[e,i,n,o]}}P.defaultProps=b,P.layerName="IconLayer"},16009:(t,e,i)=>{"use strict";i.d(e,{Z:()=>d});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(95321),l=i(15804);const c={getSourcePosition:{type:"accessor",value:t=>t.sourcePosition},getTargetPosition:{type:"accessor",value:t=>t.targetPosition},getColor:{type:"accessor",value:[0,0,0,255]},getWidth:{type:"accessor",value:1},widthUnits:"pixels",widthScale:{type:"number",value:1,min:0},widthMinPixels:{type:"number",value:0,min:0},widthMaxPixels:{type:"number",value:Number.MAX_SAFE_INTEGER,min:0}};class d extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME line-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceSourcePositions;\nattribute vec3 instanceTargetPositions;\nattribute vec3 instanceSourcePositions64Low;\nattribute vec3 instanceTargetPositions64Low;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute float instanceWidths;\n\nuniform float opacity;\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float useShortestPath;\nuniform int widthUnits;\n\nvarying vec4 vColor;\nvarying vec2 uv;\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {\n  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  return dir_screenspace * offset_direction * width / 2.0;\n}\n\nvec3 splitLine(vec3 a, vec3 b, float x) {\n  float t = (x - a.x) / (b.x - a.x);\n  return vec3(x, mix(a.yz, b.yz, t));\n}\n\nvoid main(void) {\n  geometry.worldPosition = instanceSourcePositions;\n  geometry.worldPositionAlt = instanceTargetPositions;\n\n  vec3 source_world = instanceSourcePositions;\n  vec3 target_world = instanceTargetPositions;\n  vec3 source_world_64low = instanceSourcePositions64Low;\n  vec3 target_world_64low = instanceTargetPositions64Low;\n\n  if (useShortestPath > 0.5 || useShortestPath < -0.5) {\n    source_world.x = mod(source_world.x + 180., 360.0) - 180.;\n    target_world.x = mod(target_world.x + 180., 360.0) - 180.;\n    float deltaLng = target_world.x - source_world.x;\n\n    if (deltaLng * useShortestPath > 180.) {\n      source_world.x += 360. * useShortestPath;\n      source_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      source_world_64low = vec3(0.0);\n    } else if (deltaLng * useShortestPath < -180.) {\n      target_world.x += 360. * useShortestPath;\n      target_world = splitLine(source_world, target_world, 180. * useShortestPath);\n      target_world_64low = vec3(0.0);\n    } else if (useShortestPath < 0.) {\n      gl_Position = vec4(0.);\n      return;\n    }\n  }\n  vec4 source_commonspace;\n  vec4 target_commonspace;\n  vec4 source = project_position_to_clipspace(source_world, source_world_64low, vec3(0.), source_commonspace);\n  vec4 target = project_position_to_clipspace(target_world, target_world_64low, vec3(0.), target_commonspace);\n  float segmentIndex = positions.x;\n  vec4 p = mix(source, target, segmentIndex);\n  geometry.position = mix(source_commonspace, target_commonspace, segmentIndex);\n  uv = positions.xy;\n  geometry.uv = uv;\n  geometry.pickingColor = instancePickingColors;\n  float widthPixels = clamp(\n    project_size_to_pixel(instanceWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels\n  );\n  vec3 offset = vec3(\n    getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels),\n    0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  DECKGL_FILTER_GL_POSITION(p, geometry);\n  gl_Position = p + vec4(project_pixel_size_to_clipspace(offset.xy), 0.0, 0.0);\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME line-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({instanceSourcePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getSourcePosition"},instanceTargetPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getTargetPosition"},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:[0,0,0,255]},instanceWidths:{size:1,transition:!0,accessor:"getWidth",defaultValue:1}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null==(e=this.state.model)||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{widthUnits:i,widthScale:n,widthMinPixels:o,widthMaxPixels:s,wrapLongitude:a}=this.props;this.state.model.setUniforms(e).setUniforms({widthUnits:r.iI[i],widthScale:n,widthMinPixels:o,widthMaxPixels:s,useShortestPath:a?1:0}).draw(),a&&this.state.model.setUniforms({useShortestPath:-1}).draw()}_getModel(t){return new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:5,attributes:{positions:new Float32Array([0,-1,0,0,1,0,1,-1,0,1,1,0])}}),isInstanced:!0})}}d.layerName="LineLayer",d.defaultProps=c},52329:(t,e,i)=>{"use strict";i.d(e,{Z:()=>m});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(95321),l=i(15804),c=i(68318),d=i(59021);class u extends c.Z{constructor(t){super({...t,attributes:{positions:{size:3,padding:18,initialize:!0,type:t.fp64?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray}}})}get(t){return this.attributes[t]}getGeometryFromBuffer(t){return this.normalize?super.getGeometryFromBuffer(t):null}normalizeGeometry(t){return this.normalize?function(t,e,i,n){let o;if(Array.isArray(t[0])){const i=t.length*e;o=new Array(i);for(let n=0;n<t.length;n++)for(let i=0;i<e;i++)o[n*e+i]=t[n][i]||0}else o=t;return i?(0,d.dj)(o,{size:e,gridResolution:i}):n?(0,d.ct)(o,{size:e}):o}(t,this.positionSize,this.opts.resolution,this.opts.wrapLongitude):t}getGeometrySize(t){if(p(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}const e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+2:e}updateGeometryAttributes(t,e){if(0!==e.geometrySize)if(t&&p(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t}else this._updateSegmentTypes(t,e),this._updatePositions(t,e)}_updateSegmentTypes(t,e){const i=this.attributes.segmentTypes,n=!!t&&this.isClosed(t),{vertexStart:o,geometrySize:s}=e;i.fill(0,o,o+s),n?(i[o]=4,i[o+s-2]=4):(i[o]+=1,i[o+s-2]+=2),i[o+s-1]=4}_updatePositions(t,e){const{positions:i}=this.attributes;if(!i||!t)return;const{vertexStart:n,geometrySize:o}=e,s=new Array(3);for(let r=n,a=0;a<o;r++,a++)this.getPointOnPath(t,a,s),i[3*r]=s[0],i[3*r+1]=s[1],i[3*r+2]=s[2]}getPathLength(t){return t.length/this.positionSize}getPointOnPath(t,e,i){void 0===i&&(i=[]);const{positionSize:n}=this;e*n>=t.length&&(e+=1-t.length/n);const o=e*n;return i[0]=t[o],i[1]=t[o+1],i[2]=3===n&&t[o+2]||0,i}isClosed(t){if(!this.normalize)return Boolean(this.opts.loop);const{positionSize:e}=this,i=t.length-e;return t[0]===t[i]&&t[1]===t[i+1]&&(2===e||t[2]===t[i+2])}}function p(t){return Array.isArray(t[0])}const h=[0,0,0,255],g={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},jointRounded:!1,capRounded:!1,miterLimit:{type:"number",min:0,value:4},billboard:!1,_pathType:null,getPath:{type:"accessor",value:t=>t.path},getColor:{type:"accessor",value:h},getWidth:{type:"accessor",value:1},rounded:{deprecatedFor:["jointRounded","capRounded"]}},f={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class m extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}get wrapLongitude(){return!1}initializeState(){this.getAttributeManager().addInstanced({positions:{size:3,vertexOffset:1,type:5130,fp64:this.use64bitPositions(),transition:f,accessor:"getPath",update:this.calculatePositions,noAlloc:true,shaderAttributes:{instanceLeftPositions:{vertexOffset:0},instanceStartPositions:{vertexOffset:1},instanceEndPositions:{vertexOffset:2},instanceRightPositions:{vertexOffset:3}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:true},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:f,defaultValue:1},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:f,defaultValue:h},instancePickingColors:{size:3,type:5121,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(t&&t.__source?t.__source.index:i,n)}}}),this.setState({pathTesselator:new u({fp64:this.use64bitPositions()})})}updateState(t){super.updateState(t);const{props:e,changeFlags:i}=t,n=this.getAttributeManager();if(i.dataChanged||i.updateTriggersChanged&&(i.updateTriggersChanged.all||i.updateTriggersChanged.getPath)){const{pathTesselator:t}=this.state,o=e.data.attributes||{};t.updateGeometry({data:e.data,geometryBuffer:o.getPath,buffers:o,normalize:!e._pathType,loop:"loop"===e._pathType,getGeometry:e.getPath,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,dataChanged:i.dataChanged}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),i.dataChanged||n.invalidateAll()}if(i.extensionsChanged){var o;const{gl:t}=this.context;null==(o=this.state.model)||o.delete(),this.state.model=this._getModel(t),n.invalidateAll()}}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw(t){let{uniforms:e}=t;const{jointRounded:i,capRounded:n,billboard:o,miterLimit:s,widthUnits:a,widthScale:l,widthMinPixels:c,widthMaxPixels:d}=this.props;this.state.model.setUniforms(e).setUniforms({jointType:Number(i),capType:Number(n),billboard:o,widthUnits:r.iI[a],widthScale:l,miterLimit:s,widthMinPixels:c,widthMaxPixels:d}).draw()}_getModel(t){return new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:4,attributes:{indices:new Uint16Array([0,1,2,1,4,2,1,3,4,3,5,4]),positions:{value:new Float32Array([0,0,0,-1,0,1,1,-1,1,1,1,0]),size:2}}}),isInstanced:!0})}calculatePositions(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateSegmentTypes(t){const{pathTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("segmentTypes")}}m.defaultProps=g,m.layerName="PathLayer"},76144:(t,e,i)=>{"use strict";i.d(e,{Z:()=>h});var n=i(47251),o=i(18056),s=i(89771),r=i(71693),a=i(43631),l=i(95321),c=i(15804);const d=[0,0,0,255],u=[0,0,1],p={sizeUnits:"pixels",pointSize:{type:"number",min:0,value:10},getPosition:{type:"accessor",value:t=>t.position},getNormal:{type:"accessor",value:u},getColor:{type:"accessor",value:d},material:!0,radiusPixels:{deprecatedFor:"pointSize"}};class h extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME point-cloud-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 instanceNormals;\nattribute vec4 instanceColors;\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusPixels;\nuniform int sizeUnits;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.normal = project_normal(instanceNormals);\n  unitPosition = positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);\n  vColor = vec4(lightColor, instanceColors.a * opacity);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",fs:"#define SHADER_NAME point-cloud-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\nvarying vec2 unitPosition;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition);\n\n  if (distToCenter > 1.0) {\n    discard;\n  }\n\n  gl_FragColor = vColor;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.N,r.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceNormals:{size:3,transition:!0,accessor:"getNormal",defaultValue:u},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:!0,accessor:"getColor",defaultValue:d}})}updateState(t){const{changeFlags:e,props:i}=t;if(super.updateState(t),e.extensionsChanged){var n;const{gl:t}=this.context;null==(n=this.state.model)||n.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}e.dataChanged&&function(t){const{header:e,attributes:i}=t;e&&i&&(t.length=e.vertexCount,i.POSITION&&(i.instancePositions=i.POSITION),i.NORMAL&&(i.instanceNormals=i.NORMAL),i.COLOR_0&&(i.instanceColors=i.COLOR_0))}(i.data)}draw(t){let{uniforms:e}=t;const{pointSize:i,sizeUnits:n}=this.props;this.state.model.setUniforms(e).setUniforms({sizeUnits:a.iI[n],radiusPixels:i}).draw()}_getModel(t){const e=[];for(let i=0;i<3;i++){const t=i/3*Math.PI*2;e.push(2*Math.cos(t),2*Math.sin(t),0)}return new l.Z(t,{...this.getShaders(),id:this.props.id,geometry:new c.Z({drawMode:4,attributes:{positions:new Float32Array(e)}}),isInstanced:!0})}}h.layerName="PointCloudLayer",h.defaultProps=p},48148:(t,e,i)=>{"use strict";i.d(e,{Z:()=>p});var n=i(19871),o=i(89745),s=i(37944),r=i(57654),a=i(52329),l=i(91793),c=i(46025);const d=[0,0,0,255],u={stroked:!0,filled:!0,extruded:!1,elevationScale:1,wireframe:!1,_normalize:!0,_windingOrder:"CW",lineWidthUnits:"meters",lineWidthScale:1,lineWidthMinPixels:0,lineWidthMaxPixels:Number.MAX_SAFE_INTEGER,lineJointRounded:!1,lineMiterLimit:4,getPolygon:{type:"accessor",value:t=>t.polygon},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:d},getLineWidth:{type:"accessor",value:1},getElevation:{type:"accessor",value:1e3},material:!0};class p extends n.Z{initializeState(){this.state={paths:[]},this.props.getLineDashArray&&o.Z.removed("getLineDashArray","PathStyleExtension")()}updateState(t){let{changeFlags:e}=t;const i=e.dataChanged||e.updateTriggersChanged&&(e.updateTriggersChanged.all||e.updateTriggersChanged.getPolygon);if(i&&Array.isArray(e.dataChanged)){const t=this.state.paths.slice(),i=e.dataChanged.map((e=>(0,c.b)({data:t,getIndex:t=>t.__source.index,dataRange:e,replace:this._getPaths(e)})));this.setState({paths:t,pathsDiff:i})}else i&&this.setState({paths:this._getPaths(),pathsDiff:null})}_getPaths(t){void 0===t&&(t={});const{data:e,getPolygon:i,positionFormat:n,_normalize:o}=this.props,r=[],a="XY"===n?2:3,{startRow:c,endRow:d}=t,{iterable:u,objectInfo:p}=(0,s.jB)(e,c,d);for(const s of u){p.index++;let t=i(s,p);o&&(t=l.Fv(t,a));const{holeIndices:e}=t,n=t.positions||t;if(e)for(let i=0;i<=e.length;i++){const t=n.slice(e[i-1]||0,e[i]||n.length);r.push(this.getSubLayerRow({path:t},s,p.index))}else r.push(this.getSubLayerRow({path:n},s,p.index))}return r}renderLayers(){const{data:t,_dataDiff:e,stroked:i,filled:n,extruded:o,wireframe:s,_normalize:l,_windingOrder:c,elevationScale:u,transitions:p,positionFormat:h}=this.props,{lineWidthUnits:g,lineWidthScale:f,lineWidthMinPixels:m,lineWidthMaxPixels:v,lineJointRounded:y,lineMiterLimit:_,lineDashJustified:w}=this.props,{getFillColor:b,getLineColor:P,getLineWidth:x,getLineDashArray:C,getElevation:S,getPolygon:L,updateTriggers:M,material:k}=this.props,{paths:T,pathsDiff:E}=this.state,I=this.getSubLayerClass("fill",r.Z),A=this.getSubLayerClass("stroke",a.Z),O=this.shouldRenderSubLayer("fill",T)&&new I({_dataDiff:e,extruded:o,elevationScale:u,filled:n,wireframe:s,_normalize:l,_windingOrder:c,getElevation:S,getFillColor:b,getLineColor:o&&s?P:d,material:k,transitions:p},this.getSubLayerProps({id:"fill",updateTriggers:M&&{getPolygon:M.getPolygon,getElevation:M.getElevation,getFillColor:M.getFillColor,lineColors:o&&s,getLineColor:M.getLineColor}}),{data:t,positionFormat:h,getPolygon:L});return[!o&&O,!o&&i&&this.shouldRenderSubLayer("stroke",T)&&new A({_dataDiff:E&&(()=>E),widthUnits:g,widthScale:f,widthMinPixels:m,widthMaxPixels:v,jointRounded:y,miterLimit:_,dashJustified:w,_pathType:"loop",transitions:p&&{getWidth:p.getLineWidth,getColor:p.getLineColor,getPath:p.getPolygon},getColor:this.getSubLayerAccessor(P),getWidth:this.getSubLayerAccessor(x),getDashArray:this.getSubLayerAccessor(C)},this.getSubLayerProps({id:"stroke",updateTriggers:M&&{getWidth:M.getLineWidth,getColor:M.getLineColor,getDashArray:M.getLineDashArray}}),{data:T,positionFormat:h,getPath:t=>t.path}),o&&O]}}p.layerName="PolygonLayer",p.defaultProps=u},24309:(t,e,i)=>{"use strict";i.d(e,{Z:()=>u});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(95321),l=i(15804);const c=[0,0,0,255],d={radiusUnits:"meters",radiusScale:{type:"number",min:0,value:1},radiusMinPixels:{type:"number",min:0,value:0},radiusMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},lineWidthUnits:"meters",lineWidthScale:{type:"number",min:0,value:1},lineWidthMinPixels:{type:"number",min:0,value:0},lineWidthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},stroked:!1,filled:!0,billboard:!1,antialiasing:!0,getPosition:{type:"accessor",value:t=>t.position},getRadius:{type:"accessor",value:1},getFillColor:{type:"accessor",value:c},getLineColor:{type:"accessor",value:c},getLineWidth:{type:"accessor",value:1},strokeWidth:{deprecatedFor:"getLineWidth"},outline:{deprecatedFor:"stroked"},getColor:{deprecatedFor:["getFillColor","getLineColor"]}};class u extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME scatterplot-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute float instanceRadius;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform float opacity;\nuniform float radiusScale;\nuniform float radiusMinPixels;\nuniform float radiusMaxPixels;\nuniform float lineWidthScale;\nuniform float lineWidthMinPixels;\nuniform float lineWidthMaxPixels;\nuniform float stroked;\nuniform bool filled;\nuniform bool antialiasing;\nuniform bool billboard;\nuniform int radiusUnits;\nuniform int lineWidthUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  outerRadiusPixels = clamp(\n    project_size_to_pixel(radiusScale * instanceRadius, radiusUnits),\n    radiusMinPixels, radiusMaxPixels\n  );\n  float lineWidthPixels = clamp(\n    project_size_to_pixel(lineWidthScale * instanceLineWidths, lineWidthUnits),\n    lineWidthMinPixels, lineWidthMaxPixels\n  );\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\n  float edgePadding = antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\n  unitPosition = edgePadding * positions.xy;\n  geometry.uv = unitPosition;\n  geometry.pickingColor = instancePickingColors;\n\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\n  \n  if (billboard) {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = edgePadding * positions * outerRadiusPixels;\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME scatterplot-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool filled;\nuniform float stroked;\nuniform bool antialiasing;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying vec2 unitPosition;\nvarying float innerUnitRadius;\nvarying float outerRadiusPixels;\n\nvoid main(void) {\n  geometry.uv = unitPosition;\n\n  float distToCenter = length(unitPosition) * outerRadiusPixels;\n  float inCircle = antialiasing ? \n    smoothedge(distToCenter, outerRadiusPixels) : \n    step(distToCenter, outerRadiusPixels);\n\n  if (inCircle == 0.0) {\n    discard;\n  }\n\n  if (stroked > 0.5) {\n    float isLine = antialiasing ? \n      smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\n      step(innerUnitRadius * outerRadiusPixels, distToCenter);\n\n    if (filled) {\n      gl_FragColor = mix(vFillColor, vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        discard;\n      }\n      gl_FragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n    }\n  } else if (filled) {\n    gl_FragColor = vFillColor;\n  } else {\n    discard;\n  }\n\n  gl_FragColor.a *= inCircle;\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceRadius:{size:1,transition:!0,accessor:"getRadius",defaultValue:1},instanceFillColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:this.props.colorFormat.length,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){if(super.updateState(t),t.changeFlags.extensionsChanged){var e;const{gl:t}=this.context;null==(e=this.state.model)||e.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{radiusUnits:i,radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,stroked:a,filled:l,billboard:c,antialiasing:d,lineWidthUnits:u,lineWidthScale:p,lineWidthMinPixels:h,lineWidthMaxPixels:g}=this.props;this.state.model.setUniforms(e).setUniforms({stroked:a?1:0,filled:l,billboard:c,antialiasing:d,radiusUnits:r.iI[i],radiusScale:n,radiusMinPixels:o,radiusMaxPixels:s,lineWidthUnits:r.iI[u],lineWidthScale:p,lineWidthMinPixels:h,lineWidthMaxPixels:g}).draw()}_getModel(t){return new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:3,value:new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,1,0])}}}),isInstanced:!0})}}u.defaultProps=d,u.layerName="ScatterplotLayer"},91793:(t,e,i)=>{"use strict";i.d(e,{Fv:()=>h,Gd:()=>d,k8:()=>c,mD:()=>m});var n=i(9187),o=i.n(n),s=i(59021);const r=s.wG.CLOCKWISE,a=s.wG.COUNTER_CLOCKWISE,l={isClosed:!0};function c(t){return"positions"in t?t.positions:t}function d(t){return"holeIndices"in t?t.holeIndices:null}function u(t,e,i,n,o){let r=e;const a=i.length;for(let s=0;s<a;s++)for(let e=0;e<n;e++)t[r++]=i[s][e]||0;if(!function(t){const e=t[0],i=t[t.length-1];return e[0]===i[0]&&e[1]===i[1]&&e[2]===i[2]}(i))for(let s=0;s<n;s++)t[r++]=i[0][s]||0;return l.start=e,l.end=r,l.size=n,(0,s.Ny)(t,o,l),r}function p(t,e,i,n,o,r,a){void 0===o&&(o=0);const c=(r=r||i.length)-o;if(c<=0)return e;let d=e;for(let s=0;s<c;s++)t[d++]=i[o+s];if(!function(t,e,i,n){for(let o=0;o<e;o++)if(t[i+o]!==t[n-e+o])return!1;return!0}(i,n,o,r))for(let s=0;s<n;s++)t[d++]=i[o+s];return l.start=e,l.end=d,l.size=n,(0,s.Ny)(t,a,l),d}function h(t,e){!function(t){if(t=t&&t.positions||t,!Array.isArray(t)&&!ArrayBuffer.isView(t))throw new Error("invalid polygon")}(t);const i=[],n=[];if("positions"in t){const{positions:o,holeIndices:s}=t;if(s){let t=0;for(let l=0;l<=s.length;l++)t=p(i,t,o,e,s[l-1],s[l],0===l?r:a),n.push(t);return n.pop(),{positions:i,holeIndices:n}}t=o}if(!function(t){return Array.isArray(t[0])}(t))return p(i,0,t,e,0,i.length,r),i;if(!function(t){return t.length>=1&&t[0].length>=2&&Number.isFinite(t[0][0])}(t)){let o=0;for(const[s,l]of t.entries())o=u(i,o,l,e,0===s?r:a),n.push(o);return n.pop(),{positions:i,holeIndices:n}}return u(i,0,t,e,r),i}function g(t,e,i){const n=t.length/3;let o=0;for(let s=0;s<n;s++){const r=(s+1)%n;o+=t[3*s+e]*t[3*r+i],o-=t[3*r+e]*t[3*s+i]}return Math.abs(o/2)}function f(t,e,i,n){const o=t.length/3;for(let s=0;s<o;s++){const o=3*s,r=t[o+0],a=t[o+1],l=t[o+2];t[o+e]=r,t[o+i]=a,t[o+n]=l}}function m(t,e,i,n){let s=d(t);s&&(s=s.map((t=>t/e)));let r=c(t);const a=n&&3===e;if(i){const t=r.length;r=r.slice();const n=[];for(let o=0;o<t;o+=e){n[0]=r[o],n[1]=r[o+1],a&&(n[2]=r[o+2]);const t=i(n);r[o]=t[0],r[o+1]=t[1],a&&(r[o+2]=t[2])}}if(a){const t=g(r,0,1),e=g(r,0,2),n=g(r,1,2);if(!t&&!e&&!n)return[];t>e&&t>n||(e>n?(i||(r=r.slice()),f(r,0,2,1)):(i||(r=r.slice()),f(r,1,2,0)))}return o()(r,s,e)}},57654:(t,e,i)=>{"use strict";i.d(e,{Z:()=>x});var n=i(47251),o=i(18056),s=i(89771),r=i(71693),a=i(43631),l=i(19227),c=i(83757),d=i(95321),u=i(15804),p=i(91793),h=i(68318),g=i(59021);class f extends h.Z{constructor(t){const{fp64:e,IndexType:i=Uint32Array}=t;super({...t,attributes:{positions:{size:3,type:e?Float64Array:Float32Array},vertexValid:{type:Uint8ClampedArray,size:1},indices:{type:i,size:1}}})}get(t){const{attributes:e}=this;return"indices"===t?e.indices&&e.indices.subarray(0,this.vertexCount):e[t]}updateGeometry(t){super.updateGeometry(t);const e=this.buffers.indices;if(e)this.vertexCount=(e.value||e).length;else if(this.data&&!this.getGeometry)throw new Error("missing indices buffer")}normalizeGeometry(t){if(this.normalize){const e=p.Fv(t,this.positionSize);return this.opts.resolution?(0,g.WZ)(p.k8(e),p.Gd(e),{size:this.positionSize,gridResolution:this.opts.resolution,edgeTypes:!0}):this.opts.wrapLongitude?(0,g.GU)(p.k8(e),p.Gd(e),{size:this.positionSize,maxLatitude:86,edgeTypes:!0}):e}return t}getGeometrySize(t){if(m(t)){let e=0;for(const i of t)e+=this.getGeometrySize(i);return e}return p.k8(t).length/this.positionSize}getGeometryFromBuffer(t){return this.normalize||!this.buffers.indices?super.getGeometryFromBuffer(t):null}updateGeometryAttributes(t,e){if(t&&m(t))for(const i of t){const t=this.getGeometrySize(i);e.geometrySize=t,this.updateGeometryAttributes(i,e),e.vertexStart+=t,e.indexStart=this.indexStarts[e.geometryIndex+1]}else this._updateIndices(t,e),this._updatePositions(t,e),this._updateVertexValid(t,e)}_updateIndices(t,e){let{geometryIndex:i,vertexStart:n,indexStart:o}=e;const{attributes:s,indexStarts:r,typedArrayManager:a}=this;let l=s.indices;if(!l||!t)return;let c=o;const d=p.mD(t,this.positionSize,this.opts.preproject,this.opts.full3d);l=a.allocate(l,o+d.length,{copy:!0});for(let u=0;u<d.length;u++)l[c++]=d[u]+n;r[i+1]=o+d.length,s.indices=l}_updatePositions(t,e){let{vertexStart:i,geometrySize:n}=e;const{attributes:{positions:o},positionSize:s}=this;if(!o||!t)return;const r=p.k8(t);for(let a=i,l=0;l<n;a++,l++){const t=r[l*s],e=r[l*s+1],i=s>2?r[l*s+2]:0;o[3*a]=t,o[3*a+1]=e,o[3*a+2]=i}}_updateVertexValid(t,e){let{vertexStart:i,geometrySize:n}=e;const{positionSize:o}=this,s=this.attributes.vertexValid,r=t&&p.Gd(t);if(t&&t.edgeTypes?s.set(t.edgeTypes,i):s.fill(1,i,i+n),r)for(let a=0;a<r.length;a++)s[i+r[a]/o-1]=0;s[i+n-1]=0}}function m(t){return Array.isArray(t)&&t.length>0&&!Number.isFinite(t[0])}const v="\nattribute vec2 vertexPositions;\nattribute float vertexValid;\n\nuniform bool extruded;\nuniform bool isWireframe;\nuniform float elevationScale;\nuniform float opacity;\n\nvarying vec4 vColor;\n\nstruct PolygonProps {\n  vec4 fillColors;\n  vec4 lineColors;\n  vec3 positions;\n  vec3 nextPositions;\n  vec3 pickingColors;\n  vec3 positions64Low;\n  vec3 nextPositions64Low;\n  float elevations;\n};\n\nvec3 project_offset_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\n  }\n  return project_normal(vector);\n}\n\nvoid calculatePosition(PolygonProps props) {\n#ifdef IS_SIDE_VERTEX\n  if(vertexValid < 0.5){\n    gl_Position = vec4(0.);\n    return;\n  }\n#endif\n\n  vec3 pos;\n  vec3 pos64Low;\n  vec3 normal;\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\n\n  geometry.worldPosition = props.positions;\n  geometry.worldPositionAlt = props.nextPositions;\n  geometry.pickingColor = props.pickingColors;\n\n#ifdef IS_SIDE_VERTEX\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\n  pos64Low = mix(props.positions64Low, props.nextPositions64Low, vertexPositions.x);\n#else\n  pos = props.positions;\n  pos64Low = props.positions64Low;\n#endif\n\n  if (extruded) {\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\n  }\n  gl_Position = project_position_to_clipspace(pos, pos64Low, vec3(0.), geometry.position);\n\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  if (extruded) {\n  #ifdef IS_SIDE_VERTEX\n    normal = vec3(\n      props.positions.y - props.nextPositions.y + (props.positions64Low.y - props.nextPositions64Low.y),\n      props.nextPositions.x - props.positions.x + (props.nextPositions64Low.x - props.positions64Low.x),\n      0.0);\n    normal = project_offset_normal(normal);\n  #else\n    normal = project_normal(vec3(0.0, 0.0, 1.0));\n  #endif\n    geometry.normal = normal;\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, geometry.position.xyz, normal);\n    vColor = vec4(lightColor, colors.a * opacity);\n  } else {\n    vColor = vec4(colors.rgb, colors.a * opacity);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",y="#define SHADER_NAME solid-polygon-layer-vertex-shader\n\nattribute vec3 positions;\nattribute vec3 positions64Low;\nattribute float elevations;\nattribute vec4 fillColors;\nattribute vec4 lineColors;\nattribute vec3 pickingColors;\n\n"+v+"\n\nvoid main(void) {\n  PolygonProps props;\n\n  props.positions = positions;\n  props.positions64Low = positions64Low;\n  props.elevations = elevations;\n  props.fillColors = fillColors;\n  props.lineColors = lineColors;\n  props.pickingColors = pickingColors;\n\n  calculatePosition(props);\n}\n",_="#define SHADER_NAME solid-polygon-layer-vertex-shader-side\n#define IS_SIDE_VERTEX\n\n\nattribute vec3 instancePositions;\nattribute vec3 nextPositions;\nattribute vec3 instancePositions64Low;\nattribute vec3 nextPositions64Low;\nattribute float instanceElevations;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\n"+v+"\n\nvoid main(void) {\n  PolygonProps props;\n\n  #if RING_WINDING_ORDER_CW == 1\n    props.positions = instancePositions;\n    props.positions64Low = instancePositions64Low;\n    props.nextPositions = nextPositions;\n    props.nextPositions64Low = nextPositions64Low;\n  #else\n    props.positions = nextPositions;\n    props.positions64Low = nextPositions64Low;\n    props.nextPositions = instancePositions;\n    props.nextPositions64Low = instancePositions64Low;\n  #endif\n  props.elevations = instanceElevations;\n  props.fillColors = instanceFillColors;\n  props.lineColors = instanceLineColors;\n  props.pickingColors = instancePickingColors;\n\n  calculatePosition(props);\n}\n",w=[0,0,0,255],b={filled:!0,extruded:!1,wireframe:!1,_normalize:!0,_windingOrder:"CW",_full3d:!1,elevationScale:{type:"number",min:0,value:1},getPolygon:{type:"accessor",value:t=>t.polygon},getElevation:{type:"accessor",value:1e3},getFillColor:{type:"accessor",value:w},getLineColor:{type:"accessor",value:w},material:!0},P={enter:(t,e)=>e.length?e.subarray(e.length-t.length):t};class x extends n.Z{getShaders(t){return super.getShaders({vs:"top"===t?y:_,fs:"#define SHADER_NAME solid-polygon-layer-fragment-shader\n\nprecision highp float;\n\nvarying vec4 vColor;\n\nvoid main(void) {\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",defines:{RING_WINDING_ORDER_CW:this.props._normalize||"CCW"!==this.props._windingOrder?1:0},modules:[o.Z,s.N,r.Z]})}get wrapLongitude(){return!1}initializeState(){const{gl:t,viewport:e}=this.context;let{coordinateSystem:i}=this.props;const{_full3d:n}=this.props;let o;e.isGeospatial&&i===a.Df.DEFAULT&&(i=a.Df.LNGLAT),i===a.Df.LNGLAT&&(o=n?e.projectPosition.bind(e):e.projectFlat.bind(e)),this.setState({numInstances:0,polygonTesselator:new f({preproject:o,fp64:this.use64bitPositions(),IndexType:!t||(0,l.ag)(t,c.h.ELEMENT_INDEX_UINT32)?Uint32Array:Uint16Array})});const s=this.getAttributeManager(),r=!0;s.remove(["instancePickingColors"]),s.add({indices:{size:1,isIndexed:!0,update:this.calculateIndices,noAlloc:r},positions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:P,accessor:"getPolygon",update:this.calculatePositions,noAlloc:r,shaderAttributes:{positions:{vertexOffset:0,divisor:0},instancePositions:{vertexOffset:0,divisor:1},nextPositions:{vertexOffset:1,divisor:1}}},vertexValid:{size:1,divisor:1,type:5121,update:this.calculateVertexValid,noAlloc:r},elevations:{size:1,transition:P,accessor:"getElevation",shaderAttributes:{elevations:{divisor:0},instanceElevations:{divisor:1}}},fillColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:P,accessor:"getFillColor",defaultValue:w,shaderAttributes:{fillColors:{divisor:0},instanceFillColors:{divisor:1}}},lineColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,transition:P,accessor:"getLineColor",defaultValue:w,shaderAttributes:{lineColors:{divisor:0},instanceLineColors:{divisor:1}}},pickingColors:{size:3,type:5121,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(t&&t.__source?t.__source.index:i,n)},shaderAttributes:{pickingColors:{divisor:0},instancePickingColors:{divisor:1}}}})}getPickingInfo(t){const e=super.getPickingInfo(t),{index:i}=e,{data:n}=this.props;return n[0]&&n[0].__source&&(e.object=n.find((t=>t.__source.index===i))),e}disablePickingIndex(t){const{data:e}=this.props;if(e[0]&&e[0].__source)for(let i=0;i<e.length;i++)e[i].__source.index===t&&this._disablePickingIndex(i);else this._disablePickingIndex(t)}draw(t){let{uniforms:e}=t;const{extruded:i,filled:n,wireframe:o,elevationScale:s}=this.props,{topModel:r,sideModel:a,polygonTesselator:l}=this.state,c={...e,extruded:Boolean(i),elevationScale:s};a&&(a.setInstanceCount(l.instanceCount-1),a.setUniforms(c),o&&(a.setDrawMode(3),a.setUniforms({isWireframe:!0}).draw()),n&&(a.setDrawMode(6),a.setUniforms({isWireframe:!1}).draw())),r&&(r.setVertexCount(l.vertexCount),r.setUniforms(c).draw())}updateState(t){super.updateState(t),this.updateGeometry(t);const{props:e,oldProps:i,changeFlags:n}=t,o=this.getAttributeManager();var s;(n.extensionsChanged||e.filled!==i.filled||e.extruded!==i.extruded)&&(null==(s=this.state.models)||s.forEach((t=>t.delete())),this.setState(this._getModels(this.context.gl)),o.invalidateAll())}updateGeometry(t){let{props:e,oldProps:i,changeFlags:n}=t;if(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getPolygon)){const{polygonTesselator:t}=this.state,i=e.data.attributes||{};t.updateGeometry({data:e.data,normalize:e._normalize,geometryBuffer:i.getPolygon,buffers:i,getGeometry:e.getPolygon,positionFormat:e.positionFormat,wrapLongitude:e.wrapLongitude,resolution:this.context.viewport.resolution,fp64:this.use64bitPositions(),dataChanged:n.dataChanged,full3d:e._full3d}),this.setState({numInstances:t.instanceCount,startIndices:t.vertexStarts}),n.dataChanged||this.getAttributeManager().invalidateAll()}}_getModels(t){const{id:e,filled:i,extruded:n}=this.props;let o,s;if(i){const i=this.getShaders("top");i.defines.NON_INSTANCED_MODEL=1,o=new d.Z(t,{...i,id:e+"-top",drawMode:4,attributes:{vertexPositions:new Float32Array([0,1])},uniforms:{isWireframe:!1,isSideVertex:!1},vertexCount:0,isIndexed:!0})}return n&&(s=new d.Z(t,{...this.getShaders("side"),id:e+"-side",geometry:new u.Z({drawMode:1,vertexCount:4,attributes:{vertexPositions:{size:2,value:new Float32Array([1,0,0,0,0,1,1,1])}}}),instanceCount:0,isInstanced:1}),s.userData.excludeAttributes={indices:!0}),{models:[s,o].filter(Boolean),topModel:o,sideModel:s}}calculateIndices(t){const{polygonTesselator:e}=this.state;t.startIndices=e.indexStarts,t.value=e.get("indices")}calculatePositions(t){const{polygonTesselator:e}=this.state;t.startIndices=e.vertexStarts,t.value=e.get("positions")}calculateVertexValid(t){t.value=this.state.polygonTesselator.get("vertexValid")}}x.defaultProps=b,x.layerName="SolidPolygonLayer"},38017:(t,e,i)=>{"use strict";i.d(e,{Z:()=>a});var n=i(89745),o=i(6735);const s=.75,r=[];class a extends o.Z{getShaders(){return{...super.getShaders(),fs:"#define SHADER_NAME multi-icon-layer-fragment-shader\n\nprecision highp float;\n\nuniform float opacity;\nuniform sampler2D iconsTexture;\nuniform float gamma;\nuniform bool sdf;\nuniform float alphaCutoff;\nuniform float buffer;\nuniform float outlineBuffer;\nuniform vec4 outlineColor;\n\nvarying vec4 vColor;\nvarying vec2 vTextureCoords;\nvarying vec2 uv;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  if (!picking_uActive) {\n    float alpha = texture2D(iconsTexture, vTextureCoords).a;\n    vec4 color = vColor;\n    if (sdf) {\n      float distance = alpha;\n      alpha = smoothstep(buffer - gamma, buffer + gamma, distance);\n\n      if (outlineBuffer > 0.0) {\n        float inFill = alpha;\n        float inBorder = smoothstep(outlineBuffer - gamma, outlineBuffer + gamma, distance);\n        color = mix(outlineColor, vColor, inFill);\n        alpha = inBorder;\n      }\n    }\n    float a = alpha * color.a;\n    \n    if (a < alphaCutoff) {\n      discard;\n    }\n\n    gl_FragColor = vec4(color.rgb, a * opacity);\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n"}}initializeState(){super.initializeState();this.getAttributeManager().addInstanced({instanceOffsets:{size:2,accessor:"getIconOffsets"},instancePickingColors:{type:5121,size:3,accessor:(t,e)=>{let{index:i,target:n}=e;return this.encodePickingColor(i,n)}}})}updateState(t){super.updateState(t);const{props:e,oldProps:i}=t;let{outlineColor:o}=e;o!==i.outlineColor&&(o=o.map((t=>t/255)),o[3]=Number.isFinite(o[3])?o[3]:1,this.setState({outlineColor:o})),!e.sdf&&e.outlineWidth&&n.Z.warn(this.id+": fontSettings.sdf is required to render outline")()}draw(t){const{sdf:e,smoothing:i,outlineWidth:n}=this.props,{outlineColor:o}=this.state,r=n?Math.max(i,s*(1-n)):-1;if(t.uniforms={...t.uniforms,buffer:s,outlineBuffer:r,gamma:i,sdf:Boolean(e),outlineColor:o},super.draw(t),e&&n){const{iconManager:t}=this.state;t.getTexture()&&this.state.model.draw({uniforms:{outlineBuffer:s}})}}getInstanceOffset(t){return t?Array.from(t).flatMap((t=>super.getInstanceOffset(t))):r}getInstanceColorMode(t){return 1}getInstanceIconFrame(t){return t?Array.from(t).flatMap((t=>super.getInstanceIconFrame(t))):r}}a.defaultProps={getIconOffsets:{type:"accessor",value:t=>t.offsets},alphaCutoff:.001,smoothing:.1,outlineWidth:0,outlineColor:{type:"color",value:[0,0,0,255]}},a.layerName="MultiIconLayer"},17495:(t,e,i)=>{"use strict";i.d(e,{Z:()=>d});var n=i(47251),o=i(18056),s=i(71693),r=i(43631),a=i(95321),l=i(15804);const c={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,padding:{type:"array",value:[0,0,0,0]},getPosition:{type:"accessor",value:t=>t.position},getSize:{type:"accessor",value:1},getAngle:{type:"accessor",value:0},getPixelOffset:{type:"accessor",value:[0,0]},getBoundingRect:{type:"accessor",value:[0,0,0,0]},getFillColor:{type:"accessor",value:[0,0,0,255]},getLineColor:{type:"accessor",value:[0,0,0,255]},getLineWidth:{type:"accessor",value:1}};class d extends n.Z{getShaders(){return super.getShaders({vs:"#define SHADER_NAME text-background-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute vec3 instancePositions;\nattribute vec3 instancePositions64Low;\nattribute vec4 instanceRects;\nattribute float instanceSizes;\nattribute float instanceAngles;\nattribute vec2 instancePixelOffsets;\nattribute float instanceLineWidths;\nattribute vec4 instanceFillColors;\nattribute vec4 instanceLineColors;\nattribute vec3 instancePickingColors;\n\nuniform bool billboard;\nuniform float opacity;\nuniform float sizeScale;\nuniform float sizeMinPixels;\nuniform float sizeMaxPixels;\nuniform vec4 padding;\nuniform int sizeUnits;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvec2 rotate_by_angle(vec2 vertex, float angle) {\n  float angle_radian = radians(angle);\n  float cos_angle = cos(angle_radian);\n  float sin_angle = sin(angle_radian);\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\n  return rotationMatrix * vertex;\n}\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = positions;\n  geometry.pickingColor = instancePickingColors;\n  uv = positions;\n  vLineWidth = instanceLineWidths;\n  float sizePixels = clamp(\n    project_size_to_pixel(instanceSizes * sizeScale, sizeUnits),\n    sizeMinPixels, sizeMaxPixels\n  );\n\n  dimensions = instanceRects.zw * sizePixels + padding.xy + padding.zw;\n\n  vec2 pixelOffset = (positions * instanceRects.zw + instanceRects.xy) * sizePixels + mix(-padding.xy, padding.zw, positions);\n  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles);\n  pixelOffset += instancePixelOffsets;\n  pixelOffset.y *= -1.0;\n\n  if (billboard)  {\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n    vec3 offset = vec3(pixelOffset, 0.0);\n    DECKGL_FILTER_SIZE(offset, geometry);\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n  } else {\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\n    DECKGL_FILTER_SIZE(offset_common, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset_common, geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity);\n  DECKGL_FILTER_COLOR(vFillColor, geometry);\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity);\n  DECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n",fs:"#define SHADER_NAME text-background-layer-fragment-shader\n\nprecision highp float;\n\nuniform bool stroked;\n\nvarying vec4 vFillColor;\nvarying vec4 vLineColor;\nvarying float vLineWidth;\nvarying vec2 uv;\nvarying vec2 dimensions;\n\nvoid main(void) {\n  geometry.uv = uv;\n\n  vec2 pixelPosition = uv * dimensions;\n  if (stroked) {\n    float distToEdge = min(\n      min(pixelPosition.x, dimensions.x - pixelPosition.x),\n      min(pixelPosition.y, dimensions.y - pixelPosition.y)\n    );\n    float isBorder = smoothedge(distToEdge, vLineWidth);\n    gl_FragColor = mix(vFillColor, vLineColor, isBorder);\n  } else {\n    gl_FragColor = vFillColor;\n  }\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n",modules:[o.Z,s.Z]})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:!0,accessor:"getPosition"},instanceSizes:{size:1,transition:!0,accessor:"getSize",defaultValue:1},instanceAngles:{size:1,transition:!0,accessor:"getAngle"},instanceRects:{size:4,accessor:"getBoundingRect"},instancePixelOffsets:{size:2,transition:!0,accessor:"getPixelOffset"},instanceFillColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getFillColor",defaultValue:[0,0,0,255]},instanceLineColors:{size:4,transition:!0,normalized:!0,type:5121,accessor:"getLineColor",defaultValue:[0,0,0,255]},instanceLineWidths:{size:1,transition:!0,accessor:"getLineWidth",defaultValue:1}})}updateState(t){super.updateState(t);const{changeFlags:e}=t;if(e.extensionsChanged){var i;const{gl:t}=this.context;null==(i=this.state.model)||i.delete(),this.state.model=this._getModel(t),this.getAttributeManager().invalidateAll()}}draw(t){let{uniforms:e}=t;const{billboard:i,sizeScale:n,sizeUnits:o,sizeMinPixels:s,sizeMaxPixels:a,getLineWidth:l}=this.props;let{padding:c}=this.props;c.length<4&&(c=[c[0],c[1],c[0],c[1]]),this.state.model.setUniforms(e).setUniforms({billboard:i,stroked:Boolean(l),padding:c,sizeUnits:r.iI[o],sizeScale:n,sizeMinPixels:s,sizeMaxPixels:a}).draw()}_getModel(t){return new a.Z(t,{...this.getShaders(),id:this.props.id,geometry:new l.Z({drawMode:6,vertexCount:4,attributes:{positions:{size:2,value:new Float32Array([0,0,1,0,1,1,0,1])}}}),isInstanced:!0})}}d.defaultProps=c,d.layerName="TextBackgroundLayer"},27800:(t,e,i)=>{"use strict";i.d(e,{Z:()=>M});var n=i(19871),o=i(37944),s=i(38017),r=i(39875),a=i(89745);const l=32,c=[];function d(t,e,i,n){let o=0;for(let r=e;r<i;r++){var s;o+=(null==(s=n[t[r]])?void 0:s.layoutWidth)||0}return o}function u(t,e,i,n,o,s){let r=e,a=0;for(let l=e;l<i;l++){const e=d(t,l,l+1,o);a+e>n&&(r<l&&s.push(l),r=l,a=0),a+=e}return a}function p(t,e,i,n,o,s){void 0===o&&(o=0),void 0===s&&(s=t.length);const r=[];return"break-all"===e?u(t,o,s,i,n,r):function(t,e,i,n,o,s){let r=e,a=e,l=e,c=0;for(let p=e;p<i;p++)if(" "===t[p]?l=p+1:" "!==t[p+1]&&p+1!==i||(l=p+1),l>a){let e=d(t,a,l,o);c+e>n&&(r<a&&(s.push(a),r=a,c=0),e>n&&(e=u(t,a,l,n,o,s),r=s[s.length-1])),a=l,c+=e}}(t,o,s,i,n,r),r}function h(t,e,i,n,o,s){let r=0,c=0;for(let d=e;d<i;d++){const e=t[d],i=n[e];i?(c||(c=i.layoutHeight),o[d]=r+i.layoutWidth/2,r+=i.layoutWidth):(a.Z.warn("Missing character: "+e+" ("+e.codePointAt(0)+")")(),o[d]=r,r+=l)}s[0]=r,s[1]=c}function g(t,e,i,n,o){const s=Array.from(t),r=s.length,a=new Array(r),l=new Array(r),d=new Array(r),u=("break-word"===i||"break-all"===i)&&isFinite(n)&&n>0,g=[0,0],f=[0,0];let m=0,v=0,y=0;for(let w=0;w<=r;w++){const t=s[w];if("\n"!==t&&w!==r||(y=w),y>v){const t=u?p(s,i,n,o,v,y):c;for(let i=0;i<=t.length;i++){const n=0===i?v:t[i-1],r=i<t.length?t[i]:y;h(s,n,r,o,a,f);for(let t=n;t<r;t++){var _;const e=(null==(_=o[s[t]])?void 0:_.layoutOffsetY)||0;l[t]=m+f[1]/2+e,d[t]=f[0]}m+=f[1]*e,g[0]=Math.max(g[0],f[0])}v=y}"\n"===t&&(a[v]=0,l[v]=0,d[v]=0,v++)}return g[1]=m,{x:a,y:l,rowWidth:d,size:g}}class f{constructor(t){void 0===t&&(t=5),this._cache={},this._order=[],this.limit=t}get(t){const e=this._cache[t];return e&&(this._deleteOrder(t),this._appendOrder(t)),e}set(t,e){this._cache[t]?(this.delete(t),this._cache[t]=e,this._appendOrder(t)):(Object.keys(this._cache).length===this.limit&&this.delete(this._order[0]),this._cache[t]=e,this._appendOrder(t))}delete(t){this._cache[t]&&(delete this._cache[t],this._deleteOrder(t))}_deleteOrder(t){const e=this._order.indexOf(t);e>=0&&this._order.splice(e,1)}_appendOrder(t){this._order.push(t)}}const m={fontFamily:"Monaco, monospace",fontWeight:"normal",characterSet:function(){const t=[];for(let e=32;e<128;e++)t.push(String.fromCharCode(e));return t}(),fontSize:64,buffer:4,sdf:!1,cutoff:.25,radius:12,smoothing:.1},v=3;let y=new f(v);function _(t,e){for(let i=0;i<t.length;i++)e.data[4*i+3]=t[i]}function w(t,e,i,n){t.font=n+" "+i+"px "+e,t.fillStyle="#000",t.textBaseline="alphabetic",t.textAlign="left"}class b{constructor(){this.props={...m}}get texture(){return this._atlas}get mapping(){return this._atlas&&this._atlas.mapping}get scale(){const{fontSize:t,buffer:e}=this.props;return(1.2*t+2*e)/t}setProps(t){void 0===t&&(t={}),Object.assign(this.props,t),this._key=this._getKey();const e=function(t,e){let i;i="string"==typeof e?new Set(Array.from(e)):new Set(e);const n=y.get(t);if(!n)return i;for(const o in n.mapping)i.has(o)&&i.delete(o);return i}(this._key,this.props.characterSet),i=y.get(this._key);if(i&&0===e.size)return void(this._atlas!==i&&(this._atlas=i));const n=this._generateFontAtlas(e,i);this._atlas=n,y.set(this._key,n)}_generateFontAtlas(t,e){const{fontFamily:i,fontWeight:n,fontSize:o,buffer:s,sdf:a,radius:l,cutoff:c}=this.props;let d=e&&e.data;d||(d=document.createElement("canvas"),d.width=1024);const u=d.getContext("2d",{willReadFrequently:!0});w(u,i,o,n);const{mapping:p,canvasHeight:h,xOffset:g,yOffset:f}=function(t){let{characterSet:e,getFontWidth:i,fontHeight:n,buffer:o,maxCanvasWidth:s,mapping:r={},xOffset:a=0,yOffset:l=0}=t,c=0,d=a;const u=n+2*o;for(const h of e)if(!r[h]){const t=i(h);d+t+2*o>s&&(d=0,c++),r[h]={x:d+o,y:l+c*u+o,width:t,height:u,layoutWidth:t,layoutHeight:n},d+=t+2*o}return{mapping:r,xOffset:d,yOffset:l+c*u,canvasHeight:(p=l+(c+1)*u,Math.pow(2,Math.ceil(Math.log2(p))))};var p}({getFontWidth:t=>u.measureText(t).width,fontHeight:1.2*o,buffer:s,characterSet:t,maxCanvasWidth:1024,...e&&{mapping:e.mapping,xOffset:e.xOffset,yOffset:e.yOffset}});if(d.height!==h){const t=u.getImageData(0,0,d.width,d.height);d.height=h,u.putImageData(t,0,0)}if(w(u,i,o,n),a){const e=new r.Z({fontSize:o,buffer:s,radius:l,cutoff:c,fontFamily:i,fontWeight:""+n});for(const i of t){const{data:t,width:n,height:s,glyphTop:r}=e.draw(i);p[i].width=n,p[i].layoutOffsetY=.9*o-r;const a=u.createImageData(n,s);_(t,a),u.putImageData(a,p[i].x,p[i].y)}}else for(const r of t)u.fillText(r,p[r].x,p[r].y+s+.9*o);return{xOffset:g,yOffset:f,mapping:p,data:d,width:d.width,height:d.height}}_getKey(){const{fontFamily:t,fontWeight:e,fontSize:i,buffer:n,sdf:o,radius:s,cutoff:r}=this.props;return o?t+" "+e+" "+i+" "+n+" "+s+" "+r:t+" "+e+" "+i+" "+n}}var P=i(17495);const x={start:1,middle:0,end:-1},C={top:1,center:0,bottom:-1},S=[0,0,0,255],L={billboard:!0,sizeScale:1,sizeUnits:"pixels",sizeMinPixels:0,sizeMaxPixels:Number.MAX_SAFE_INTEGER,background:!1,getBackgroundColor:{type:"accessor",value:[255,255,255,255]},getBorderColor:{type:"accessor",value:S},getBorderWidth:{type:"accessor",value:0},backgroundPadding:{type:"array",value:[0,0,0,0]},characterSet:{type:"object",value:m.characterSet},fontFamily:m.fontFamily,fontWeight:m.fontWeight,lineHeight:1,outlineWidth:{type:"number",value:0,min:0},outlineColor:{type:"color",value:S},fontSettings:{},wordBreak:"break-word",maxWidth:{type:"number",value:-1},getText:{type:"accessor",value:t=>t.text},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:S},getSize:{type:"accessor",value:32},getAngle:{type:"accessor",value:0},getTextAnchor:{type:"accessor",value:"middle"},getAlignmentBaseline:{type:"accessor",value:"center"},getPixelOffset:{type:"accessor",value:[0,0]},backgroundColor:{deprecatedFor:["background","getBackgroundColor"]}};class M extends n.Z{constructor(){super(...arguments),this.getBoundingRect=(t,e)=>{const i=this.state.fontAtlasManager.mapping,n=this.state.getText,{wordBreak:o,maxWidth:s,lineHeight:r,getTextAnchor:a,getAlignmentBaseline:l}=this.props,c=n(t,e)||"",{size:[d,u]}=g(c,r,o,s,i);return[(x["function"==typeof a?a(t,e):a]-1)*d/2,(C["function"==typeof l?l(t,e):l]-1)*u/2,d,u]},this.getIconOffsets=(t,e)=>{const i=this.state.fontAtlasManager.mapping,n=this.state.getText,{wordBreak:o,maxWidth:s,lineHeight:r,getTextAnchor:a,getAlignmentBaseline:l}=this.props,c=n(t,e)||"",{x:d,y:u,rowWidth:p,size:[h,f]}=g(c,r,o,s,i),m=x["function"==typeof a?a(t,e):a],v=C["function"==typeof l?l(t,e):l],y=d.length,_=new Array(2*y);let w=0;for(let g=0;g<y;g++){const t=(1-m)*(h-p[g])/2;_[w++]=(m-1)*h/2+t+d[g],_[w++]=(v-1)*f/2+u[g]}return _}}initializeState(){this.state={styleVersion:0,fontAtlasManager:new b}}updateState(t){const{props:e,oldProps:i,changeFlags:n}=t;(n.dataChanged||n.updateTriggersChanged&&(n.updateTriggersChanged.all||n.updateTriggersChanged.getText))&&this._updateText();(this._updateFontAtlas()||e.lineHeight!==i.lineHeight||e.wordBreak!==i.wordBreak||e.maxWidth!==i.maxWidth)&&this.setState({styleVersion:this.state.styleVersion+1})}getPickingInfo(t){let{info:e}=t;return e.object=e.index>=0?this.props.data[e.index]:null,e}_updateFontAtlas(){const{fontSettings:t,fontFamily:e,fontWeight:i}=this.props,{fontAtlasManager:n,characterSet:o}=this.state,s={...t,characterSet:o,fontFamily:e,fontWeight:i};if(!n.mapping)return n.setProps(s),!0;for(const r in s)if(s[r]!==n.props[r])return n.setProps(s),!0;return!1}_updateText(){var t;const{data:e,characterSet:i}=this.props,n=null==(t=e.attributes)?void 0:t.getText;let s,{getText:r}=this.props,a=e.startIndices;const l="auto"===i&&new Set;if(n&&a){const{texts:t,characterCount:i}=function(t){let{value:e,length:i,stride:n,offset:o,startIndices:s,characterSet:r}=t;const a=e.BYTES_PER_ELEMENT,l=n?n/a:1,c=o?o/a:0,d=s[i]||Math.ceil((e.length-c)/l),u=r&&new Set,p=new Array(i);let h=e;if(l>1||c>0){h=new(0,e.constructor)(d);for(let t=0;t<d;t++)h[t]=e[t*l+c]}for(let g=0;g<i;g++){const t=s[g],e=s[g+1]||d,i=h.subarray(t,e);p[g]=String.fromCodePoint.apply(null,i),u&&i.forEach(u.add,u)}if(u)for(const g of u)r.add(String.fromCodePoint(g));return{texts:p,characterCount:d}}({...ArrayBuffer.isView(n)?{value:n}:n,length:e.length,startIndices:a,characterSet:l});s=i,r=(e,i)=>{let{index:n}=i;return t[n]}}else{const{iterable:t,objectInfo:i}=(0,o.jB)(e);a=[0],s=0;for(const e of t){i.index++;const t=Array.from(r(e,i)||"");l&&t.forEach(l.add,l),s+=t.length,a.push(s)}}this.setState({getText:r,startIndices:a,numInstances:s,characterSet:l||i})}renderLayers(){const{startIndices:t,numInstances:e,getText:i,fontAtlasManager:{scale:n,texture:o,mapping:r},styleVersion:a}=this.state,{data:l,_dataDiff:c,getPosition:d,getColor:u,getSize:p,getAngle:h,getPixelOffset:g,getBackgroundColor:f,getBorderColor:v,getBorderWidth:y,backgroundPadding:_,background:w,billboard:b,fontSettings:x,outlineWidth:C,outlineColor:S,sizeScale:L,sizeUnits:M,sizeMinPixels:k,sizeMaxPixels:T,transitions:E,updateTriggers:I}=this.props,A=this.getSubLayerClass("characters",s.Z),O=this.getSubLayerClass("background",P.Z);return[w&&new O({getFillColor:f,getLineColor:v,getLineWidth:y,padding:_,getPosition:d,getSize:p,getAngle:h,getPixelOffset:g,billboard:b,sizeScale:L/this.state.fontAtlasManager.props.fontSize,sizeUnits:M,sizeMinPixels:k,sizeMaxPixels:T,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getSize:E.getSize,getFillColor:E.getBackgroundColor,getLineColor:E.getBorderColor,getLineWidth:E.getBorderWidth,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"background",updateTriggers:{getPosition:I.getPosition,getAngle:I.getAngle,getSize:I.getSize,getFillColor:I.getBackgroundColor,getLineColor:I.getBorderColor,getLineWidth:I.getBorderWidth,getPixelOffset:I.getPixelOffset,getBoundingRect:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:a}}}),{data:l.attributes&&l.attributes.background?{length:l.length,attributes:l.attributes.background}:l,_dataDiff:c,autoHighlight:!1,getBoundingRect:this.getBoundingRect}),new A({sdf:x.sdf,smoothing:Number.isFinite(x.smoothing)?x.smoothing:m.smoothing,outlineWidth:C/(x.radius||m.radius),outlineColor:S,iconAtlas:o,iconMapping:r,getPosition:d,getColor:u,getSize:p,getAngle:h,getPixelOffset:g,billboard:b,sizeScale:L*n,sizeUnits:M,sizeMinPixels:k*n,sizeMaxPixels:T*n,transitions:E&&{getPosition:E.getPosition,getAngle:E.getAngle,getColor:E.getColor,getSize:E.getSize,getPixelOffset:E.getPixelOffset}},this.getSubLayerProps({id:"characters",updateTriggers:{getIcon:I.getText,getPosition:I.getPosition,getAngle:I.getAngle,getColor:I.getColor,getSize:I.getSize,getPixelOffset:I.getPixelOffset,getIconOffsets:{getText:I.getText,getTextAnchor:I.getTextAnchor,getAlignmentBaseline:I.getAlignmentBaseline,styleVersion:a}}}),{data:l,_dataDiff:c,startIndices:t,numInstances:e,getIconOffsets:this.getIconOffsets,getIcon:i})]}static set fontAtlasCacheLimit(t){!function(t){a.Z.assert(Number.isFinite(t)&&t>=v,"Invalid cache limit"),y=new f(t)}(t)}}M.defaultProps=L,M.layerName="TextLayer"},46025:(t,e,i)=>{"use strict";function n(t){let{data:e,getIndex:i,dataRange:n,replace:o}=t;const{startRow:s=0,endRow:r=1/0}=n,a=e.length;let l=a,c=a;for(let p=0;p<a;p++){const t=i(e[p]);if(l>p&&t>=s&&(l=p),t>=r){c=p;break}}let d=l;const u=c-l!==o.length?e.slice(c):void 0;for(let p=0;p<o.length;p++)e[d++]=o[p];if(u){for(let t=0;t<u.length;t++)e[d++]=u[t];e.length=d}return{startRow:l,endRow:l+o.length}}i.d(e,{b:()=>n})},16103:(t,e,i)=>{"use strict";i.d(e,{Z:()=>m});var n=i(67294),o=i(83779);const s="undefined"!=typeof window?n.useLayoutEffect:n.useEffect;function r(t,e){for(;t;){if(t===e)return!0;t=Object.getPrototypeOf(t)}return!1}var a=i(45213),l=i(47251);const c={position:"absolute",zIndex:-1};function d(t,e){if("function"==typeof t)return t(e);if(Array.isArray(t))return t.map((t=>d(t,e)));if(u(t)){if(function(t){const e=t.type,i=e&&e.defaultProps;return i&&i.mapStyle}(t))return e.style=c,(0,n.cloneElement)(t,e);if(function(t){const e=t.type;return e&&e.deckGLViewProps}(t))return(0,n.cloneElement)(t,e)}return t}function u(t){return t&&"object"==typeof t&&"type"in t||!1}function p(t){if("function"==typeof t)return(0,n.createElement)(a.Z,{},t);if(Array.isArray(t))return t.map(p);if(u(t)){if(t.type===n.Fragment)return p(t.props.children);if(r(t.type,a.Z))return t}return t}const h={mixBlendMode:null};function g(t){t.redrawReason&&(t.deck._drawLayers(t.redrawReason),t.redrawReason=null)}const f=(0,n.forwardRef)(((t,e)=>{const[i,c]=(0,n.useState)(0),f=(0,n.useRef)({control:null,version:i,forceUpdate:()=>c((t=>t+1))}).current,m=(0,n.useRef)(null),v=(0,n.useRef)(null),y=(0,n.useMemo)((()=>function(t){let{children:e,layers:i=[],views:o=null}=t;const s=[],c=[],d={};return n.Children.forEach(p(e),(t=>{if(u(t)){const e=t.type;if(r(e,l.Z)){const i=function(t,e){const i={},n=t.defaultProps||{};for(const o in e)n[o]!==e[o]&&(i[o]=e[o]);return new t(i)}(e,t.props);c.push(i)}else s.push(t);if(r(e,a.Z)&&e!==a.Z&&t.props.id){const i=new e(t.props);d[i.id]=i}}else t&&s.push(t)})),Object.keys(d).length>0&&(Array.isArray(o)?o.forEach((t=>{d[t.id]=t})):o&&(d[o.id]=o),o=Object.values(d)),i=c.length>0?[...c,...i]:i,{layers:i,children:s,views:o}}(t)),[t.layers,t.views,t.children]);let _=!0;const w=e=>_&&t.viewState?(f.viewStateUpdateRequested=e,null):(f.viewStateUpdateRequested=null,null==t.onViewStateChange?void 0:t.onViewStateChange(e)),b=e=>{_?f.interactionStateUpdateRequested=e:(f.interactionStateUpdateRequested=null,null==t.onInteractionStateChange||t.onInteractionStateChange(e))},P=(0,n.useMemo)((()=>{const e={...t,style:null,width:"100%",height:"100%",parent:m.current,canvas:v.current,layers:y.layers,views:y.views,onViewStateChange:w,onInteractionStateChange:b};return delete e._customRender,f.deck&&f.deck.setProps(e),e}),[t]);(0,n.useEffect)((()=>{const e=t.Deck||o.Z;return f.deck=function(t,e,i){const n=new e({...i,_customRender:e=>{t.redrawReason=e;const i=n.getViewports();t.lastRenderedViewports!==i?t.forceUpdate():g(t)}});return n}(f,e,{...P,parent:m.current,canvas:v.current}),()=>{var t;return null==(t=f.deck)?void 0:t.finalize()}}),[]),s((()=>{g(f);const{viewStateUpdateRequested:t,interactionStateUpdateRequested:e}=f;t&&w(t),e&&b(e)})),(0,n.useImperativeHandle)(e,(()=>function(t){return{get deck(){return t.deck},pickObject:e=>t.deck.pickObject(e),pickMultipleObjects:e=>t.deck.pickMultipleObjects(e),pickObjects:e=>t.deck.pickObjects(e)}}(f)),[]);const x=f.deck&&f.deck.isInitialized?f.deck.getViewports():void 0,{ContextProvider:C,width:S,height:L,id:M,style:k}=t,{containerStyle:T,canvasStyle:E}=(0,n.useMemo)((()=>function(t){let{width:e,height:i,style:n}=t;const o={position:"absolute",zIndex:0,left:0,top:0,width:e,height:i},s={left:0,top:0};if(n)for(const r in n)r in h?s[r]=n[r]:o[r]=n[r];return{containerStyle:o,canvasStyle:s}}({width:S,height:L,style:k})),[S,L,k]);if(!f.viewStateUpdateRequested&&f.lastRenderedViewports===x||f.version!==i){f.lastRenderedViewports=x,f.version=i;const t=function(t){let{children:e,deck:i,ContextProvider:o}=t;const{viewManager:s}=i||{};if(!s||!s.views.length)return[];const l={},c=s.views[0].id;for(const n of e){let t=c,e=n;u(n)&&r(n.type,a.Z)&&(t=n.props.id||c,e=n.props.children);const i=s.getViewport(t),o=s.getViewState(t);if(i){o.padding=i.padding;const{x:n,y:s,width:r,height:a}=i;e=d(e,{x:n,y:s,width:r,height:a,viewport:i,viewState:o}),l[t]||(l[t]={viewport:i,children:[]}),l[t].children.push(e)}}return Object.keys(l).map((t=>{const{viewport:e,children:s}=l[t],{x:r,y:a,width:c,height:d}=e,u={position:"absolute",left:r,top:a,width:c,height:d},p="view-"+t,h=(0,n.createElement)("div",{key:p,id:p,style:u},...s);if(o){const s={viewport:e,container:i.canvas.offsetParent,eventManager:i.eventManager,onViewStateChange:e=>{e.viewId=t,i._onViewStateChange(e)}};return(0,n.createElement)(o,{key:p,value:s},h)}return h}))}({children:y.children,deck:f.deck,ContextProvider:C}),e=(0,n.createElement)("canvas",{key:"canvas",id:M||"deckgl-overlay",ref:v,style:E});f.control=(0,n.createElement)("div",{id:(M||"deckgl")+"-wrapper",ref:m,style:T},[e,t])}return _=!1,f.control}));f.defaultProps=o.Z.defaultProps;const m=f},27260:(t,e,i)=>{"use strict";i.d(e,{IM:()=>o,Sr:()=>n,fL:()=>s});const n={LIGHT:"https://deck.gl/mapstyle/deck-light.json",LIGHT_LABEL:"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",DARK:"https://deck.gl/mapstyle/deck-dark.json",BLANK:{version:8,sources:{},layers:[]}},o="https://raw.githubusercontent.com/visgl/deck.gl-data/master/website",s="https://github.com/visgl/deck.gl/tree/master"},44752:(t,e,i)=>{"use strict";i.d(e,{C:()=>c});const n=["dataComparator","fetch"],o=["autoHighlight","coordinateOrigin","coordinateSystem","highlightColor","modelMatrix","opacity","pickable","visible","wrapLongitude"],s={loaders:[],coordinateSystem:"COORDINATE_SYSTEM.LNGLAT",renderSubLayers:"props => new GeoJsonLayer(props)",characterSet:'" !\\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~"'};function r(t,e){if(!t.includes("\n")||0===e)return t;const i=t.split("\n");if(e>0){const t="".padStart(e," ");return i.map(((e,i)=>i>0?t+e:e)).join("\n")}return i.map(((t,i)=>i>0?t.slice(-e):t)).join("\n")}function a(t){return null==t?"null":"string"==typeof t?"'"+t+"'":"function"==typeof t?t.toString():Array.isArray(t)?"["+t.map(a).join(", ")+"]":t===Number.MAX_SAFE_INTEGER?"Number.MAX_SAFE_INTEGER":r(JSON.stringify(t,null,2),2)}function l(t,e){const i=[],l={};e=function(t){const e=t.split("\n");e.pop();const i={};let n,o=1/0;for(const s of e){const t=s.match(/^(\s*)(\w+):\s*(.*)/);t&&t[1].length<=o?(o=t[1].length,n=t[2],i[n]=t[3]):n&&(i[n]+="\n"+s)}for(n in i)i[n]=r(i[n].replace(/,\s*$/,""),2-o);return i}(e);let c=t.constructor,d=!1;const u=t.props[Symbol.for("asyncPropOriginal")],p=t.props[Symbol.for("asyncPropResolved")];function h(t,e,o,s){if(!l[t]&&!n.includes(t)){const n=(o?"// ":"")+t+": "+e+",";void 0===s?i.push(n):i.splice(s,0,n),l[t]=!0}}let g=1;for(h("id",a(t.id)),e.data&&h("data",e.data,!1,g++);c.layerName;){if(c.hasOwnProperty("defaultProps")){i.push("","/* props "+(d?"inherited from":"from")+" "+c.layerName+" class */","");const n=Object.keys(c.defaultProps).sort();for(const i of n){const n=c.defaultProps[i],r=!(i in u)&&!(i in p)&&!Object.hasOwnProperty.call(t.props,i);let l,d=!1;i in e?l=e[i]:(d=n&&n.deprecatedFor,d=d||i.startsWith("_"),d=d||n&&"accessor"===n.type&&"function"==typeof n.value,d=d||"Layer"===c.layerName&&!o.includes(i),l=u[i]||t.props[i],l="function"==typeof l?null:i in s?s[i]:a(l)),d||h(i,l,r)}}c=Object.getPrototypeOf(c),d=!0}for(const n in e)n in l||h(n,e[n],!1,g++);return i.join("\n  ")}function c(t,e){const{Layer:i,getTooltip:n,props:o,mapStyle:s=!0,dependencies:a=[],imports:c,initialViewState:d}=t,u=["DeckGL",i.layerName],p=[];if(c)for(const r in c)r[0]>="a"||(r.endsWith("Loader")?p.push(r):u.push(r));const h=r(JSON.stringify(d,null,2).replace(/"/g,""),2),g="const {"+u.join(", ")+"} = deck;\n"+(p.length?"const {"+p.join(", ")+"} = loaders;\n":"")+"\nconst layer = new "+i.layerName+"({\n  "+l(e,o)+"\n});\n\nnew DeckGL({\n  "+(s?"mapStyle: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',":"")+"\n  initialViewState: "+h+",\n  controller: true,\n  "+(n?"getTooltip: "+n+",":"")+"\n  layers: [layer]\n});\n  ";!function(t){let{dependencies:e=[],title:i,source:n}=t;const o={js_external:e.concat(["https://unpkg.com/deck.gl@latest/dist.min.js"]).join(";"),title:i,parent:48721472,tags:["webgl","data visualization"],editors:"001",css:"\n  body {\n    margin: 0;\n    width: 100vw;\n    height: 100vh;\n    overflow: hidden;\n  }\n  \n  .deck-tooltip {\n    font-size: 0.8em;\n    font-family: Helvetica, Arial, sans-serif;\n  }\n  ",js:"/*\n* "+window.location.href+"\n*/\n"+n},s=document.createElement("form");s.action="https://codepen.io/pen/define/",s.method="POST",s.style.display="none",document.body.appendChild(s);const r=document.createElement("input");r.type="text",r.name="data",r.value=JSON.stringify(o),s.appendChild(r),window.open("","deck-example-codepen"),s.target="deck-example-codepen",s.submit(),s.remove()}({dependencies:a.concat(["https://api.mapbox.com/mapbox-gl-js/v1.12.0/mapbox-gl.js"]),title:"deck.gl "+i.layerName,source:g})}},62757:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{v:()=>makeLayerDemo});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(67294),_deck_gl_react__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(16103),react_map_gl__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(33545),styled_components__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(19521),_constants_defaults__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(27260),_codepen_automation__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(44752);const INITIAL_VIEW_STATE={longitude:-122.4,latitude:37.74,zoom:11,maxZoom:20,pitch:30,bearing:0},TOOLTIP_STYLE={padding:"4px",background:"rgba(0, 0, 0, 0.8)",color:"#fff",maxWidth:"300px",fontSize:"10px",zIndex:9},DemoPlaceholder=styled_components__WEBPACK_IMPORTED_MODULE_4__.ZP.div.withConfig({displayName:"demo-base__DemoPlaceholder",componentId:"sc-bhdrci-0"})(["height:50vh;min-height:200px;position:relative;margin-bottom:24px;@media screen and (max-width:768px){height:60vh;}"]),DemoContainer=styled_components__WEBPACK_IMPORTED_MODULE_4__.ZP.div.withConfig({displayName:"demo-base__DemoContainer",componentId:"sc-bhdrci-1"})(["height:50vh;min-height:200px;position:absolute;width:100%;left:0;top:0;overflow:hidden;@media screen and (max-width:768px){height:60vh;}"]),DemoSourceLink=styled_components__WEBPACK_IMPORTED_MODULE_4__.ZP.div.withConfig({displayName:"demo-base__DemoSourceLink",componentId:"sc-bhdrci-2"})(["position:absolute;top:0;right:0;padding:8px;background:#fff;margin:12px;box-shadow:0 2px 4px rgba(0,0,0,0.3);cursor:pointer;font-weight:bold;font-size:12px;&:hover{color:var(--color-primary);}svg{width:20px;vertical-align:middle;margin-right:4px;}"]);function evalObject(source,globals,output){return eval("(function evalObject(globals){\n    Object.assign(globalThis, globals);\n    "+(output?source+"\n      return {"+output.join(",")+"};":"return "+source+";")+"\n  })")(globals)}function makeLayerDemo(config){const{Layer:Layer,getTooltip:getTooltip,props:props,mapStyle:mapStyle=_constants_defaults__WEBPACK_IMPORTED_MODULE_2__.Sr.LIGHT,initialViewState:initialViewState=INITIAL_VIEW_STATE,imports:imports}=config;function Demo(){const _getTooltip=getTooltip&&eval(getTooltip),styledGetTooltip=t=>{const e=_getTooltip&&_getTooltip(t);return e&&{text:e,style:TOOLTIP_STYLE}},layerProps=evalObject(props,imports),layer=new Layer(layerProps);return react__WEBPACK_IMPORTED_MODULE_0__.createElement(DemoPlaceholder,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(DemoContainer,null,react__WEBPACK_IMPORTED_MODULE_0__.createElement(_deck_gl_react__WEBPACK_IMPORTED_MODULE_5__.Z,{pickingRadius:5,initialViewState:initialViewState,getTooltip:styledGetTooltip,controller:!0,layers:[layer]},mapStyle&&react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_map_gl__WEBPACK_IMPORTED_MODULE_1__.D5,{reuseMaps:!0,mapLib:__webpack_require__.e(4613).then(__webpack_require__.t.bind(__webpack_require__,24613,23)),mapStyle:mapStyle,preventStyleDiffing:!0}))),react__WEBPACK_IMPORTED_MODULE_0__.createElement(DemoSourceLink,{onClick:()=>(0,_codepen_automation__WEBPACK_IMPORTED_MODULE_3__.C)(config,layer)},react__WEBPACK_IMPORTED_MODULE_0__.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24"},react__WEBPACK_IMPORTED_MODULE_0__.createElement("path",{d:"M0 0h24v24H0V0z",fill:"none"}),react__WEBPACK_IMPORTED_MODULE_0__.createElement("path",{d:"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"})),"Edit on Codepen"))}return config.initialViewState=initialViewState,react__WEBPACK_IMPORTED_MODULE_0__.memo(Demo)}},61413:(t,e,i)=>{"use strict";i.d(e,{$6:()=>P,J6:()=>w,LN:()=>y,N0:()=>b,Pt:()=>L,R2:()=>C,b:()=>x,eg:()=>_,sD:()=>S,sX:()=>k,xY:()=>M,zC:()=>T});var n=i(43631),o=i(62253),s=i(99147),r=i(68797),a=i(88123),l=i(31759),c=i(6735),d=i(16009),u=i(52329),p=i(76144),h=i(48148),g=i(24309),f=i(27800),m=i(62757),v=i(27260);const y=(0,m.v)({Layer:o.Z,getTooltip:"({object}) => object && `${object.from.name} to ${object.to.name}`",props:"{\n    data: '"+v.IM+"/bart-segments.json',\n    pickable: true,\n    getWidth: 12,\n    getSourcePosition: d => d.from.coordinates,\n    getTargetPosition: d => d.to.coordinates,\n    getSourceColor: d => [Math.sqrt(d.inbound), 140, 0],\n    getTargetColor: d => [Math.sqrt(d.outbound), 140, 0]\n  }"}),_=(0,m.v)({Layer:s.Z,props:"{\n    bounds: [-122.519, 37.7045, -122.355, 37.829],\n    image: '"+v.IM+"/sf-districts.png'\n  }"}),w=(0,m.v)({Layer:r.Z,getTooltip:"({object}) => object && `height: ${object.value * 5000}m`",props:"{\n    data: '"+v.IM+"/hexagons.json',\n    diskResolution: 12,\n    radius: 250,\n    extruded: true,\n    pickable: true,\n    elevationScale: 100,\n    getPosition: d => d.centroid,\n    getFillColor: d => [48, 128, d.value * 255, 255],\n    getLineColor: [0, 0, 0],\n    getLineWidth: 20,\n    getElevation: d => d.value * 50\n  }"}),b=(0,m.v)({Layer:a.Z,getTooltip:"({object}) => object && (object.properties.name || object.properties.station)",props:"{\n    data: '"+v.IM+"/bart.geo.json',\n    pickable: true,\n    stroked: false,\n    filled: true,\n    extruded: true,\n    lineWidthMinPixels: 2,\n    pointType: 'circle+text',\n    pointRadiusUnits: 'pixels',\n    getText: f => f.properties.name,\n    getTextSize: 12,\n    getFillColor: [160, 160, 180, 200],\n    getLineColor: f => {\n      const hex = f.properties.color;\n      // convert to RGB\n      return hex ? hex.match(/[0-9a-f]{2}/g).map(x => parseInt(x, 16)) : [0, 0, 0];\n    },\n    getPointRadius: 4,\n    getLineWidth: 20,\n    getElevation: 30\n  }"}),P=(0,m.v)({Layer:l.Z,getTooltip:"({object}) => object && `height: ${object.value * 5000}m`",props:"{\n    data: '"+v.IM+"/hexagons.json',\n    pickable: true,\n    extruded: true,\n    cellSize: 200,\n    elevationScale: 5000,\n    getPosition: d => d.centroid,\n    getFillColor: d => [48, 128, d.value * 255, 255],\n    getElevation: d => d.value\n  }"}),x=(0,m.v)({Layer:c.Z,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+v.IM+"/bart-stations.json',\n    pickable: true,\n    iconAtlas: '"+v.IM+"/icon-atlas.png',\n    iconMapping: {\n      marker: {\n        x: 0,\n        y: 0,\n        width: 128,\n        height: 128,\n        anchorY: 128,\n        mask: true\n      }\n    },\n    sizeScale: 8,\n    getPosition: d => d.coordinates,\n    getIcon: d => 'marker',\n    getSize: d => 5,\n    getColor: d => [Math.sqrt(d.exits), 140, 0]\n  }"}),C=(0,m.v)({Layer:d.Z,getTooltip:"({object}) => object && `${object.from.name} to ${object.to.name}`",props:"{\n    data: '"+v.IM+"/bart-segments.json',\n    pickable: true,\n    getWidth: 12,\n    getSourcePosition: d => d.from.coordinates,\n    getTargetPosition: d => d.to.coordinates,\n    getColor: d => [Math.sqrt(d.inbound + d.outbound), 140, 0]\n  }"}),S=(0,m.v)({Layer:u.Z,getTooltip:"({object}) => object && object.name",props:"{\n    data: '"+v.IM+"/bart-lines.json',\n    parameters: {\n      depthMask: false\n    },\n    pickable: true,\n    widthScale: 20,\n    widthMinPixels: 2,\n    getPath: d => d.path,\n    getColor: d => {\n      const hex = d.color;\n      // convert to RGB\n      return hex.match(/[0-9a-f]{2}/g).map(x => parseInt(x, 16));\n    },\n    getWidth: d => 5\n  }"}),L=(0,m.v)({Layer:p.Z,getTooltip:"({object}) => object && object.position.join(', ')",imports:{COORDINATE_SYSTEM:n.Df},props:"{\n    data: '"+v.IM+"/pointcloud.json',\n    pickable: false,\n    coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,\n    coordinateOrigin: [-122.4, 37.74],\n    pointSize: 2,\n    getPosition: d => d.position,\n    getNormal: d => d.normal,\n    getColor: d => d.color\n  }"}),M=(0,m.v)({Layer:h.Z,getTooltip:"({object}) => object && `${object.zipcode}\nPopulation: ${object.population}`",props:"{\n    data: '"+v.IM+"/sf-zipcodes.json',\n    pickable: true,\n    stroked: true,\n    filled: true,\n    extruded: true,\n    wireframe: true,\n    lineWidthMinPixels: 1,\n    getPolygon: d => d.contour,\n    getElevation: d => d.population / d.area / 10,\n    getFillColor: d => [d.population / d.area / 60, 140, 0],\n    getLineColor: [80, 80, 80],\n    getLineWidth: d => 1\n  }"}),k=(0,m.v)({Layer:g.Z,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+v.IM+"/bart-stations.json',\n    pickable: true,\n    opacity: 0.8,\n    stroked: true,\n    radiusScale: 6,\n    radiusMinPixels: 1,\n    radiusMaxPixels: 100,\n    lineWidthMinPixels: 1,\n    getPosition: d => d.coordinates,\n    getRadius: d => Math.sqrt(d.exits),\n    getFillColor: [255, 140, 0],\n    getLineColor: [0, 0, 0]\n  }"}),T=(0,m.v)({Layer:f.Z,getTooltip:"({object}) => object && `${object.name}\n${object.address}`",props:"{\n    data: '"+v.IM+"/bart-stations.json',\n    pickable: true,\n    sizeScale: 1,\n    getPosition: d => d.coordinates,\n    getText: d => d.name,\n    getSize: 16,\n    getAngle: 0,\n    getTextAnchor: 'middle',\n    getAlignmentBaseline: 'center'\n  }"})},19165:(t,e,i)=>{"use strict";i.r(e),i.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var n=i(87462),o=(i(67294),i(3905)),s=i(61413);const r={},a="IconLayer",l={unversionedId:"api-reference/layers/icon-layer",id:"api-reference/layers/icon-layer",title:"IconLayer",description:"The IconLayer renders raster icons at given coordinates.",source:"@site/../docs/api-reference/layers/icon-layer.md",sourceDirName:"api-reference/layers",slug:"/api-reference/layers/icon-layer",permalink:"/docs/api-reference/layers/icon-layer",draft:!1,editUrl:"https://github.com/visgl/deck.gl/tree/master/website/../docs/api-reference/layers/icon-layer.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"HexagonLayer",permalink:"/docs/api-reference/aggregation-layers/hexagon-layer"},next:{title:"LineLayer",permalink:"/docs/api-reference/layers/line-layer"}},c={},d=[{value:"Example: pre-packed iconAtlas",id:"example-pre-packed-iconatlas",level:2},{value:"Example: auto packing iconAtlas",id:"example-auto-packing-iconatlas",level:2},{value:"Installation",id:"installation",level:2},{value:"Properties",id:"properties",level:2},{value:"<code>iconAtlas</code> (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional)",id:"iconatlas",level:5},{value:"<code>iconMapping</code> (Object|String, optional)",id:"iconmapping",level:5},{value:"<code>sizeScale</code> (Number, optional) transition-enabled",id:"sizescale",level:5},{value:"<code>sizeUnits</code> (String, optional)",id:"sizeunits",level:5},{value:"<code>sizeMinPixels</code> (Number, optional) transition-enabled",id:"sizeminpixels",level:5},{value:"<code>sizeMaxPixels</code> (Number, optional) transition-enabled",id:"sizemaxpixels",level:5},{value:"<code>billboard</code> (Boolean, optional)",id:"billboard",level:5},{value:"<code>alphaCutoff</code> (Number, optional)",id:"alphacutoff",level:5},{value:"<code>loadOptions</code> (Object, optional)",id:"loadoptions",level:5},{value:"<code>textureParameters</code> (Object)",id:"textureparameters",level:5},{value:"Data Accessors",id:"data-accessors",level:3},{value:"<code>getIcon</code> (Function, optional)",id:"geticon",level:5},{value:"<code>getPosition</code> (Function, optional) transition-enabled",id:"getposition",level:5},{value:"<code>getSize</code> (Function|Number, optional) transition-enabled",id:"getsize",level:5},{value:"<code>getColor</code> (Function|Array, optional) transition-enabled",id:"getcolor",level:5},{value:"<code>getAngle</code> (Function|Number, optional) transition-enabled",id:"getangle",level:5},{value:"<code>getPixelOffset</code> (Function|Array, optional) transition-enabled",id:"getpixeloffset",level:5},{value:"Callbacks",id:"callbacks",level:3},{value:"<code>onIconError</code> (Function)",id:"oniconerror",level:5},{value:"Use binary attributes",id:"use-binary-attributes",level:2},{value:"Source",id:"source",level:2}],u={toc:d},p="wrapper";function h(t){let{components:e,...i}=t;return(0,o.kt)(p,(0,n.Z)({},u,i,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"iconlayer"},"IconLayer"),(0,o.kt)(s.b,{mdxType:"IconLayerDemo"}),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IconLayer")," renders raster icons at given coordinates."),(0,o.kt)("p",null,"There are two approaches to load icons. You can pre-generated a sprite image (",(0,o.kt)("inlineCode",{parentName:"p"},"iconAtlas"),"), which packs all your icons\ninto one layout, and a JSON descriptor (",(0,o.kt)("inlineCode",{parentName:"p"},"iconMapping"),"), which describes the position and size of each icon in the ",(0,o.kt)("inlineCode",{parentName:"p"},"iconAtlas"),".\nYou can create sprite images with tools such as ",(0,o.kt)("a",{parentName:"p",href:"https://www.codeandweb.com/texturepacker"},"TexturePacker"),". This is the\nmost efficient way to load icons."),(0,o.kt)("p",null,"It is also possible to ask ",(0,o.kt)("inlineCode",{parentName:"p"},"IconLayer")," to generate ",(0,o.kt)("inlineCode",{parentName:"p"},"iconAtlas")," dynamically. This is slower but might be useful in certain\nuse cases."),(0,o.kt)("h2",{id:"example-pre-packed-iconatlas"},"Example: pre-packed iconAtlas"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import DeckGL from '@deck.gl/react';\nimport {IconLayer} from '@deck.gl/layers';\n\nconst ICON_MAPPING = {\n  marker: {x: 0, y: 0, width: 128, height: 128, mask: true}\n};\n\nfunction App({data, viewState}) {\n  /**\n   * Data format:\n   * [\n   *   {name: 'Colma (COLM)', address: '365 D Street, Colma CA 94014', exits: 4214, coordinates: [-122.466233, 37.684638]},\n   *   ...\n   * ]\n   */\n  const layer = new IconLayer({\n    id: 'icon-layer',\n    data,\n    pickable: true,\n    // iconAtlas and iconMapping are required\n    // getIcon: return a string\n    iconAtlas: 'https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png',\n    iconMapping: ICON_MAPPING,\n    getIcon: d => 'marker',\n\n    sizeScale: 15,\n    getPosition: d => d.coordinates,\n    getSize: d => 5,\n    getColor: d => [Math.sqrt(d.exits), 140, 0]\n  });\n\n  return <DeckGL viewState={viewState}\n    layers={[layer]}\n    getTooltip={({object}) => object && `${object.name}\\n${object.address}`} />;\n}\n")),(0,o.kt)("h2",{id:"example-auto-packing-iconatlas"},"Example: auto packing iconAtlas"),(0,o.kt)("p",null,"In some use cases, it is not possible to know the icons that will be used. Instead, each icon needs to be fetched from\na programmatically generated URL at runtime. For example, if you want to visualize avatars of github contributors for\na project on a map, it is not convenient for you to generate the ",(0,o.kt)("inlineCode",{parentName:"p"},"iconAtlas")," with all the contributors' avatars.\nIn this case, you can follow the example. Auto packing icons is less efficient than pre-packed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import DeckGL, {IconLayer} from 'deck.gl';\nimport {Octokit} from '@octokit/rest';\nconst octokit = new Octokit()\n\nfunction App({data, viewState}) {\n  /**\n   * Data format:\n   * [\n   *   {\n   *     avatar_url: \"https://avatars1.githubusercontent.com/u/7025232?v=4\",\n   *     contributions: 620,\n   *     id: 7025232,\n   *     login: \"ibgreen\",\n   *     type: \"User\",\n   *     ...\n   *   }\n   * ]\n   */\n  const layer = new IconLayer({\n    id: 'icon-layer',\n    data: octokit.repos.getContributors({\n      owner: 'visgl',\n      repo: 'deck.gl'\n    }).then(result => result.data),\n    // iconAtlas and iconMapping should not be provided\n    // getIcon return an object which contains url to fetch icon of each data point\n    getIcon: d => ({\n      url: d.avatar_url,\n      width: 128,\n      height: 128,\n      anchorY: 128\n    }),\n    // icon size is based on data point's contributions, between 2 - 25\n    getSize: d => Math.max(2, Math.min(d.contributions / 1000 * 25, 25)),\n    pickable: true,\n    sizeScale: 15,\n    getPosition: d => d.coordinates\n  });\n\n  return <DeckGL viewState={viewState}\n    layers={[layer]}\n    getTooltip={({object}) => object && `${object.login}\\n${object.contributions}`} />;\n}\n")),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"To install the dependencies from NPM:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"npm install deck.gl\n# or\nnpm install @deck.gl/core @deck.gl/layers\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import {IconLayer} from '@deck.gl/layers';\nnew IconLayer({});\n")),(0,o.kt)("p",null,"To use pre-bundled scripts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<script src="https://unpkg.com/deck.gl@^8.0.0/dist.min.js"><\/script>\n\x3c!-- or --\x3e\n<script src="https://unpkg.com/@deck.gl/core@^8.0.0/dist.min.js"><\/script>\n<script src="https://unpkg.com/@deck.gl/layers@^8.0.0/dist.min.js"><\/script>\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"new deck.IconLayer({});\n")),(0,o.kt)("h2",{id:"properties"},"Properties"),(0,o.kt)("p",null,"Inherits from all ",(0,o.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer"},"Base Layer")," properties."),(0,o.kt)("h5",{id:"iconatlas"},(0,o.kt)("inlineCode",{parentName:"h5"},"iconAtlas")," (String|Texture2D|Image|ImageData|HTMLCanvasElement|HTMLVideoElement|ImageBitmap|Promise|Object, optional)"),(0,o.kt)("p",null,"A pre-packed image that contains all icons."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If a string is supplied, it is interpreted as a URL or a ",(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs"},"Data URL"),"."),(0,o.kt)("li",{parentName:"ul"},"One of the following, or a Promise that resolves to one of the following:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"One of the valid ",(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D"},"pixel sources for WebGL texture")),(0,o.kt)("li",{parentName:"ul"},"A luma.gl ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/visgl/luma.gl/blob/8.5-release/modules/webgl/docs/api-reference/texture-2d.md"},"Texture2D")," instance"),(0,o.kt)("li",{parentName:"ul"},"A plain object that can be passed to the ",(0,o.kt)("inlineCode",{parentName:"li"},"Texture2D")," constructor, e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"{width: <number>, height: <number>, data: <Uint8Array>}"),". Note that whenever this object shallowly changes, a new texture will be created.")))),(0,o.kt)("p",null,"The image data will be converted to a ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/visgl/luma.gl/blob/8.5-release/modules/webgl/docs/api-reference/texture-2d.md"},"Texture2D")," object. See ",(0,o.kt)("inlineCode",{parentName:"p"},"textureParameters")," prop for advanced customization."),(0,o.kt)("p",null,"If you go with pre-packed strategy, this prop is required."),(0,o.kt)("p",null,"If you choose to use auto packing, this prop should be left empty."),(0,o.kt)("h5",{id:"iconmapping"},(0,o.kt)("inlineCode",{parentName:"h5"},"iconMapping")," (Object|String, optional)"),(0,o.kt)("p",null,"Icon names mapped to icon definitions, or a URL to load such mapping from a JSON file. Each icon is defined with the following values:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"x")," (Number, required): x position of icon on the atlas image"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"y")," (Number, required): y position of icon on the atlas image"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"width")," (Number, required): width of icon on the atlas image"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"height")," (Number, required): height of icon on the atlas image"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"anchorX")," (Number, optional): horizontal position of icon anchor. Default: half width."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"anchorY")," (Number, optional): vertical position of icon anchor. Default: half height."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mask")," (Boolean, optional): whether icon is treated as a transparency mask.\nIf ",(0,o.kt)("inlineCode",{parentName:"li"},"true"),", user defined color is applied.\nIf ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),", pixel color from the image is applied. User still can specify the opacity through getColor.\nDefault: ",(0,o.kt)("inlineCode",{parentName:"li"},"false"))),(0,o.kt)("p",null,"If you go with pre-packed strategy, this prop is required."),(0,o.kt)("p",null,"If you choose to use auto packing, this prop should be left empty."),(0,o.kt)("h5",{id:"sizescale"},(0,o.kt)("inlineCode",{parentName:"h5"},"sizeScale")," (Number, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"1"))),(0,o.kt)("p",null,"Icon size multiplier."),(0,o.kt)("h5",{id:"sizeunits"},(0,o.kt)("inlineCode",{parentName:"h5"},"sizeUnits")," (String, optional)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"pixels"))),(0,o.kt)("p",null,"The units of the size, one of ",(0,o.kt)("inlineCode",{parentName:"p"},"'meters'"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"'common'"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"'pixels'"),". See ",(0,o.kt)("a",{parentName:"p",href:"/docs/developer-guide/coordinate-systems#supported-units"},"unit system"),"."),(0,o.kt)("h5",{id:"sizeminpixels"},(0,o.kt)("inlineCode",{parentName:"h5"},"sizeMinPixels")," (Number, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"0"))),(0,o.kt)("p",null,"The minimum size in pixels. When using non-pixel ",(0,o.kt)("inlineCode",{parentName:"p"},"sizeUnits"),", this prop can be used to prevent the icon from getting too small when zoomed out."),(0,o.kt)("h5",{id:"sizemaxpixels"},(0,o.kt)("inlineCode",{parentName:"h5"},"sizeMaxPixels")," (Number, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"Number.MAX_SAFE_INTEGER"))),(0,o.kt)("p",null,"The maximum size in pixels. When using non-pixel ",(0,o.kt)("inlineCode",{parentName:"p"},"sizeUnits"),", this prop can be used to prevent the icon from getting too big when zoomed in."),(0,o.kt)("h5",{id:"billboard"},(0,o.kt)("inlineCode",{parentName:"h5"},"billboard")," (Boolean, optional)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"true"))),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),", the icon always faces camera. Otherwise the icon faces up (z)."),(0,o.kt)("h5",{id:"alphacutoff"},(0,o.kt)("inlineCode",{parentName:"h5"},"alphaCutoff")," (Number, optional)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"0.05"))),(0,o.kt)("p",null,'Discard pixels whose opacity is below this threshold. A discarded pixel would create a "hole" in the icon that is not considered part of the object. This is useful for customizing picking behavior, e.g. setting ',(0,o.kt)("inlineCode",{parentName:"p"},"alphaCutoff: 0, autoHighlight")," will highlight an object whenever the cursor moves into its bounding box, instead of over the visible pixels."),(0,o.kt)("h5",{id:"loadoptions"},(0,o.kt)("inlineCode",{parentName:"h5"},"loadOptions")," (Object, optional)"),(0,o.kt)("p",null,"On top of the ",(0,o.kt)("a",{parentName:"p",href:"/docs/api-reference/core/layer#loadoptions"},"default options"),", also accepts options for the following loaders:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://loaders.gl/modules/images/docs/api-reference/image-loader"},"ImageLoader")," if the ",(0,o.kt)("inlineCode",{parentName:"li"},"iconAtlas")," prop is an URL, or if ",(0,o.kt)("inlineCode",{parentName:"li"},"getIcon")," returns URLs for auto-packing")),(0,o.kt)("h5",{id:"textureparameters"},(0,o.kt)("inlineCode",{parentName:"h5"},"textureParameters")," (Object)"),(0,o.kt)("p",null,"Customize the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter"},"texture parameters"),"."),(0,o.kt)("p",null,"If not specified, the layer uses the following defaults to create a linearly smoothed texture from ",(0,o.kt)("inlineCode",{parentName:"p"},"iconAtlas"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"{\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n}\n")),(0,o.kt)("h3",{id:"data-accessors"},"Data Accessors"),(0,o.kt)("h5",{id:"geticon"},(0,o.kt)("inlineCode",{parentName:"h5"},"getIcon")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),", optional)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"d => d.icon"))),(0,o.kt)("p",null,"Method called to retrieve the icon name of each object, returns string or object."),(0,o.kt)("p",null,"If you go with pre-packed strategy, then ",(0,o.kt)("inlineCode",{parentName:"p"},"getIcon")," should return a string representing name of the icon,\nused to retrieve icon definition from given ",(0,o.kt)("inlineCode",{parentName:"p"},"iconMapping"),"."),(0,o.kt)("p",null,"If you choose to use auto packing, then ",(0,o.kt)("inlineCode",{parentName:"p"},"getIcon")," should return an object which contains\nthe following properties."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"url")," (String, required): url to fetch the icon"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"height")," (Number, required): max height of icon"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"width")," (Number, required): max width of icon"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"id"),": (String, optional): unique identifier of the icon, fall back to ",(0,o.kt)("inlineCode",{parentName:"li"},"url")," if not specified"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"anchorX"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"anchorY"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"mask")," are the same as mentioned in ",(0,o.kt)("inlineCode",{parentName:"li"},"iconMapping"))),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"IconLayer")," uses ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," (fallback to ",(0,o.kt)("inlineCode",{parentName:"p"},"url"),") to dedupe icons. For icons with the same id, even if their sizes differ, ",(0,o.kt)("inlineCode",{parentName:"p"},"IconLayer")," will only define one icon according to the first occurrence and ignore the rest of them. Vice versa, for icons with different ids, even if ",(0,o.kt)("inlineCode",{parentName:"p"},"url"),"s are the same, the image will be fetched again to create a new definition with different size, anchor, etc."),(0,o.kt)("p",null,"The image loaded from ",(0,o.kt)("inlineCode",{parentName:"p"},"url")," is always resized to fit the box defined by ",(0,o.kt)("inlineCode",{parentName:"p"},"[width, height]")," while preserving its aspect ratio."),(0,o.kt)("h5",{id:"getposition"},(0,o.kt)("inlineCode",{parentName:"h5"},"getPosition")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),", optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"d => d.position"))),(0,o.kt)("p",null,"Method called to retrieve the position of each object, returns ",(0,o.kt)("inlineCode",{parentName:"p"},"[lng, lat, z]"),"."),(0,o.kt)("h5",{id:"getsize"},(0,o.kt)("inlineCode",{parentName:"h5"},"getSize")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),"|Number, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"1"))),(0,o.kt)("p",null,"The height of each object, in units specified by ",(0,o.kt)("inlineCode",{parentName:"p"},"sizeUnits")," (default pixels)."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If a number is provided, it is used as the size for all objects."),(0,o.kt)("li",{parentName:"ul"},"If a function is provided, it is called on each object to retrieve its size.")),(0,o.kt)("h5",{id:"getcolor"},(0,o.kt)("inlineCode",{parentName:"h5"},"getColor")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),"|Array, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"[0, 0, 0, 255]"))),(0,o.kt)("p",null,"The rgba color is in the format of ",(0,o.kt)("inlineCode",{parentName:"p"},"[r, g, b, [a]]"),". Each channel is a number between 0-255 and ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," is 255 if not supplied."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If an array is provided, it is used as the color for all objects."),(0,o.kt)("li",{parentName:"ul"},"If a function is provided, it is called on each object to retrieve its color."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"mask")," = false, only the alpha component will be used to control the opacity of the icon.")),(0,o.kt)("h5",{id:"getangle"},(0,o.kt)("inlineCode",{parentName:"h5"},"getAngle")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),"|Number, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"0"))),(0,o.kt)("p",null,"The rotating angle  of each object, in degrees."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If a number is provided, it is used as the angle for all objects."),(0,o.kt)("li",{parentName:"ul"},"If a function is provided, it is called on each object to retrieve its angle.")),(0,o.kt)("h5",{id:"getpixeloffset"},(0,o.kt)("inlineCode",{parentName:"h5"},"getPixelOffset")," (",(0,o.kt)("a",{parentName:"h5",href:"/docs/developer-guide/using-layers#accessors"},"Function"),"|Array, optional) ",(0,o.kt)("img",{parentName:"h5",src:"https://img.shields.io/badge/transition-enabled-green.svg?style=flat-square%22",alt:"transition-enabled"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"[0, 0]"))),(0,o.kt)("p",null,"Screen space offset relative to the ",(0,o.kt)("inlineCode",{parentName:"p"},"coordinates")," in pixel unit."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"If an array is provided, it is used as the offset for all objects."),(0,o.kt)("li",{parentName:"ul"},"If a function is provided, it is called on each object to retrieve its offset.")),(0,o.kt)("h3",{id:"callbacks"},"Callbacks"),(0,o.kt)("h5",{id:"oniconerror"},(0,o.kt)("inlineCode",{parentName:"h5"},"onIconError")," (Function)"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Default: ",(0,o.kt)("inlineCode",{parentName:"li"},"null"))),(0,o.kt)("p",null,"Only used when using auto-packing. If the attempt to fetch an icon returned by ",(0,o.kt)("inlineCode",{parentName:"p"},"getIcon")," fails, this callback is called with the following arguments:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"event")," (Object)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"url")," (String) - the URL that was trying to fetch"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"loadOptions")," (Object) - the load options used for the fetch"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"source")," (Object) - the original data object that requested this icon"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"sourceIndex")," (Object) - the index of the original data object that requested this icon"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"error")," (Error)")))),(0,o.kt)("h2",{id:"use-binary-attributes"},"Use binary attributes"),(0,o.kt)("p",null,"This section is about the special requirements when ",(0,o.kt)("a",{parentName:"p",href:"/docs/developer-guide/performance#supply-attributes-directly"},"supplying attributes directly")," to an ",(0,o.kt)("inlineCode",{parentName:"p"},"IconLayer"),"."),(0,o.kt)("p",null,"If ",(0,o.kt)("inlineCode",{parentName:"p"},"data.attributes.getIcon")," is supplied, since its value can only be a typed array, ",(0,o.kt)("inlineCode",{parentName:"p"},"iconMapping")," can only use integers as keys."),(0,o.kt)("h2",{id:"source"},"Source"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/visgl/deck.gl/tree/master/modules/layers/src/icon-layer"},"modules/layers/src/icon-layer")))}h.isMDXComponent=!0},96070:()=>{},39875:(t,e,i)=>{"use strict";i.d(e,{Z:()=>o});const n=1e20;class o{constructor({fontSize:t=24,buffer:e=3,radius:i=8,cutoff:n=.25,fontFamily:o="sans-serif",fontWeight:s="normal",fontStyle:r="normal"}={}){this.buffer=e,this.cutoff=n,this.radius=i;const a=this.size=t+4*e,l=this._createCanvas(a),c=this.ctx=l.getContext("2d",{willReadFrequently:!0});c.font=`${r} ${s} ${t}px ${o}`,c.textBaseline="alphabetic",c.textAlign="left",c.fillStyle="black",this.gridOuter=new Float64Array(a*a),this.gridInner=new Float64Array(a*a),this.f=new Float64Array(a),this.z=new Float64Array(a+1),this.v=new Uint16Array(a)}_createCanvas(t){const e=document.createElement("canvas");return e.width=e.height=t,e}draw(t){const{width:e,actualBoundingBoxAscent:i,actualBoundingBoxDescent:o,actualBoundingBoxLeft:r,actualBoundingBoxRight:a}=this.ctx.measureText(t),l=Math.ceil(i),c=Math.max(0,Math.min(this.size-this.buffer,Math.ceil(a-r))),d=Math.min(this.size-this.buffer,l+Math.ceil(o)),u=c+2*this.buffer,p=d+2*this.buffer,h=Math.max(u*p,0),g=new Uint8ClampedArray(h),f={data:g,width:u,height:p,glyphWidth:c,glyphHeight:d,glyphTop:l,glyphLeft:0,glyphAdvance:e};if(0===c||0===d)return f;const{ctx:m,buffer:v,gridInner:y,gridOuter:_}=this;m.clearRect(v,v,c,d),m.fillText(t,v,v+l);const w=m.getImageData(v,v,c,d);_.fill(n,0,h),y.fill(0,0,h);for(let s=0;s<d;s++)for(let t=0;t<c;t++){const e=w.data[4*(s*c+t)+3]/255;if(0===e)continue;const i=(s+v)*u+t+v;if(1===e)_[i]=0,y[i]=n;else{const t=.5-e;_[i]=t>0?t*t:0,y[i]=t<0?t*t:0}}s(_,0,0,u,p,u,this.f,this.v,this.z),s(y,v,v,c,d,u,this.f,this.v,this.z);for(let n=0;n<h;n++){const t=Math.sqrt(_[n])-Math.sqrt(y[n]);g[n]=Math.round(255-255*(t/this.radius+this.cutoff))}return f}}function s(t,e,i,n,o,s,a,l,c){for(let d=e;d<e+n;d++)r(t,i*s+d,s,o,a,l,c);for(let d=i;d<i+o;d++)r(t,d*s+e,1,n,a,l,c)}function r(t,e,i,o,s,r,a){r[0]=0,a[0]=-n,a[1]=n,s[0]=t[e];for(let l=1,c=0,d=0;l<o;l++){s[l]=t[e+l*i];const o=l*l;do{const t=r[c];d=(s[l]-s[t]+o-t*t)/(l-t)/2}while(d<=a[c]&&--c>-1);c++,r[c]=l,a[c]=d,a[c+1]=n}for(let n=0,l=0;n<o;n++){for(;a[l+1]<n;)l++;const o=r[l],c=n-o;t[e+n*i]=s[o]+c*c}}}}]);